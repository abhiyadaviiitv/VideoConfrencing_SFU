(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

/**
 * Expose `Emitter`.
 */

exports.Emitter = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
}

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function (event, fn) {
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }
  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }

  // Remove event specific arrays for event types that no
  // one is subscribed for to avoid memory leak.
  if (callbacks.length === 0) {
    delete this._callbacks['$' + event];
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function (event) {
  this._callbacks = this._callbacks || {};
  var args = new Array(arguments.length - 1),
    callbacks = this._callbacks['$' + event];
  for (var i = 1; i < arguments.length; i++) {
    args[i - 1] = arguments[i];
  }
  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }
  return this;
};

// alias used for reserved events (protected method)
Emitter.prototype.emitReserved = Emitter.prototype.emit;

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function (event) {
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function (event) {
  return !!this.listeners(event).length;
};

},{}],2:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o("next", 0), o("throw", 1), o("return", 2); } }, _regeneratorDefine2(e, r, n, t); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AwaitQueue = void 0;
var Logger_1 = require("./Logger");
var errors_1 = require("./errors");
var logger = new Logger_1.Logger('AwaitQueue');
var AwaitQueue = /*#__PURE__*/function () {
  function AwaitQueue() {
    _classCallCheck(this, AwaitQueue);
    // Queue of pending tasks (map of PendingTasks indexed by id).
    _defineProperty(this, "pendingTasks", new Map());
    // Incrementing PendingTask id.
    _defineProperty(this, "nextTaskId", 0);
    // Whether stop() method is stopping all pending tasks.
    _defineProperty(this, "stopping", false);
    logger.debug('constructor()');
  }
  return _createClass(AwaitQueue, [{
    key: "size",
    get: function get() {
      return this.pendingTasks.size;
    }
  }, {
    key: "push",
    value: function () {
      var _push = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(task, name) {
        var _this = this;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              name = name !== null && name !== void 0 ? name : task.name;
              logger.debug("push() [name:".concat(name, "]"));
              if (!(typeof task !== 'function')) {
                _context.n = 1;
                break;
              }
              throw new TypeError('given task is not a function');
            case 1:
              if (name) {
                try {
                  Object.defineProperty(task, 'name', {
                    value: name
                  });
                } catch (error) {}
              }
              return _context.a(2, new Promise(function (_resolve, _reject) {
                var pendingTask = {
                  id: _this.nextTaskId++,
                  task: task,
                  name: name,
                  enqueuedAt: Date.now(),
                  executedAt: undefined,
                  completed: false,
                  resolve: function resolve(result) {
                    // pendingTask.resolve() can only be called in execute() method. Since
                    // resolve() was called it means that the task successfully completed.
                    // However the task may have been stopped before it completed (via
                    // stop() or remove()) so its completed flag was already set. If this
                    // is the case, abort here since next task (if any) is already being
                    // executed.
                    if (pendingTask.completed) {
                      return;
                    }
                    pendingTask.completed = true;
                    // Remove the task from the queue.
                    _this.pendingTasks["delete"](pendingTask.id);
                    logger.debug("resolving task [name:".concat(pendingTask.name, "]"));
                    // Resolve the task with the obtained result.
                    _resolve(result);
                    // Execute the next pending task (if any).
                    var _this$pendingTasks$va = _this.pendingTasks.values(),
                      _this$pendingTasks$va2 = _slicedToArray(_this$pendingTasks$va, 1),
                      nextPendingTask = _this$pendingTasks$va2[0];
                    // NOTE: During the resolve() callback the user app may have interacted
                    // with the queue. For instance, the app may have pushed a task while
                    // the queue was empty so such a task is already being executed. If so,
                    // don't execute it twice.
                    if (nextPendingTask && !nextPendingTask.executedAt) {
                      void _this.execute(nextPendingTask);
                    }
                  },
                  reject: function reject(error) {
                    // pendingTask.reject() can be called within execute() method if the
                    // task completed with error. However it may have also been called in
                    // stop() or remove() methods (before or while being executed) so its
                    // completed flag was already set. If so, abort here since next task
                    // (if any) is already being executed.
                    if (pendingTask.completed) {
                      return;
                    }
                    pendingTask.completed = true;
                    // Remove the task from the queue.
                    _this.pendingTasks["delete"](pendingTask.id);
                    logger.debug("rejecting task [name:".concat(pendingTask.name, "]: %s"), String(error));
                    // Reject the task with the obtained error.
                    _reject(error);
                    // Execute the next pending task (if any) unless stop() is running.
                    if (!_this.stopping) {
                      var _this$pendingTasks$va3 = _this.pendingTasks.values(),
                        _this$pendingTasks$va4 = _slicedToArray(_this$pendingTasks$va3, 1),
                        nextPendingTask = _this$pendingTasks$va4[0];
                      // NOTE: During the reject() callback the user app may have interacted
                      // with the queue. For instance, the app may have pushed a task while
                      // the queue was empty so such a task is already being executed. If so,
                      // don't execute it twice.
                      if (nextPendingTask && !nextPendingTask.executedAt) {
                        void _this.execute(nextPendingTask);
                      }
                    }
                  }
                };
                // Append task to the queue.
                _this.pendingTasks.set(pendingTask.id, pendingTask);
                // And execute it if this is the only task in the queue.
                if (_this.pendingTasks.size === 1) {
                  void _this.execute(pendingTask);
                }
              }));
          }
        }, _callee);
      }));
      function push(_x, _x2) {
        return _push.apply(this, arguments);
      }
      return push;
    }()
  }, {
    key: "stop",
    value: function stop() {
      logger.debug('stop()');
      this.stopping = true;
      var _iterator = _createForOfIteratorHelper(this.pendingTasks.values()),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var pendingTask = _step.value;
          logger.debug("stop() | stopping task [name:".concat(pendingTask.name, "]"));
          pendingTask.reject(new errors_1.AwaitQueueStoppedError());
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      this.stopping = false;
    }
  }, {
    key: "remove",
    value: function remove(taskIdx) {
      logger.debug("remove() [taskIdx:".concat(taskIdx, "]"));
      var pendingTask = Array.from(this.pendingTasks.values())[taskIdx];
      if (!pendingTask) {
        logger.debug("stop() | no task with given idx [taskIdx:".concat(taskIdx, "]"));
        return;
      }
      pendingTask.reject(new errors_1.AwaitQueueRemovedTaskError());
    }
  }, {
    key: "dump",
    value: function dump() {
      var now = Date.now();
      var idx = 0;
      return Array.from(this.pendingTasks.values()).map(function (pendingTask) {
        return {
          idx: idx++,
          task: pendingTask.task,
          name: pendingTask.name,
          enqueuedTime: pendingTask.executedAt ? pendingTask.executedAt - pendingTask.enqueuedAt : now - pendingTask.enqueuedAt,
          executionTime: pendingTask.executedAt ? now - pendingTask.executedAt : 0
        };
      });
    }
  }, {
    key: "execute",
    value: function () {
      var _execute = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(pendingTask) {
        var result, _t;
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.n) {
            case 0:
              logger.debug("execute() [name:".concat(pendingTask.name, "]"));
              if (!pendingTask.executedAt) {
                _context2.n = 1;
                break;
              }
              throw new Error('task already being executed');
            case 1:
              pendingTask.executedAt = Date.now();
              _context2.p = 2;
              _context2.n = 3;
              return pendingTask.task();
            case 3:
              result = _context2.v;
              // Resolve the task with its resolved result (if any).
              pendingTask.resolve(result);
              _context2.n = 5;
              break;
            case 4:
              _context2.p = 4;
              _t = _context2.v;
              // Reject the task with its rejected error.
              pendingTask.reject(_t);
            case 5:
              return _context2.a(2);
          }
        }, _callee2, null, [[2, 4]]);
      }));
      function execute(_x3) {
        return _execute.apply(this, arguments);
      }
      return execute;
    }()
  }]);
}();
exports.AwaitQueue = AwaitQueue;

},{"./Logger":3,"./errors":4}],3:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Logger = void 0;
var debug = require("debug");
var LIB_NAME = 'awaitqueue';
var Logger = /*#__PURE__*/function () {
  function Logger(prefix) {
    _classCallCheck(this, Logger);
    _defineProperty(this, "_debug", void 0);
    _defineProperty(this, "_warn", void 0);
    _defineProperty(this, "_error", void 0);
    if (prefix) {
      this._debug = debug("".concat(LIB_NAME, ":").concat(prefix));
      this._warn = debug("".concat(LIB_NAME, ":WARN:").concat(prefix));
      this._error = debug("".concat(LIB_NAME, ":ERROR:").concat(prefix));
    } else {
      this._debug = debug(LIB_NAME);
      this._warn = debug("".concat(LIB_NAME, ":WARN"));
      this._error = debug("".concat(LIB_NAME, ":ERROR"));
    }
    /* eslint-disable no-console */
    this._debug.log = console.info.bind(console);
    this._warn.log = console.warn.bind(console);
    this._error.log = console.error.bind(console);
    /* eslint-enable no-console */
  }
  return _createClass(Logger, [{
    key: "debug",
    get: function get() {
      return this._debug;
    }
  }, {
    key: "warn",
    get: function get() {
      return this._warn;
    }
  }, {
    key: "error",
    get: function get() {
      return this._error;
    }
  }]);
}();
exports.Logger = Logger;

},{"debug":6}],4:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _wrapNativeSuper(t) { var r = "function" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf("[native code]"); } catch (n) { return "function" == typeof t; } }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AwaitQueueRemovedTaskError = exports.AwaitQueueStoppedError = void 0;
/**
 * Custom Error derived class used to reject pending tasks once stop() method
 * has been called.
 */
var AwaitQueueStoppedError = /*#__PURE__*/function (_Error) {
  function AwaitQueueStoppedError(message) {
    var _this;
    _classCallCheck(this, AwaitQueueStoppedError);
    _this = _callSuper(this, AwaitQueueStoppedError, [message !== null && message !== void 0 ? message : 'queue stopped']);
    _this.name = 'AwaitQueueStoppedError';
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(_this, AwaitQueueStoppedError);
    }
    return _this;
  }
  _inherits(AwaitQueueStoppedError, _Error);
  return _createClass(AwaitQueueStoppedError);
}(/*#__PURE__*/_wrapNativeSuper(Error));
exports.AwaitQueueStoppedError = AwaitQueueStoppedError;
/**
 * Custom Error derived class used to reject pending tasks once removeTask()
 * method has been called.
 */
var AwaitQueueRemovedTaskError = /*#__PURE__*/function (_Error2) {
  function AwaitQueueRemovedTaskError(message) {
    var _this2;
    _classCallCheck(this, AwaitQueueRemovedTaskError);
    _this2 = _callSuper(this, AwaitQueueRemovedTaskError, [message !== null && message !== void 0 ? message : 'queue task removed']);
    _this2.name = 'AwaitQueueRemovedTaskError';
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(_this2, AwaitQueueRemovedTaskError);
    }
    return _this2;
  }
  _inherits(AwaitQueueRemovedTaskError, _Error2);
  return _createClass(AwaitQueueRemovedTaskError);
}(/*#__PURE__*/_wrapNativeSuper(Error));
exports.AwaitQueueRemovedTaskError = AwaitQueueRemovedTaskError;

},{}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AwaitQueueRemovedTaskError = exports.AwaitQueueStoppedError = exports.AwaitQueue = void 0;
var AwaitQueue_1 = require("./AwaitQueue");
Object.defineProperty(exports, "AwaitQueue", {
  enumerable: true,
  get: function get() {
    return AwaitQueue_1.AwaitQueue;
  }
});
var errors_1 = require("./errors");
Object.defineProperty(exports, "AwaitQueueStoppedError", {
  enumerable: true,
  get: function get() {
    return errors_1.AwaitQueueStoppedError;
  }
});
Object.defineProperty(exports, "AwaitQueueRemovedTaskError", {
  enumerable: true,
  get: function get() {
    return errors_1.AwaitQueueRemovedTaskError;
  }
});

},{"./AwaitQueue":2,"./errors":4}],6:[function(require,module,exports){
(function (process){(function (){
"use strict";

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = function () {
  var warned = false;
  return function () {
    if (!warned) {
      warned = true;
      console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    }
  };
}();

/**
 * Colors.
 */

exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
    return true;
  }

  // Internet Explorer and Edge do not support colors.
  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  }
  var m;

  // Is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  // eslint-disable-next-line no-return-assign
  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||
  // Is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) ||
  // Is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 ||
  // Double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);
  if (!this.useColors) {
    return;
  }
  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit');

  // The final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
    if (match === '%%') {
      return;
    }
    index++;
    if (match === '%c') {
      // We only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });
  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || function () {};

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
  try {
    if (namespaces) {
      exports.storage.setItem('debug', namespaces);
    } else {
      exports.storage.removeItem('debug');
    }
  } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
  }
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
  var r;
  try {
    r = exports.storage.getItem('debug') || exports.storage.getItem('DEBUG');
  } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
  }

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }
  return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
    // The Browser also has localStorage in the global context.
    return localStorage;
  } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
  }
}
module.exports = require('./common')(exports);
var formatters = module.exports.formatters;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (error) {
    return '[UnexpectedJSONParseError]: ' + error.message;
  }
};

}).call(this)}).call(this,require('_process'))
},{"./common":7,"_process":74}],7:[function(require,module,exports){
"use strict";

function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
  createDebug.debug = createDebug;
  createDebug["default"] = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = require('ms');
  createDebug.destroy = destroy;
  Object.keys(env).forEach(function (key) {
    createDebug[key] = env[key];
  });

  /**
  * The currently active debug mode names, and names to skip.
  */

  createDebug.names = [];
  createDebug.skips = [];

  /**
  * Map of special "%n" handling functions, for the debug "format" argument.
  *
  * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
  */
  createDebug.formatters = {};

  /**
  * Selects a color for a debug namespace
  * @param {String} namespace The namespace string for the debug instance to be colored
  * @return {Number|String} An ANSI color code for the given namespace
  * @api private
  */
  function selectColor(namespace) {
    var hash = 0;
    for (var i = 0; i < namespace.length; i++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }
    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }
  createDebug.selectColor = selectColor;

  /**
  * Create a debugger with the given `namespace`.
  *
  * @param {String} namespace
  * @return {Function}
  * @api public
  */
  function createDebug(namespace) {
    var prevTime;
    var enableOverride = null;
    var namespacesCache;
    var enabledCache;
    function debug() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      // Disabled?
      if (!debug.enabled) {
        return;
      }
      var self = debug;

      // Set `diff` timestamp
      var curr = Number(new Date());
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);
      if (typeof args[0] !== 'string') {
        // Anything else let's inspect with %O
        args.unshift('%O');
      }

      // Apply any `formatters` transformations
      var index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
        // If we encounter an escaped % then don't increase the array index
        if (match === '%%') {
          return '%';
        }
        index++;
        var formatter = createDebug.formatters[format];
        if (typeof formatter === 'function') {
          var val = args[index];
          match = formatter.call(self, val);

          // Now we need to remove `args[index]` since it's inlined in the `format`
          args.splice(index, 1);
          index--;
        }
        return match;
      });

      // Apply env-specific formatting (colors, etc.)
      createDebug.formatArgs.call(self, args);
      var logFn = self.log || createDebug.log;
      logFn.apply(self, args);
    }
    debug.namespace = namespace;
    debug.useColors = createDebug.useColors();
    debug.color = createDebug.selectColor(namespace);
    debug.extend = extend;
    debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

    Object.defineProperty(debug, 'enabled', {
      enumerable: true,
      configurable: false,
      get: function get() {
        if (enableOverride !== null) {
          return enableOverride;
        }
        if (namespacesCache !== createDebug.namespaces) {
          namespacesCache = createDebug.namespaces;
          enabledCache = createDebug.enabled(namespace);
        }
        return enabledCache;
      },
      set: function set(v) {
        enableOverride = v;
      }
    });

    // Env-specific initialization logic for debug instances
    if (typeof createDebug.init === 'function') {
      createDebug.init(debug);
    }
    return debug;
  }
  function extend(namespace, delimiter) {
    var newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
    newDebug.log = this.log;
    return newDebug;
  }

  /**
  * Enables a debug mode by namespaces. This can include modes
  * separated by a colon and wildcards.
  *
  * @param {String} namespaces
  * @api public
  */
  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.namespaces = namespaces;
    createDebug.names = [];
    createDebug.skips = [];
    var split = (typeof namespaces === 'string' ? namespaces : '').trim().replace(/\s+/g, ',').split(',').filter(Boolean);
    var _iterator = _createForOfIteratorHelper(split),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var ns = _step.value;
        if (ns[0] === '-') {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }

  /**
   * Checks if the given string matches a namespace template, honoring
   * asterisks as wildcards.
   *
   * @param {String} search
   * @param {String} template
   * @return {Boolean}
   */
  function matchesTemplate(search, template) {
    var searchIndex = 0;
    var templateIndex = 0;
    var starIndex = -1;
    var matchIndex = 0;
    while (searchIndex < search.length) {
      if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {
        // Match character or proceed with wildcard
        if (template[templateIndex] === '*') {
          starIndex = templateIndex;
          matchIndex = searchIndex;
          templateIndex++; // Skip the '*'
        } else {
          searchIndex++;
          templateIndex++;
        }
      } else if (starIndex !== -1) {
        // eslint-disable-line no-negated-condition
        // Backtrack to the last '*' and try to match more characters
        templateIndex = starIndex + 1;
        matchIndex++;
        searchIndex = matchIndex;
      } else {
        return false; // No match
      }
    }

    // Handle trailing '*' in template
    while (templateIndex < template.length && template[templateIndex] === '*') {
      templateIndex++;
    }
    return templateIndex === template.length;
  }

  /**
  * Disable debug output.
  *
  * @return {String} namespaces
  * @api public
  */
  function disable() {
    var namespaces = [].concat(_toConsumableArray(createDebug.names), _toConsumableArray(createDebug.skips.map(function (namespace) {
      return '-' + namespace;
    }))).join(',');
    createDebug.enable('');
    return namespaces;
  }

  /**
  * Returns true if the given mode name is enabled, false otherwise.
  *
  * @param {String} name
  * @return {Boolean}
  * @api public
  */
  function enabled(name) {
    var _iterator2 = _createForOfIteratorHelper(createDebug.skips),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var skip = _step2.value;
        if (matchesTemplate(name, skip)) {
          return false;
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    var _iterator3 = _createForOfIteratorHelper(createDebug.names),
      _step3;
    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        var ns = _step3.value;
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }
    return false;
  }

  /**
  * Coerce `val`.
  *
  * @param {Mixed} val
  * @return {Mixed}
  * @api private
  */
  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }
    return val;
  }

  /**
  * XXX DO NOT USE. This is a temporary stub function.
  * XXX It WILL be removed in the next major release.
  */
  function destroy() {
    console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
  }
  createDebug.enable(createDebug.load());
  return createDebug;
}
module.exports = setup;

},{"ms":73}],8:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hasCORS = void 0;
// imported from https://github.com/component/has-cors
var value = false;
try {
  value = typeof XMLHttpRequest !== 'undefined' && 'withCredentials' in new XMLHttpRequest();
} catch (err) {
  // if XMLHttp support is disabled in IE then it will throw
  // when trying to create
}
exports.hasCORS = value;

},{}],9:[function(require,module,exports){
"use strict";

// imported from https://github.com/galkn/querystring
/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.encode = encode;
exports.decode = decode;
function encode(obj) {
  var str = '';
  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += '&';
      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
    }
  }
  return str;
}
/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */
function decode(qs) {
  var qry = {};
  var pairs = qs.split('&');
  for (var i = 0, l = pairs.length; i < l; i++) {
    var pair = pairs[i].split('=');
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
}

},{}],10:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parse = parse;
// imported from https://github.com/galkn/parseuri
/**
 * Parses a URI
 *
 * Note: we could also have used the built-in URL object, but it isn't supported on all platforms.
 *
 * See:
 * - https://developer.mozilla.org/en-US/docs/Web/API/URL
 * - https://caniuse.com/url
 * - https://www.rfc-editor.org/rfc/rfc3986#appendix-B
 *
 * History of the parse() method:
 * - first commit: https://github.com/socketio/socket.io-client/commit/4ee1d5d94b3906a9c052b459f1a818b15f38f91c
 * - export into its own module: https://github.com/socketio/engine.io-client/commit/de2c561e4564efeb78f1bdb1ba39ef81b2822cb3
 * - reimport: https://github.com/socketio/engine.io-client/commit/df32277c3f6d622eec5ed09f493cae3f3391d242
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */
var re = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
var parts = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'];
function parse(str) {
  if (str.length > 8000) {
    throw "URI too long";
  }
  var src = str,
    b = str.indexOf('['),
    e = str.indexOf(']');
  if (b != -1 && e != -1) {
    str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
  }
  var m = re.exec(str || ''),
    uri = {},
    i = 14;
  while (i--) {
    uri[parts[i]] = m[i] || '';
  }
  if (b != -1 && e != -1) {
    uri.source = src;
    uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
    uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
    uri.ipv6uri = true;
  }
  uri.pathNames = pathNames(uri, uri['path']);
  uri.queryKey = queryKey(uri, uri['query']);
  return uri;
}
function pathNames(obj, path) {
  var regx = /\/{2,9}/g,
    names = path.replace(regx, "/").split("/");
  if (path.slice(0, 1) == '/' || path.length === 0) {
    names.splice(0, 1);
  }
  if (path.slice(-1) == '/') {
    names.splice(names.length - 1, 1);
  }
  return names;
}
function queryKey(uri, query) {
  var data = {};
  query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function ($0, $1, $2) {
    if ($1) {
      data[$1] = $2;
    }
  });
  return data;
}

},{}],11:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultBinaryType = exports.globalThisShim = exports.nextTick = void 0;
exports.createCookieJar = createCookieJar;
exports.nextTick = function () {
  var isPromiseAvailable = typeof Promise === "function" && typeof Promise.resolve === "function";
  if (isPromiseAvailable) {
    return function (cb) {
      return Promise.resolve().then(cb);
    };
  } else {
    return function (cb, setTimeoutFn) {
      return setTimeoutFn(cb, 0);
    };
  }
}();
exports.globalThisShim = function () {
  if (typeof self !== "undefined") {
    return self;
  } else if (typeof window !== "undefined") {
    return window;
  } else {
    return Function("return this")();
  }
}();
exports.defaultBinaryType = "arraybuffer";
function createCookieJar() {}

},{}],12:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WebTransport = exports.WebSocket = exports.NodeWebSocket = exports.XHR = exports.NodeXHR = exports.Fetch = exports.nextTick = exports.parse = exports.installTimerFunctions = exports.transports = exports.TransportError = exports.Transport = exports.protocol = exports.SocketWithUpgrade = exports.SocketWithoutUpgrade = exports.Socket = void 0;
var socket_js_1 = require("./socket.js");
Object.defineProperty(exports, "Socket", {
  enumerable: true,
  get: function get() {
    return socket_js_1.Socket;
  }
});
var socket_js_2 = require("./socket.js");
Object.defineProperty(exports, "SocketWithoutUpgrade", {
  enumerable: true,
  get: function get() {
    return socket_js_2.SocketWithoutUpgrade;
  }
});
Object.defineProperty(exports, "SocketWithUpgrade", {
  enumerable: true,
  get: function get() {
    return socket_js_2.SocketWithUpgrade;
  }
});
exports.protocol = socket_js_1.Socket.protocol;
var transport_js_1 = require("./transport.js");
Object.defineProperty(exports, "Transport", {
  enumerable: true,
  get: function get() {
    return transport_js_1.Transport;
  }
});
Object.defineProperty(exports, "TransportError", {
  enumerable: true,
  get: function get() {
    return transport_js_1.TransportError;
  }
});
var index_js_1 = require("./transports/index.js");
Object.defineProperty(exports, "transports", {
  enumerable: true,
  get: function get() {
    return index_js_1.transports;
  }
});
var util_js_1 = require("./util.js");
Object.defineProperty(exports, "installTimerFunctions", {
  enumerable: true,
  get: function get() {
    return util_js_1.installTimerFunctions;
  }
});
var parseuri_js_1 = require("./contrib/parseuri.js");
Object.defineProperty(exports, "parse", {
  enumerable: true,
  get: function get() {
    return parseuri_js_1.parse;
  }
});
var globals_node_js_1 = require("./globals.node.js");
Object.defineProperty(exports, "nextTick", {
  enumerable: true,
  get: function get() {
    return globals_node_js_1.nextTick;
  }
});
var polling_fetch_js_1 = require("./transports/polling-fetch.js");
Object.defineProperty(exports, "Fetch", {
  enumerable: true,
  get: function get() {
    return polling_fetch_js_1.Fetch;
  }
});
var polling_xhr_node_js_1 = require("./transports/polling-xhr.node.js");
Object.defineProperty(exports, "NodeXHR", {
  enumerable: true,
  get: function get() {
    return polling_xhr_node_js_1.XHR;
  }
});
var polling_xhr_js_1 = require("./transports/polling-xhr.js");
Object.defineProperty(exports, "XHR", {
  enumerable: true,
  get: function get() {
    return polling_xhr_js_1.XHR;
  }
});
var websocket_node_js_1 = require("./transports/websocket.node.js");
Object.defineProperty(exports, "NodeWebSocket", {
  enumerable: true,
  get: function get() {
    return websocket_node_js_1.WS;
  }
});
var websocket_js_1 = require("./transports/websocket.js");
Object.defineProperty(exports, "WebSocket", {
  enumerable: true,
  get: function get() {
    return websocket_js_1.WS;
  }
});
var webtransport_js_1 = require("./transports/webtransport.js");
Object.defineProperty(exports, "WebTransport", {
  enumerable: true,
  get: function get() {
    return webtransport_js_1.WT;
  }
});

},{"./contrib/parseuri.js":10,"./globals.node.js":11,"./socket.js":13,"./transport.js":14,"./transports/index.js":15,"./transports/polling-fetch.js":16,"./transports/polling-xhr.js":17,"./transports/polling-xhr.node.js":17,"./transports/websocket.js":19,"./transports/websocket.node.js":19,"./transports/webtransport.js":20,"./util.js":21}],13:[function(require,module,exports){
"use strict";

function _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _readOnlyError(r) { throw new TypeError('"' + r + '" is read-only'); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Socket = exports.SocketWithUpgrade = exports.SocketWithoutUpgrade = void 0;
var index_js_1 = require("./transports/index.js");
var util_js_1 = require("./util.js");
var parseqs_js_1 = require("./contrib/parseqs.js");
var parseuri_js_1 = require("./contrib/parseuri.js");
var component_emitter_1 = require("@socket.io/component-emitter");
var engine_io_parser_1 = require("engine.io-parser");
var globals_node_js_1 = require("./globals.node.js");
var debug_1 = __importDefault(require("debug")); // debug()
var debug = (0, debug_1["default"])("engine.io-client:socket"); // debug()
var withEventListeners = typeof addEventListener === "function" && typeof removeEventListener === "function";
var OFFLINE_EVENT_LISTENERS = [];
if (withEventListeners) {
  // within a ServiceWorker, any event handler for the 'offline' event must be added on the initial evaluation of the
  // script, so we create one single event listener here which will forward the event to the socket instances
  addEventListener("offline", function () {
    debug("closing %d connection(s) because the network was lost", OFFLINE_EVENT_LISTENERS.length);
    OFFLINE_EVENT_LISTENERS.forEach(function (listener) {
      return listener();
    });
  }, false);
}
/**
 * This class provides a WebSocket-like interface to connect to an Engine.IO server. The connection will be established
 * with one of the available low-level transports, like HTTP long-polling, WebSocket or WebTransport.
 *
 * This class comes without upgrade mechanism, which means that it will keep the first low-level transport that
 * successfully establishes the connection.
 *
 * In order to allow tree-shaking, there are no transports included, that's why the `transports` option is mandatory.
 *
 * @example
 * import { SocketWithoutUpgrade, WebSocket } from "engine.io-client";
 *
 * const socket = new SocketWithoutUpgrade({
 *   transports: [WebSocket]
 * });
 *
 * socket.on("open", () => {
 *   socket.send("hello");
 * });
 *
 * @see SocketWithUpgrade
 * @see Socket
 */
var SocketWithoutUpgrade = /*#__PURE__*/function (_component_emitter_1$) {
  /**
   * Socket constructor.
   *
   * @param {String|Object} uri - uri or options
   * @param {Object} opts - options
   */
  function SocketWithoutUpgrade(uri, opts) {
    var _this;
    _classCallCheck(this, SocketWithoutUpgrade);
    _this = _callSuper(this, SocketWithoutUpgrade);
    _this.binaryType = globals_node_js_1.defaultBinaryType;
    _this.writeBuffer = [];
    _this._prevBufferLen = 0;
    _this._pingInterval = -1;
    _this._pingTimeout = -1;
    _this._maxPayload = -1;
    /**
     * The expiration timestamp of the {@link _pingTimeoutTimer} object is tracked, in case the timer is throttled and the
     * callback is not fired on time. This can happen for example when a laptop is suspended or when a phone is locked.
     */
    _this._pingTimeoutTime = Infinity;
    if (uri && "object" === _typeof(uri)) {
      opts = uri;
      uri = null;
    }
    if (uri) {
      var parsedUri = (0, parseuri_js_1.parse)(uri);
      opts.hostname = parsedUri.host;
      opts.secure = parsedUri.protocol === "https" || parsedUri.protocol === "wss";
      opts.port = parsedUri.port;
      if (parsedUri.query) opts.query = parsedUri.query;
    } else if (opts.host) {
      opts.hostname = (0, parseuri_js_1.parse)(opts.host).host;
    }
    (0, util_js_1.installTimerFunctions)(_this, opts);
    _this.secure = null != opts.secure ? opts.secure : typeof location !== "undefined" && "https:" === location.protocol;
    if (opts.hostname && !opts.port) {
      // if no port is specified manually, use the protocol default
      opts.port = _this.secure ? "443" : "80";
    }
    _this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
    _this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : _this.secure ? "443" : "80");
    _this.transports = [];
    _this._transportsByName = {};
    opts.transports.forEach(function (t) {
      var transportName = t.prototype.name;
      _this.transports.push(transportName);
      _this._transportsByName[transportName] = t;
    });
    _this.opts = Object.assign({
      path: "/engine.io",
      agent: false,
      withCredentials: false,
      upgrade: true,
      timestampParam: "t",
      rememberUpgrade: false,
      addTrailingSlash: true,
      rejectUnauthorized: true,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: false
    }, opts);
    _this.opts.path = _this.opts.path.replace(/\/$/, "") + (_this.opts.addTrailingSlash ? "/" : "");
    if (typeof _this.opts.query === "string") {
      _this.opts.query = (0, parseqs_js_1.decode)(_this.opts.query);
    }
    if (withEventListeners) {
      if (_this.opts.closeOnBeforeunload) {
        // Firefox closes the connection when the "beforeunload" event is emitted but not Chrome. This event listener
        // ensures every browser behaves the same (no "disconnect" event at the Socket.IO level when the page is
        // closed/reloaded)
        _this._beforeunloadEventListener = function () {
          if (_this.transport) {
            // silently close the transport
            _this.transport.removeAllListeners();
            _this.transport.close();
          }
        };
        addEventListener("beforeunload", _this._beforeunloadEventListener, false);
      }
      if (_this.hostname !== "localhost") {
        debug("adding listener for the 'offline' event");
        _this._offlineEventListener = function () {
          _this._onClose("transport close", {
            description: "network connection lost"
          });
        };
        OFFLINE_EVENT_LISTENERS.push(_this._offlineEventListener);
      }
    }
    if (_this.opts.withCredentials) {
      _this._cookieJar = (0, globals_node_js_1.createCookieJar)();
    }
    _this._open();
    return _this;
  }
  /**
   * Creates transport of the given type.
   *
   * @param {String} name - transport name
   * @return {Transport}
   * @private
   */
  _inherits(SocketWithoutUpgrade, _component_emitter_1$);
  return _createClass(SocketWithoutUpgrade, [{
    key: "createTransport",
    value: function createTransport(name) {
      debug('creating transport "%s"', name);
      var query = Object.assign({}, this.opts.query);
      // append engine.io protocol identifier
      query.EIO = engine_io_parser_1.protocol;
      // transport name
      query.transport = name;
      // session id if we already have one
      if (this.id) query.sid = this.id;
      var opts = Object.assign({}, this.opts, {
        query: query,
        socket: this,
        hostname: this.hostname,
        secure: this.secure,
        port: this.port
      }, this.opts.transportOptions[name]);
      debug("options: %j", opts);
      return new this._transportsByName[name](opts);
    }
    /**
     * Initializes transport to use and starts probe.
     *
     * @private
     */
  }, {
    key: "_open",
    value: function _open() {
      var _this2 = this;
      if (this.transports.length === 0) {
        // Emit error on next tick so it can be listened to
        this.setTimeoutFn(function () {
          _this2.emitReserved("error", "No transports available");
        }, 0);
        return;
      }
      var transportName = this.opts.rememberUpgrade && SocketWithoutUpgrade.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1 ? "websocket" : this.transports[0];
      this.readyState = "opening";
      var transport = this.createTransport(transportName);
      transport.open();
      this.setTransport(transport);
    }
    /**
     * Sets the current transport. Disables the existing one (if any).
     *
     * @private
     */
  }, {
    key: "setTransport",
    value: function setTransport(transport) {
      var _this3 = this;
      debug("setting transport %s", transport.name);
      if (this.transport) {
        debug("clearing existing transport %s", this.transport.name);
        this.transport.removeAllListeners();
      }
      // set up transport
      this.transport = transport;
      // set up transport listeners
      transport.on("drain", this._onDrain.bind(this)).on("packet", this._onPacket.bind(this)).on("error", this._onError.bind(this)).on("close", function (reason) {
        return _this3._onClose("transport close", reason);
      });
    }
    /**
     * Called when connection is deemed open.
     *
     * @private
     */
  }, {
    key: "onOpen",
    value: function onOpen() {
      debug("socket open");
      this.readyState = "open";
      SocketWithoutUpgrade.priorWebsocketSuccess = "websocket" === this.transport.name;
      this.emitReserved("open");
      this.flush();
    }
    /**
     * Handles a packet.
     *
     * @private
     */
  }, {
    key: "_onPacket",
    value: function _onPacket(packet) {
      if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
        debug('socket receive: type "%s", data "%s"', packet.type, packet.data);
        this.emitReserved("packet", packet);
        // Socket is live - any packet counts
        this.emitReserved("heartbeat");
        switch (packet.type) {
          case "open":
            this.onHandshake(JSON.parse(packet.data));
            break;
          case "ping":
            this._sendPacket("pong");
            this.emitReserved("ping");
            this.emitReserved("pong");
            this._resetPingTimeout();
            break;
          case "error":
            var err = new Error("server error");
            // @ts-ignore
            err.code = packet.data;
            this._onError(err);
            break;
          case "message":
            this.emitReserved("data", packet.data);
            this.emitReserved("message", packet.data);
            break;
        }
      } else {
        debug('packet received with socket readyState "%s"', this.readyState);
      }
    }
    /**
     * Called upon handshake completion.
     *
     * @param {Object} data - handshake obj
     * @private
     */
  }, {
    key: "onHandshake",
    value: function onHandshake(data) {
      this.emitReserved("handshake", data);
      this.id = data.sid;
      this.transport.query.sid = data.sid;
      this._pingInterval = data.pingInterval;
      this._pingTimeout = data.pingTimeout;
      this._maxPayload = data.maxPayload;
      this.onOpen();
      // In case open handler closes socket
      if ("closed" === this.readyState) return;
      this._resetPingTimeout();
    }
    /**
     * Sets and resets ping timeout timer based on server pings.
     *
     * @private
     */
  }, {
    key: "_resetPingTimeout",
    value: function _resetPingTimeout() {
      var _this4 = this;
      this.clearTimeoutFn(this._pingTimeoutTimer);
      var delay = this._pingInterval + this._pingTimeout;
      this._pingTimeoutTime = Date.now() + delay;
      this._pingTimeoutTimer = this.setTimeoutFn(function () {
        _this4._onClose("ping timeout");
      }, delay);
      if (this.opts.autoUnref) {
        this._pingTimeoutTimer.unref();
      }
    }
    /**
     * Called on `drain` event
     *
     * @private
     */
  }, {
    key: "_onDrain",
    value: function _onDrain() {
      this.writeBuffer.splice(0, this._prevBufferLen);
      // setting prevBufferLen = 0 is very important
      // for example, when upgrading, upgrade packet is sent over,
      // and a nonzero prevBufferLen could cause problems on `drain`
      this._prevBufferLen = 0;
      if (0 === this.writeBuffer.length) {
        this.emitReserved("drain");
      } else {
        this.flush();
      }
    }
    /**
     * Flush write buffers.
     *
     * @private
     */
  }, {
    key: "flush",
    value: function flush() {
      if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
        var packets = this._getWritablePackets();
        debug("flushing %d packets in socket", packets.length);
        this.transport.send(packets);
        // keep track of current length of writeBuffer
        // splice writeBuffer and callbackBuffer on `drain`
        this._prevBufferLen = packets.length;
        this.emitReserved("flush");
      }
    }
    /**
     * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
     * long-polling)
     *
     * @private
     */
  }, {
    key: "_getWritablePackets",
    value: function _getWritablePackets() {
      var shouldCheckPayloadSize = this._maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1;
      if (!shouldCheckPayloadSize) {
        return this.writeBuffer;
      }
      var payloadSize = 1; // first packet type
      for (var i = 0; i < this.writeBuffer.length; i++) {
        var data = this.writeBuffer[i].data;
        if (data) {
          payloadSize += (0, util_js_1.byteLength)(data);
        }
        if (i > 0 && payloadSize > this._maxPayload) {
          debug("only send %d out of %d packets", i, this.writeBuffer.length);
          return this.writeBuffer.slice(0, i);
        }
        payloadSize += 2; // separator + packet type
      }
      debug("payload size is %d (max: %d)", payloadSize, this._maxPayload);
      return this.writeBuffer;
    }
    /**
     * Checks whether the heartbeat timer has expired but the socket has not yet been notified.
     *
     * Note: this method is private for now because it does not really fit the WebSocket API, but if we put it in the
     * `write()` method then the message would not be buffered by the Socket.IO client.
     *
     * @return {boolean}
     * @private
     */
    /* private */
  }, {
    key: "_hasPingExpired",
    value: function _hasPingExpired() {
      var _this5 = this;
      if (!this._pingTimeoutTime) return true;
      var hasExpired = Date.now() > this._pingTimeoutTime;
      if (hasExpired) {
        debug("throttled timer detected, scheduling connection close");
        this._pingTimeoutTime = 0;
        (0, globals_node_js_1.nextTick)(function () {
          _this5._onClose("ping timeout");
        }, this.setTimeoutFn);
      }
      return hasExpired;
    }
    /**
     * Sends a message.
     *
     * @param {String} msg - message.
     * @param {Object} options.
     * @param {Function} fn - callback function.
     * @return {Socket} for chaining.
     */
  }, {
    key: "write",
    value: function write(msg, options, fn) {
      this._sendPacket("message", msg, options, fn);
      return this;
    }
    /**
     * Sends a message. Alias of {@link Socket#write}.
     *
     * @param {String} msg - message.
     * @param {Object} options.
     * @param {Function} fn - callback function.
     * @return {Socket} for chaining.
     */
  }, {
    key: "send",
    value: function send(msg, options, fn) {
      this._sendPacket("message", msg, options, fn);
      return this;
    }
    /**
     * Sends a packet.
     *
     * @param {String} type: packet type.
     * @param {String} data.
     * @param {Object} options.
     * @param {Function} fn - callback function.
     * @private
     */
  }, {
    key: "_sendPacket",
    value: function _sendPacket(type, data, options, fn) {
      if ("function" === typeof data) {
        fn = data;
        data = undefined;
      }
      if ("function" === typeof options) {
        fn = options;
        options = null;
      }
      if ("closing" === this.readyState || "closed" === this.readyState) {
        return;
      }
      options = options || {};
      options.compress = false !== options.compress;
      var packet = {
        type: type,
        data: data,
        options: options
      };
      this.emitReserved("packetCreate", packet);
      this.writeBuffer.push(packet);
      if (fn) this.once("flush", fn);
      this.flush();
    }
    /**
     * Closes the connection.
     */
  }, {
    key: "close",
    value: function close() {
      var _this6 = this;
      var close = function close() {
        _this6._onClose("forced close");
        debug("socket closing - telling transport to close");
        _this6.transport.close();
      };
      var _cleanupAndClose = function cleanupAndClose() {
        _this6.off("upgrade", _cleanupAndClose);
        _this6.off("upgradeError", _cleanupAndClose);
        close();
      };
      var waitForUpgrade = function waitForUpgrade() {
        // wait for upgrade to finish since we can't send packets while pausing a transport
        _this6.once("upgrade", _cleanupAndClose);
        _this6.once("upgradeError", _cleanupAndClose);
      };
      if ("opening" === this.readyState || "open" === this.readyState) {
        this.readyState = "closing";
        if (this.writeBuffer.length) {
          this.once("drain", function () {
            if (_this6.upgrading) {
              waitForUpgrade();
            } else {
              close();
            }
          });
        } else if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      }
      return this;
    }
    /**
     * Called upon transport error
     *
     * @private
     */
  }, {
    key: "_onError",
    value: function _onError(err) {
      debug("socket error %j", err);
      SocketWithoutUpgrade.priorWebsocketSuccess = false;
      if (this.opts.tryAllTransports && this.transports.length > 1 && this.readyState === "opening") {
        debug("trying next transport");
        this.transports.shift();
        return this._open();
      }
      this.emitReserved("error", err);
      this._onClose("transport error", err);
    }
    /**
     * Called upon transport close.
     *
     * @private
     */
  }, {
    key: "_onClose",
    value: function _onClose(reason, description) {
      if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
        debug('socket close with reason: "%s"', reason);
        // clear timers
        this.clearTimeoutFn(this._pingTimeoutTimer);
        // stop event from firing again for transport
        this.transport.removeAllListeners("close");
        // ensure transport won't stay open
        this.transport.close();
        // ignore further transport communication
        this.transport.removeAllListeners();
        if (withEventListeners) {
          if (this._beforeunloadEventListener) {
            removeEventListener("beforeunload", this._beforeunloadEventListener, false);
          }
          if (this._offlineEventListener) {
            var i = OFFLINE_EVENT_LISTENERS.indexOf(this._offlineEventListener);
            if (i !== -1) {
              debug("removing listener for the 'offline' event");
              OFFLINE_EVENT_LISTENERS.splice(i, 1);
            }
          }
        }
        // set ready state
        this.readyState = "closed";
        // clear session id
        this.id = null;
        // emit close event
        this.emitReserved("close", reason, description);
        // clean buffers after, so users can still
        // grab the buffers on `close` event
        this.writeBuffer = [];
        this._prevBufferLen = 0;
      }
    }
  }]);
}(component_emitter_1.Emitter);
exports.SocketWithoutUpgrade = SocketWithoutUpgrade;
SocketWithoutUpgrade.protocol = engine_io_parser_1.protocol;
/**
 * This class provides a WebSocket-like interface to connect to an Engine.IO server. The connection will be established
 * with one of the available low-level transports, like HTTP long-polling, WebSocket or WebTransport.
 *
 * This class comes with an upgrade mechanism, which means that once the connection is established with the first
 * low-level transport, it will try to upgrade to a better transport.
 *
 * In order to allow tree-shaking, there are no transports included, that's why the `transports` option is mandatory.
 *
 * @example
 * import { SocketWithUpgrade, WebSocket } from "engine.io-client";
 *
 * const socket = new SocketWithUpgrade({
 *   transports: [WebSocket]
 * });
 *
 * socket.on("open", () => {
 *   socket.send("hello");
 * });
 *
 * @see SocketWithoutUpgrade
 * @see Socket
 */
var SocketWithUpgrade = /*#__PURE__*/function (_SocketWithoutUpgrade) {
  function SocketWithUpgrade() {
    var _this7;
    _classCallCheck(this, SocketWithUpgrade);
    _this7 = _callSuper(this, SocketWithUpgrade, arguments);
    _this7._upgrades = [];
    return _this7;
  }
  _inherits(SocketWithUpgrade, _SocketWithoutUpgrade);
  return _createClass(SocketWithUpgrade, [{
    key: "onOpen",
    value: function onOpen() {
      _superPropGet(SocketWithUpgrade, "onOpen", this, 3)([]);
      if ("open" === this.readyState && this.opts.upgrade) {
        debug("starting upgrade probes");
        for (var i = 0; i < this._upgrades.length; i++) {
          this._probe(this._upgrades[i]);
        }
      }
    }
    /**
     * Probes a transport.
     *
     * @param {String} name - transport name
     * @private
     */
  }, {
    key: "_probe",
    value: function _probe(name) {
      var _this8 = this;
      debug('probing transport "%s"', name);
      var transport = this.createTransport(name);
      var failed = false;
      SocketWithoutUpgrade.priorWebsocketSuccess = false;
      var onTransportOpen = function onTransportOpen() {
        if (failed) return;
        debug('probe transport "%s" opened', name);
        transport.send([{
          type: "ping",
          data: "probe"
        }]);
        transport.once("packet", function (msg) {
          if (failed) return;
          if ("pong" === msg.type && "probe" === msg.data) {
            debug('probe transport "%s" pong', name);
            _this8.upgrading = true;
            _this8.emitReserved("upgrading", transport);
            if (!transport) return;
            SocketWithoutUpgrade.priorWebsocketSuccess = "websocket" === transport.name;
            debug('pausing current transport "%s"', _this8.transport.name);
            _this8.transport.pause(function () {
              if (failed) return;
              if ("closed" === _this8.readyState) return;
              debug("changing transport and sending upgrade packet");
              cleanup();
              _this8.setTransport(transport);
              transport.send([{
                type: "upgrade"
              }]);
              _this8.emitReserved("upgrade", transport);
              transport = null;
              _this8.upgrading = false;
              _this8.flush();
            });
          } else {
            debug('probe transport "%s" failed', name);
            var err = new Error("probe error");
            // @ts-ignore
            err.transport = transport.name;
            _this8.emitReserved("upgradeError", err);
          }
        });
      };
      function freezeTransport() {
        if (failed) return;
        // Any callback called by transport should be ignored since now
        failed = true;
        cleanup();
        transport.close();
        transport = null;
      }
      // Handle any error that happens while probing
      var onerror = function onerror(err) {
        var error = new Error("probe error: " + err);
        // @ts-ignore
        error.transport = transport.name;
        freezeTransport();
        debug('probe transport "%s" failed because of error: %s', name, err);
        _this8.emitReserved("upgradeError", error);
      };
      function onTransportClose() {
        onerror("transport closed");
      }
      // When the socket is closed while we're probing
      function onclose() {
        onerror("socket closed");
      }
      // When the socket is upgraded while we're probing
      function onupgrade(to) {
        if (transport && to.name !== transport.name) {
          debug('"%s" works - aborting "%s"', to.name, transport.name);
          freezeTransport();
        }
      }
      // Remove all listeners on the transport and on self
      var cleanup = function cleanup() {
        transport.removeListener("open", onTransportOpen);
        transport.removeListener("error", onerror);
        transport.removeListener("close", onTransportClose);
        _this8.off("close", onclose);
        _this8.off("upgrading", onupgrade);
      };
      transport.once("open", onTransportOpen);
      transport.once("error", onerror);
      transport.once("close", onTransportClose);
      this.once("close", onclose);
      this.once("upgrading", onupgrade);
      if (this._upgrades.indexOf("webtransport") !== -1 && name !== "webtransport") {
        // favor WebTransport
        this.setTimeoutFn(function () {
          if (!failed) {
            transport.open();
          }
        }, 200);
      } else {
        transport.open();
      }
    }
  }, {
    key: "onHandshake",
    value: function onHandshake(data) {
      this._upgrades = this._filterUpgrades(data.upgrades);
      _superPropGet(SocketWithUpgrade, "onHandshake", this, 3)([data]);
    }
    /**
     * Filters upgrades, returning only those matching client transports.
     *
     * @param {Array} upgrades - server upgrades
     * @private
     */
  }, {
    key: "_filterUpgrades",
    value: function _filterUpgrades(upgrades) {
      var filteredUpgrades = [];
      for (var i = 0; i < upgrades.length; i++) {
        if (~this.transports.indexOf(upgrades[i])) filteredUpgrades.push(upgrades[i]);
      }
      return filteredUpgrades;
    }
  }]);
}(SocketWithoutUpgrade);
exports.SocketWithUpgrade = SocketWithUpgrade;
/**
 * This class provides a WebSocket-like interface to connect to an Engine.IO server. The connection will be established
 * with one of the available low-level transports, like HTTP long-polling, WebSocket or WebTransport.
 *
 * This class comes with an upgrade mechanism, which means that once the connection is established with the first
 * low-level transport, it will try to upgrade to a better transport.
 *
 * @example
 * import { Socket } from "engine.io-client";
 *
 * const socket = new Socket();
 *
 * socket.on("open", () => {
 *   socket.send("hello");
 * });
 *
 * @see SocketWithoutUpgrade
 * @see SocketWithUpgrade
 */
var Socket = /*#__PURE__*/function (_SocketWithUpgrade) {
  function Socket(uri) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _classCallCheck(this, Socket);
    var o = _typeof(uri) === "object" ? uri : opts;
    if (!o.transports || o.transports && typeof o.transports[0] === "string") {
      o.transports = (o.transports || ["polling", "websocket", "webtransport"]).map(function (transportName) {
        return index_js_1.transports[transportName];
      }).filter(function (t) {
        return !!t;
      });
    }
    return _callSuper(this, Socket, [uri, o]);
  }
  _inherits(Socket, _SocketWithUpgrade);
  return _createClass(Socket);
}(SocketWithUpgrade);
exports.Socket = Socket;

},{"./contrib/parseqs.js":9,"./contrib/parseuri.js":10,"./globals.node.js":11,"./transports/index.js":15,"./util.js":21,"@socket.io/component-emitter":1,"debug":22,"engine.io-parser":28}],14:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _wrapNativeSuper(t) { var r = "function" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf("[native code]"); } catch (n) { return "function" == typeof t; } }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Transport = exports.TransportError = void 0;
var engine_io_parser_1 = require("engine.io-parser");
var component_emitter_1 = require("@socket.io/component-emitter");
var util_js_1 = require("./util.js");
var parseqs_js_1 = require("./contrib/parseqs.js");
var debug_1 = __importDefault(require("debug")); // debug()
var debug = (0, debug_1["default"])("engine.io-client:transport"); // debug()
var TransportError = /*#__PURE__*/function (_Error) {
  function TransportError(reason, description, context) {
    var _this;
    _classCallCheck(this, TransportError);
    _this = _callSuper(this, TransportError, [reason]);
    _this.description = description;
    _this.context = context;
    _this.type = "TransportError";
    return _this;
  }
  _inherits(TransportError, _Error);
  return _createClass(TransportError);
}(/*#__PURE__*/_wrapNativeSuper(Error));
exports.TransportError = TransportError;
var Transport = /*#__PURE__*/function (_component_emitter_1$) {
  /**
   * Transport abstract constructor.
   *
   * @param {Object} opts - options
   * @protected
   */
  function Transport(opts) {
    var _this2;
    _classCallCheck(this, Transport);
    _this2 = _callSuper(this, Transport);
    _this2.writable = false;
    (0, util_js_1.installTimerFunctions)(_this2, opts);
    _this2.opts = opts;
    _this2.query = opts.query;
    _this2.socket = opts.socket;
    _this2.supportsBinary = !opts.forceBase64;
    return _this2;
  }
  /**
   * Emits an error.
   *
   * @param {String} reason
   * @param description
   * @param context - the error context
   * @return {Transport} for chaining
   * @protected
   */
  _inherits(Transport, _component_emitter_1$);
  return _createClass(Transport, [{
    key: "onError",
    value: function onError(reason, description, context) {
      _superPropGet(Transport, "emitReserved", this, 3)(["error", new TransportError(reason, description, context)]);
      return this;
    }
    /**
     * Opens the transport.
     */
  }, {
    key: "open",
    value: function open() {
      this.readyState = "opening";
      this.doOpen();
      return this;
    }
    /**
     * Closes the transport.
     */
  }, {
    key: "close",
    value: function close() {
      if (this.readyState === "opening" || this.readyState === "open") {
        this.doClose();
        this.onClose();
      }
      return this;
    }
    /**
     * Sends multiple packets.
     *
     * @param {Array} packets
     */
  }, {
    key: "send",
    value: function send(packets) {
      if (this.readyState === "open") {
        this.write(packets);
      } else {
        // this might happen if the transport was silently closed in the beforeunload event handler
        debug("transport is not open, discarding packets");
      }
    }
    /**
     * Called upon open
     *
     * @protected
     */
  }, {
    key: "onOpen",
    value: function onOpen() {
      this.readyState = "open";
      this.writable = true;
      _superPropGet(Transport, "emitReserved", this, 3)(["open"]);
    }
    /**
     * Called with data.
     *
     * @param {String} data
     * @protected
     */
  }, {
    key: "onData",
    value: function onData(data) {
      var packet = (0, engine_io_parser_1.decodePacket)(data, this.socket.binaryType);
      this.onPacket(packet);
    }
    /**
     * Called with a decoded packet.
     *
     * @protected
     */
  }, {
    key: "onPacket",
    value: function onPacket(packet) {
      _superPropGet(Transport, "emitReserved", this, 3)(["packet", packet]);
    }
    /**
     * Called upon close.
     *
     * @protected
     */
  }, {
    key: "onClose",
    value: function onClose(details) {
      this.readyState = "closed";
      _superPropGet(Transport, "emitReserved", this, 3)(["close", details]);
    }
    /**
     * Pauses the transport, in order not to lose packets during an upgrade.
     *
     * @param onPause
     */
  }, {
    key: "pause",
    value: function pause(onPause) {}
  }, {
    key: "createUri",
    value: function createUri(schema) {
      var query = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return schema + "://" + this._hostname() + this._port() + this.opts.path + this._query(query);
    }
  }, {
    key: "_hostname",
    value: function _hostname() {
      var hostname = this.opts.hostname;
      return hostname.indexOf(":") === -1 ? hostname : "[" + hostname + "]";
    }
  }, {
    key: "_port",
    value: function _port() {
      if (this.opts.port && (this.opts.secure && Number(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80)) {
        return ":" + this.opts.port;
      } else {
        return "";
      }
    }
  }, {
    key: "_query",
    value: function _query(query) {
      var encodedQuery = (0, parseqs_js_1.encode)(query);
      return encodedQuery.length ? "?" + encodedQuery : "";
    }
  }]);
}(component_emitter_1.Emitter);
exports.Transport = Transport;

},{"./contrib/parseqs.js":9,"./util.js":21,"@socket.io/component-emitter":1,"debug":22,"engine.io-parser":28}],15:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transports = void 0;
var polling_xhr_node_js_1 = require("./polling-xhr.node.js");
var websocket_node_js_1 = require("./websocket.node.js");
var webtransport_js_1 = require("./webtransport.js");
exports.transports = {
  websocket: websocket_node_js_1.WS,
  webtransport: webtransport_js_1.WT,
  polling: polling_xhr_node_js_1.XHR
};

},{"./polling-xhr.node.js":17,"./websocket.node.js":19,"./webtransport.js":20}],16:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Fetch = void 0;
var polling_js_1 = require("./polling.js");
/**
 * HTTP long-polling based on the built-in `fetch()` method.
 *
 * Usage: browser, Node.js (since v18), Deno, Bun
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/fetch
 * @see https://caniuse.com/fetch
 * @see https://nodejs.org/api/globals.html#fetch
 */
var Fetch = /*#__PURE__*/function (_polling_js_1$Polling) {
  function Fetch() {
    _classCallCheck(this, Fetch);
    return _callSuper(this, Fetch, arguments);
  }
  _inherits(Fetch, _polling_js_1$Polling);
  return _createClass(Fetch, [{
    key: "doPoll",
    value: function doPoll() {
      var _this = this;
      this._fetch().then(function (res) {
        if (!res.ok) {
          return _this.onError("fetch read error", res.status, res);
        }
        res.text().then(function (data) {
          return _this.onData(data);
        });
      })["catch"](function (err) {
        _this.onError("fetch read error", err);
      });
    }
  }, {
    key: "doWrite",
    value: function doWrite(data, callback) {
      var _this2 = this;
      this._fetch(data).then(function (res) {
        if (!res.ok) {
          return _this2.onError("fetch write error", res.status, res);
        }
        callback();
      })["catch"](function (err) {
        _this2.onError("fetch write error", err);
      });
    }
  }, {
    key: "_fetch",
    value: function _fetch(data) {
      var _this3 = this;
      var _a;
      var isPost = data !== undefined;
      var headers = new Headers(this.opts.extraHeaders);
      if (isPost) {
        headers.set("content-type", "text/plain;charset=UTF-8");
      }
      (_a = this.socket._cookieJar) === null || _a === void 0 ? void 0 : _a.appendCookies(headers);
      return fetch(this.uri(), {
        method: isPost ? "POST" : "GET",
        body: isPost ? data : null,
        headers: headers,
        credentials: this.opts.withCredentials ? "include" : "omit"
      }).then(function (res) {
        var _a;
        // @ts-ignore getSetCookie() was added in Node.js v19.7.0
        (_a = _this3.socket._cookieJar) === null || _a === void 0 ? void 0 : _a.parseCookies(res.headers.getSetCookie());
        return res;
      });
    }
  }]);
}(polling_js_1.Polling);
exports.Fetch = Fetch;

},{"./polling.js":18}],17:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.XHR = exports.Request = exports.BaseXHR = void 0;
var polling_js_1 = require("./polling.js");
var component_emitter_1 = require("@socket.io/component-emitter");
var util_js_1 = require("../util.js");
var globals_node_js_1 = require("../globals.node.js");
var has_cors_js_1 = require("../contrib/has-cors.js");
var debug_1 = __importDefault(require("debug")); // debug()
var debug = (0, debug_1["default"])("engine.io-client:polling"); // debug()
function empty() {}
var BaseXHR = /*#__PURE__*/function (_polling_js_1$Polling) {
  /**
   * XHR Polling constructor.
   *
   * @param {Object} opts
   * @package
   */
  function BaseXHR(opts) {
    var _this;
    _classCallCheck(this, BaseXHR);
    _this = _callSuper(this, BaseXHR, [opts]);
    if (typeof location !== "undefined") {
      var isSSL = "https:" === location.protocol;
      var port = location.port;
      // some user agents have empty `location.port`
      if (!port) {
        port = isSSL ? "443" : "80";
      }
      _this.xd = typeof location !== "undefined" && opts.hostname !== location.hostname || port !== opts.port;
    }
    return _this;
  }
  /**
   * Sends data.
   *
   * @param {String} data to send.
   * @param {Function} called upon flush.
   * @private
   */
  _inherits(BaseXHR, _polling_js_1$Polling);
  return _createClass(BaseXHR, [{
    key: "doWrite",
    value: function doWrite(data, fn) {
      var _this2 = this;
      var req = this.request({
        method: "POST",
        data: data
      });
      req.on("success", fn);
      req.on("error", function (xhrStatus, context) {
        _this2.onError("xhr post error", xhrStatus, context);
      });
    }
    /**
     * Starts a poll cycle.
     *
     * @private
     */
  }, {
    key: "doPoll",
    value: function doPoll() {
      var _this3 = this;
      debug("xhr poll");
      var req = this.request();
      req.on("data", this.onData.bind(this));
      req.on("error", function (xhrStatus, context) {
        _this3.onError("xhr poll error", xhrStatus, context);
      });
      this.pollXhr = req;
    }
  }]);
}(polling_js_1.Polling);
exports.BaseXHR = BaseXHR;
var Request = /*#__PURE__*/function (_component_emitter_1$) {
  /**
   * Request constructor
   *
   * @param {Object} options
   * @package
   */
  function Request(createRequest, uri, opts) {
    var _this4;
    _classCallCheck(this, Request);
    _this4 = _callSuper(this, Request);
    _this4.createRequest = createRequest;
    (0, util_js_1.installTimerFunctions)(_this4, opts);
    _this4._opts = opts;
    _this4._method = opts.method || "GET";
    _this4._uri = uri;
    _this4._data = undefined !== opts.data ? opts.data : null;
    _this4._create();
    return _this4;
  }
  /**
   * Creates the XHR object and sends the request.
   *
   * @private
   */
  _inherits(Request, _component_emitter_1$);
  return _createClass(Request, [{
    key: "_create",
    value: function _create() {
      var _this5 = this;
      var _a;
      var opts = (0, util_js_1.pick)(this._opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
      opts.xdomain = !!this._opts.xd;
      var xhr = this._xhr = this.createRequest(opts);
      try {
        debug("xhr open %s: %s", this._method, this._uri);
        xhr.open(this._method, this._uri, true);
        try {
          if (this._opts.extraHeaders) {
            // @ts-ignore
            xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
            for (var i in this._opts.extraHeaders) {
              if (this._opts.extraHeaders.hasOwnProperty(i)) {
                xhr.setRequestHeader(i, this._opts.extraHeaders[i]);
              }
            }
          }
        } catch (e) {}
        if ("POST" === this._method) {
          try {
            xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
          } catch (e) {}
        }
        try {
          xhr.setRequestHeader("Accept", "*/*");
        } catch (e) {}
        (_a = this._opts.cookieJar) === null || _a === void 0 ? void 0 : _a.addCookies(xhr);
        // ie6 check
        if ("withCredentials" in xhr) {
          xhr.withCredentials = this._opts.withCredentials;
        }
        if (this._opts.requestTimeout) {
          xhr.timeout = this._opts.requestTimeout;
        }
        xhr.onreadystatechange = function () {
          var _a;
          if (xhr.readyState === 3) {
            (_a = _this5._opts.cookieJar) === null || _a === void 0 ? void 0 : _a.parseCookies(
            // @ts-ignore
            xhr.getResponseHeader("set-cookie"));
          }
          if (4 !== xhr.readyState) return;
          if (200 === xhr.status || 1223 === xhr.status) {
            _this5._onLoad();
          } else {
            // make sure the `error` event handler that's user-set
            // does not throw in the same tick and gets caught here
            _this5.setTimeoutFn(function () {
              _this5._onError(typeof xhr.status === "number" ? xhr.status : 0);
            }, 0);
          }
        };
        debug("xhr data %s", this._data);
        xhr.send(this._data);
      } catch (e) {
        // Need to defer since .create() is called directly from the constructor
        // and thus the 'error' event can only be only bound *after* this exception
        // occurs.  Therefore, also, we cannot throw here at all.
        this.setTimeoutFn(function () {
          _this5._onError(e);
        }, 0);
        return;
      }
      if (typeof document !== "undefined") {
        this._index = Request.requestsCount++;
        Request.requests[this._index] = this;
      }
    }
    /**
     * Called upon error.
     *
     * @private
     */
  }, {
    key: "_onError",
    value: function _onError(err) {
      this.emitReserved("error", err, this._xhr);
      this._cleanup(true);
    }
    /**
     * Cleans up house.
     *
     * @private
     */
  }, {
    key: "_cleanup",
    value: function _cleanup(fromError) {
      if ("undefined" === typeof this._xhr || null === this._xhr) {
        return;
      }
      this._xhr.onreadystatechange = empty;
      if (fromError) {
        try {
          this._xhr.abort();
        } catch (e) {}
      }
      if (typeof document !== "undefined") {
        delete Request.requests[this._index];
      }
      this._xhr = null;
    }
    /**
     * Called upon load.
     *
     * @private
     */
  }, {
    key: "_onLoad",
    value: function _onLoad() {
      var data = this._xhr.responseText;
      if (data !== null) {
        this.emitReserved("data", data);
        this.emitReserved("success");
        this._cleanup();
      }
    }
    /**
     * Aborts the request.
     *
     * @package
     */
  }, {
    key: "abort",
    value: function abort() {
      this._cleanup();
    }
  }]);
}(component_emitter_1.Emitter);
exports.Request = Request;
Request.requestsCount = 0;
Request.requests = {};
/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */
if (typeof document !== "undefined") {
  // @ts-ignore
  if (typeof attachEvent === "function") {
    // @ts-ignore
    attachEvent("onunload", unloadHandler);
  } else if (typeof addEventListener === "function") {
    var terminationEvent = "onpagehide" in globals_node_js_1.globalThisShim ? "pagehide" : "unload";
    addEventListener(terminationEvent, unloadHandler, false);
  }
}
function unloadHandler() {
  for (var i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}
var hasXHR2 = function () {
  var xhr = newRequest({
    xdomain: false
  });
  return xhr && xhr.responseType !== null;
}();
/**
 * HTTP long-polling based on the built-in `XMLHttpRequest` object.
 *
 * Usage: browser
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest
 */
var XHR = /*#__PURE__*/function (_BaseXHR) {
  function XHR(opts) {
    var _this6;
    _classCallCheck(this, XHR);
    _this6 = _callSuper(this, XHR, [opts]);
    var forceBase64 = opts && opts.forceBase64;
    _this6.supportsBinary = hasXHR2 && !forceBase64;
    return _this6;
  }
  _inherits(XHR, _BaseXHR);
  return _createClass(XHR, [{
    key: "request",
    value: function request() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      Object.assign(opts, {
        xd: this.xd
      }, this.opts);
      return new Request(newRequest, this.uri(), opts);
    }
  }]);
}(BaseXHR);
exports.XHR = XHR;
function newRequest(opts) {
  var xdomain = opts.xdomain;
  // XMLHttpRequest can be disabled on IE
  try {
    if ("undefined" !== typeof XMLHttpRequest && (!xdomain || has_cors_js_1.hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) {}
  if (!xdomain) {
    try {
      return new globals_node_js_1.globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch (e) {}
  }
}

},{"../contrib/has-cors.js":8,"../globals.node.js":11,"../util.js":21,"./polling.js":18,"@socket.io/component-emitter":1,"debug":22}],18:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _readOnlyError(r) { throw new TypeError('"' + r + '" is read-only'); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Polling = void 0;
var transport_js_1 = require("../transport.js");
var util_js_1 = require("../util.js");
var engine_io_parser_1 = require("engine.io-parser");
var debug_1 = __importDefault(require("debug")); // debug()
var debug = (0, debug_1["default"])("engine.io-client:polling"); // debug()
var Polling = /*#__PURE__*/function (_transport_js_1$Trans) {
  function Polling() {
    var _this;
    _classCallCheck(this, Polling);
    _this = _callSuper(this, Polling, arguments);
    _this._polling = false;
    return _this;
  }
  _inherits(Polling, _transport_js_1$Trans);
  return _createClass(Polling, [{
    key: "name",
    get: function get() {
      return "polling";
    }
    /**
     * Opens the socket (triggers polling). We write a PING message to determine
     * when the transport is open.
     *
     * @protected
     */
  }, {
    key: "doOpen",
    value: function doOpen() {
      this._poll();
    }
    /**
     * Pauses polling.
     *
     * @param {Function} onPause - callback upon buffers are flushed and transport is paused
     * @package
     */
  }, {
    key: "pause",
    value: function pause(onPause) {
      var _this2 = this;
      this.readyState = "pausing";
      var pause = function pause() {
        debug("paused");
        _this2.readyState = "paused";
        onPause();
      };
      if (this._polling || !this.writable) {
        var total = 0;
        if (this._polling) {
          debug("we are currently polling - waiting to pause");
          total++;
          this.once("pollComplete", function () {
            debug("pre-pause polling complete");
            --total || pause();
          });
        }
        if (!this.writable) {
          debug("we are currently writing - waiting to pause");
          total++;
          this.once("drain", function () {
            debug("pre-pause writing complete");
            --total || pause();
          });
        }
      } else {
        pause();
      }
    }
    /**
     * Starts polling cycle.
     *
     * @private
     */
  }, {
    key: "_poll",
    value: function _poll() {
      debug("polling");
      this._polling = true;
      this.doPoll();
      this.emitReserved("poll");
    }
    /**
     * Overloads onData to detect payloads.
     *
     * @protected
     */
  }, {
    key: "onData",
    value: function onData(data) {
      var _this3 = this;
      debug("polling got data %s", data);
      var callback = function callback(packet) {
        // if its the first message we consider the transport open
        if ("opening" === _this3.readyState && packet.type === "open") {
          _this3.onOpen();
        }
        // if its a close packet, we close the ongoing requests
        if ("close" === packet.type) {
          _this3.onClose({
            description: "transport closed by the server"
          });
          return false;
        }
        // otherwise bypass onData and handle the message
        _this3.onPacket(packet);
      };
      // decode payload
      (0, engine_io_parser_1.decodePayload)(data, this.socket.binaryType).forEach(callback);
      // if an event did not trigger closing
      if ("closed" !== this.readyState) {
        // if we got data we're not polling
        this._polling = false;
        this.emitReserved("pollComplete");
        if ("open" === this.readyState) {
          this._poll();
        } else {
          debug('ignoring poll - transport state "%s"', this.readyState);
        }
      }
    }
    /**
     * For polling, send a close packet.
     *
     * @protected
     */
  }, {
    key: "doClose",
    value: function doClose() {
      var _this4 = this;
      var close = function close() {
        debug("writing close packet");
        _this4.write([{
          type: "close"
        }]);
      };
      if ("open" === this.readyState) {
        debug("transport open - closing");
        close();
      } else {
        // in case we're trying to close while
        // handshaking is in progress (GH-164)
        debug("transport not open - deferring close");
        this.once("open", close);
      }
    }
    /**
     * Writes a packets payload.
     *
     * @param {Array} packets - data packets
     * @protected
     */
  }, {
    key: "write",
    value: function write(packets) {
      var _this5 = this;
      this.writable = false;
      (0, engine_io_parser_1.encodePayload)(packets, function (data) {
        _this5.doWrite(data, function () {
          _this5.writable = true;
          _this5.emitReserved("drain");
        });
      });
    }
    /**
     * Generates uri for connection.
     *
     * @private
     */
  }, {
    key: "uri",
    value: function uri() {
      var schema = this.opts.secure ? "https" : "http";
      var query = this.query || {};
      // cache busting is forced
      if (false !== this.opts.timestampRequests) {
        query[this.opts.timestampParam] = (0, util_js_1.randomString)();
      }
      if (!this.supportsBinary && !query.sid) {
        query.b64 = 1;
      }
      return this.createUri(schema, query);
    }
  }]);
}(transport_js_1.Transport);
exports.Polling = Polling;

},{"../transport.js":14,"../util.js":21,"debug":22,"engine.io-parser":28}],19:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WS = exports.BaseWS = void 0;
var transport_js_1 = require("../transport.js");
var util_js_1 = require("../util.js");
var engine_io_parser_1 = require("engine.io-parser");
var globals_node_js_1 = require("../globals.node.js");
var debug_1 = __importDefault(require("debug")); // debug()
var debug = (0, debug_1["default"])("engine.io-client:websocket"); // debug()
// detect ReactNative environment
var isReactNative = typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
var BaseWS = /*#__PURE__*/function (_transport_js_1$Trans) {
  function BaseWS() {
    _classCallCheck(this, BaseWS);
    return _callSuper(this, BaseWS, arguments);
  }
  _inherits(BaseWS, _transport_js_1$Trans);
  return _createClass(BaseWS, [{
    key: "name",
    get: function get() {
      return "websocket";
    }
  }, {
    key: "doOpen",
    value: function doOpen() {
      var uri = this.uri();
      var protocols = this.opts.protocols;
      // React Native only supports the 'headers' option, and will print a warning if anything else is passed
      var opts = isReactNative ? {} : (0, util_js_1.pick)(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
      if (this.opts.extraHeaders) {
        opts.headers = this.opts.extraHeaders;
      }
      try {
        this.ws = this.createSocket(uri, protocols, opts);
      } catch (err) {
        return this.emitReserved("error", err);
      }
      this.ws.binaryType = this.socket.binaryType;
      this.addEventListeners();
    }
    /**
     * Adds event listeners to the socket
     *
     * @private
     */
  }, {
    key: "addEventListeners",
    value: function addEventListeners() {
      var _this = this;
      this.ws.onopen = function () {
        if (_this.opts.autoUnref) {
          _this.ws._socket.unref();
        }
        _this.onOpen();
      };
      this.ws.onclose = function (closeEvent) {
        return _this.onClose({
          description: "websocket connection closed",
          context: closeEvent
        });
      };
      this.ws.onmessage = function (ev) {
        return _this.onData(ev.data);
      };
      this.ws.onerror = function (e) {
        return _this.onError("websocket error", e);
      };
    }
  }, {
    key: "write",
    value: function write(packets) {
      var _this2 = this;
      this.writable = false;
      // encodePacket efficient as it uses WS framing
      // no need for encodePayload
      var _loop = function _loop() {
        var packet = packets[i];
        var lastPacket = i === packets.length - 1;
        (0, engine_io_parser_1.encodePacket)(packet, _this2.supportsBinary, function (data) {
          // Sometimes the websocket has already been closed but the browser didn't
          // have a chance of informing us about it yet, in that case send will
          // throw an error
          try {
            _this2.doWrite(packet, data);
          } catch (e) {
            debug("websocket closed before onclose event");
          }
          if (lastPacket) {
            // fake drain
            // defer to next tick to allow Socket to clear writeBuffer
            (0, globals_node_js_1.nextTick)(function () {
              _this2.writable = true;
              _this2.emitReserved("drain");
            }, _this2.setTimeoutFn);
          }
        });
      };
      for (var i = 0; i < packets.length; i++) {
        _loop();
      }
    }
  }, {
    key: "doClose",
    value: function doClose() {
      if (typeof this.ws !== "undefined") {
        this.ws.onerror = function () {};
        this.ws.close();
        this.ws = null;
      }
    }
    /**
     * Generates uri for connection.
     *
     * @private
     */
  }, {
    key: "uri",
    value: function uri() {
      var schema = this.opts.secure ? "wss" : "ws";
      var query = this.query || {};
      // append timestamp to URI
      if (this.opts.timestampRequests) {
        query[this.opts.timestampParam] = (0, util_js_1.randomString)();
      }
      // communicate binary support capabilities
      if (!this.supportsBinary) {
        query.b64 = 1;
      }
      return this.createUri(schema, query);
    }
  }]);
}(transport_js_1.Transport);
exports.BaseWS = BaseWS;
var WebSocketCtor = globals_node_js_1.globalThisShim.WebSocket || globals_node_js_1.globalThisShim.MozWebSocket;
/**
 * WebSocket transport based on the built-in `WebSocket` object.
 *
 * Usage: browser, Node.js (since v21), Deno, Bun
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket
 * @see https://caniuse.com/mdn-api_websocket
 * @see https://nodejs.org/api/globals.html#websocket
 */
var WS = /*#__PURE__*/function (_BaseWS) {
  function WS() {
    _classCallCheck(this, WS);
    return _callSuper(this, WS, arguments);
  }
  _inherits(WS, _BaseWS);
  return _createClass(WS, [{
    key: "createSocket",
    value: function createSocket(uri, protocols, opts) {
      return !isReactNative ? protocols ? new WebSocketCtor(uri, protocols) : new WebSocketCtor(uri) : new WebSocketCtor(uri, protocols, opts);
    }
  }, {
    key: "doWrite",
    value: function doWrite(_packet, data) {
      this.ws.send(data);
    }
  }]);
}(BaseWS);
exports.WS = WS;

},{"../globals.node.js":11,"../transport.js":14,"../util.js":21,"debug":22,"engine.io-parser":28}],20:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WT = void 0;
var transport_js_1 = require("../transport.js");
var globals_node_js_1 = require("../globals.node.js");
var engine_io_parser_1 = require("engine.io-parser");
var debug_1 = __importDefault(require("debug")); // debug()
var debug = (0, debug_1["default"])("engine.io-client:webtransport"); // debug()
/**
 * WebTransport transport based on the built-in `WebTransport` object.
 *
 * Usage: browser, Node.js (with the `@fails-components/webtransport` package)
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/WebTransport
 * @see https://caniuse.com/webtransport
 */
var WT = /*#__PURE__*/function (_transport_js_1$Trans) {
  function WT() {
    _classCallCheck(this, WT);
    return _callSuper(this, WT, arguments);
  }
  _inherits(WT, _transport_js_1$Trans);
  return _createClass(WT, [{
    key: "name",
    get: function get() {
      return "webtransport";
    }
  }, {
    key: "doOpen",
    value: function doOpen() {
      var _this = this;
      try {
        // @ts-ignore
        this._transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
      } catch (err) {
        return this.emitReserved("error", err);
      }
      this._transport.closed.then(function () {
        debug("transport closed gracefully");
        _this.onClose();
      })["catch"](function (err) {
        debug("transport closed due to %s", err);
        _this.onError("webtransport error", err);
      });
      // note: we could have used async/await, but that would require some additional polyfills
      this._transport.ready.then(function () {
        _this._transport.createBidirectionalStream().then(function (stream) {
          var decoderStream = (0, engine_io_parser_1.createPacketDecoderStream)(Number.MAX_SAFE_INTEGER, _this.socket.binaryType);
          var reader = stream.readable.pipeThrough(decoderStream).getReader();
          var encoderStream = (0, engine_io_parser_1.createPacketEncoderStream)();
          encoderStream.readable.pipeTo(stream.writable);
          _this._writer = encoderStream.writable.getWriter();
          var _read = function read() {
            reader.read().then(function (_ref) {
              var done = _ref.done,
                value = _ref.value;
              if (done) {
                debug("session is closed");
                return;
              }
              debug("received chunk: %o", value);
              _this.onPacket(value);
              _read();
            })["catch"](function (err) {
              debug("an error occurred while reading: %s", err);
            });
          };
          _read();
          var packet = {
            type: "open"
          };
          if (_this.query.sid) {
            packet.data = "{\"sid\":\"".concat(_this.query.sid, "\"}");
          }
          _this._writer.write(packet).then(function () {
            return _this.onOpen();
          });
        });
      });
    }
  }, {
    key: "write",
    value: function write(packets) {
      var _this2 = this;
      this.writable = false;
      var _loop = function _loop() {
        var packet = packets[i];
        var lastPacket = i === packets.length - 1;
        _this2._writer.write(packet).then(function () {
          if (lastPacket) {
            (0, globals_node_js_1.nextTick)(function () {
              _this2.writable = true;
              _this2.emitReserved("drain");
            }, _this2.setTimeoutFn);
          }
        });
      };
      for (var i = 0; i < packets.length; i++) {
        _loop();
      }
    }
  }, {
    key: "doClose",
    value: function doClose() {
      var _a;
      (_a = this._transport) === null || _a === void 0 ? void 0 : _a.close();
    }
  }]);
}(transport_js_1.Transport);
exports.WT = WT;

},{"../globals.node.js":11,"../transport.js":14,"debug":22,"engine.io-parser":28}],21:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pick = pick;
exports.installTimerFunctions = installTimerFunctions;
exports.byteLength = byteLength;
exports.randomString = randomString;
var globals_node_js_1 = require("./globals.node.js");
function pick(obj) {
  for (var _len = arguments.length, attr = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    attr[_key - 1] = arguments[_key];
  }
  return attr.reduce(function (acc, k) {
    if (obj.hasOwnProperty(k)) {
      acc[k] = obj[k];
    }
    return acc;
  }, {});
}
// Keep a reference to the real timeout functions so they can be used when overridden
var NATIVE_SET_TIMEOUT = globals_node_js_1.globalThisShim.setTimeout;
var NATIVE_CLEAR_TIMEOUT = globals_node_js_1.globalThisShim.clearTimeout;
function installTimerFunctions(obj, opts) {
  if (opts.useNativeTimers) {
    obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globals_node_js_1.globalThisShim);
    obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globals_node_js_1.globalThisShim);
  } else {
    obj.setTimeoutFn = globals_node_js_1.globalThisShim.setTimeout.bind(globals_node_js_1.globalThisShim);
    obj.clearTimeoutFn = globals_node_js_1.globalThisShim.clearTimeout.bind(globals_node_js_1.globalThisShim);
  }
}
// base64 encoded buffers are about 33% bigger (https://en.wikipedia.org/wiki/Base64)
var BASE64_OVERHEAD = 1.33;
// we could also have used `new Blob([obj]).size`, but it isn't supported in IE9
function byteLength(obj) {
  if (typeof obj === "string") {
    return utf8Length(obj);
  }
  // arraybuffer or blob
  return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);
}
function utf8Length(str) {
  var c = 0,
    length = 0;
  for (var i = 0, l = str.length; i < l; i++) {
    c = str.charCodeAt(i);
    if (c < 0x80) {
      length += 1;
    } else if (c < 0x800) {
      length += 2;
    } else if (c < 0xd800 || c >= 0xe000) {
      length += 3;
    } else {
      i++;
      length += 4;
    }
  }
  return length;
}
/**
 * Generates a random 8-characters string.
 */
function randomString() {
  return Date.now().toString(36).substring(3) + Math.random().toString(36).substring(2, 5);
}

},{"./globals.node.js":11}],22:[function(require,module,exports){
(function (process){(function (){
"use strict";

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = function () {
  var warned = false;
  return function () {
    if (!warned) {
      warned = true;
      console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    }
  };
}();

/**
 * Colors.
 */

exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
    return true;
  }

  // Internet Explorer and Edge do not support colors.
  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  }
  var m;

  // Is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||
  // Is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) ||
  // Is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 ||
  // Double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);
  if (!this.useColors) {
    return;
  }
  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit');

  // The final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
    if (match === '%%') {
      return;
    }
    index++;
    if (match === '%c') {
      // We only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });
  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || function () {};

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
  try {
    if (namespaces) {
      exports.storage.setItem('debug', namespaces);
    } else {
      exports.storage.removeItem('debug');
    }
  } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
  }
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
  var r;
  try {
    r = exports.storage.getItem('debug');
  } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
  }

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }
  return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
    // The Browser also has localStorage in the global context.
    return localStorage;
  } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
  }
}
module.exports = require('./common')(exports);
var formatters = module.exports.formatters;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (error) {
    return '[UnexpectedJSONParseError]: ' + error.message;
  }
};

}).call(this)}).call(this,require('_process'))
},{"./common":23,"_process":74}],23:[function(require,module,exports){
"use strict";

function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
  createDebug.debug = createDebug;
  createDebug["default"] = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = require('ms');
  createDebug.destroy = destroy;
  Object.keys(env).forEach(function (key) {
    createDebug[key] = env[key];
  });

  /**
  * The currently active debug mode names, and names to skip.
  */

  createDebug.names = [];
  createDebug.skips = [];

  /**
  * Map of special "%n" handling functions, for the debug "format" argument.
  *
  * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
  */
  createDebug.formatters = {};

  /**
  * Selects a color for a debug namespace
  * @param {String} namespace The namespace string for the debug instance to be colored
  * @return {Number|String} An ANSI color code for the given namespace
  * @api private
  */
  function selectColor(namespace) {
    var hash = 0;
    for (var i = 0; i < namespace.length; i++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }
    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }
  createDebug.selectColor = selectColor;

  /**
  * Create a debugger with the given `namespace`.
  *
  * @param {String} namespace
  * @return {Function}
  * @api public
  */
  function createDebug(namespace) {
    var prevTime;
    var enableOverride = null;
    var namespacesCache;
    var enabledCache;
    function debug() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      // Disabled?
      if (!debug.enabled) {
        return;
      }
      var self = debug;

      // Set `diff` timestamp
      var curr = Number(new Date());
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);
      if (typeof args[0] !== 'string') {
        // Anything else let's inspect with %O
        args.unshift('%O');
      }

      // Apply any `formatters` transformations
      var index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
        // If we encounter an escaped % then don't increase the array index
        if (match === '%%') {
          return '%';
        }
        index++;
        var formatter = createDebug.formatters[format];
        if (typeof formatter === 'function') {
          var val = args[index];
          match = formatter.call(self, val);

          // Now we need to remove `args[index]` since it's inlined in the `format`
          args.splice(index, 1);
          index--;
        }
        return match;
      });

      // Apply env-specific formatting (colors, etc.)
      createDebug.formatArgs.call(self, args);
      var logFn = self.log || createDebug.log;
      logFn.apply(self, args);
    }
    debug.namespace = namespace;
    debug.useColors = createDebug.useColors();
    debug.color = createDebug.selectColor(namespace);
    debug.extend = extend;
    debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

    Object.defineProperty(debug, 'enabled', {
      enumerable: true,
      configurable: false,
      get: function get() {
        if (enableOverride !== null) {
          return enableOverride;
        }
        if (namespacesCache !== createDebug.namespaces) {
          namespacesCache = createDebug.namespaces;
          enabledCache = createDebug.enabled(namespace);
        }
        return enabledCache;
      },
      set: function set(v) {
        enableOverride = v;
      }
    });

    // Env-specific initialization logic for debug instances
    if (typeof createDebug.init === 'function') {
      createDebug.init(debug);
    }
    return debug;
  }
  function extend(namespace, delimiter) {
    var newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
    newDebug.log = this.log;
    return newDebug;
  }

  /**
  * Enables a debug mode by namespaces. This can include modes
  * separated by a colon and wildcards.
  *
  * @param {String} namespaces
  * @api public
  */
  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.namespaces = namespaces;
    createDebug.names = [];
    createDebug.skips = [];
    var i;
    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    var len = split.length;
    for (i = 0; i < len; i++) {
      if (!split[i]) {
        // ignore empty strings
        continue;
      }
      namespaces = split[i].replace(/\*/g, '.*?');
      if (namespaces[0] === '-') {
        createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
      } else {
        createDebug.names.push(new RegExp('^' + namespaces + '$'));
      }
    }
  }

  /**
  * Disable debug output.
  *
  * @return {String} namespaces
  * @api public
  */
  function disable() {
    var namespaces = [].concat(_toConsumableArray(createDebug.names.map(toNamespace)), _toConsumableArray(createDebug.skips.map(toNamespace).map(function (namespace) {
      return '-' + namespace;
    }))).join(',');
    createDebug.enable('');
    return namespaces;
  }

  /**
  * Returns true if the given mode name is enabled, false otherwise.
  *
  * @param {String} name
  * @return {Boolean}
  * @api public
  */
  function enabled(name) {
    if (name[name.length - 1] === '*') {
      return true;
    }
    var i;
    var len;
    for (i = 0, len = createDebug.skips.length; i < len; i++) {
      if (createDebug.skips[i].test(name)) {
        return false;
      }
    }
    for (i = 0, len = createDebug.names.length; i < len; i++) {
      if (createDebug.names[i].test(name)) {
        return true;
      }
    }
    return false;
  }

  /**
  * Convert regexp to namespace
  *
  * @param {RegExp} regxep
  * @return {String} namespace
  * @api private
  */
  function toNamespace(regexp) {
    return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, '*');
  }

  /**
  * Coerce `val`.
  *
  * @param {Mixed} val
  * @return {Mixed}
  * @api private
  */
  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }
    return val;
  }

  /**
  * XXX DO NOT USE. This is a temporary stub function.
  * XXX It WILL be removed in the next major release.
  */
  function destroy() {
    console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
  }
  createDebug.enable(createDebug.load());
  return createDebug;
}
module.exports = setup;

},{"ms":73}],24:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ERROR_PACKET = exports.PACKET_TYPES_REVERSE = exports.PACKET_TYPES = void 0;
var PACKET_TYPES = Object.create(null); // no Map = no polyfill
exports.PACKET_TYPES = PACKET_TYPES;
PACKET_TYPES["open"] = "0";
PACKET_TYPES["close"] = "1";
PACKET_TYPES["ping"] = "2";
PACKET_TYPES["pong"] = "3";
PACKET_TYPES["message"] = "4";
PACKET_TYPES["upgrade"] = "5";
PACKET_TYPES["noop"] = "6";
var PACKET_TYPES_REVERSE = Object.create(null);
exports.PACKET_TYPES_REVERSE = PACKET_TYPES_REVERSE;
Object.keys(PACKET_TYPES).forEach(function (key) {
  PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
});
var ERROR_PACKET = {
  type: "error",
  data: "parser error"
};
exports.ERROR_PACKET = ERROR_PACKET;

},{}],25:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decode = exports.encode = void 0;
// imported from https://github.com/socketio/base64-arraybuffer
var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
// Use a lookup table to find the index.
var lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
for (var i = 0; i < chars.length; i++) {
  lookup[chars.charCodeAt(i)] = i;
}
var encode = function encode(arraybuffer) {
  var bytes = new Uint8Array(arraybuffer),
    i,
    len = bytes.length,
    base64 = '';
  for (i = 0; i < len; i += 3) {
    base64 += chars[bytes[i] >> 2];
    base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
    base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
    base64 += chars[bytes[i + 2] & 63];
  }
  if (len % 3 === 2) {
    base64 = base64.substring(0, base64.length - 1) + '=';
  } else if (len % 3 === 1) {
    base64 = base64.substring(0, base64.length - 2) + '==';
  }
  return base64;
};
exports.encode = encode;
var decode = function decode(base64) {
  var bufferLength = base64.length * 0.75,
    len = base64.length,
    i,
    p = 0,
    encoded1,
    encoded2,
    encoded3,
    encoded4;
  if (base64[base64.length - 1] === '=') {
    bufferLength--;
    if (base64[base64.length - 2] === '=') {
      bufferLength--;
    }
  }
  var arraybuffer = new ArrayBuffer(bufferLength),
    bytes = new Uint8Array(arraybuffer);
  for (i = 0; i < len; i += 4) {
    encoded1 = lookup[base64.charCodeAt(i)];
    encoded2 = lookup[base64.charCodeAt(i + 1)];
    encoded3 = lookup[base64.charCodeAt(i + 2)];
    encoded4 = lookup[base64.charCodeAt(i + 3)];
    bytes[p++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return arraybuffer;
};
exports.decode = decode;

},{}],26:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decodePacket = void 0;
var commons_js_1 = require("./commons.js");
var base64_arraybuffer_js_1 = require("./contrib/base64-arraybuffer.js");
var withNativeArrayBuffer = typeof ArrayBuffer === "function";
var decodePacket = function decodePacket(encodedPacket, binaryType) {
  if (typeof encodedPacket !== "string") {
    return {
      type: "message",
      data: mapBinary(encodedPacket, binaryType)
    };
  }
  var type = encodedPacket.charAt(0);
  if (type === "b") {
    return {
      type: "message",
      data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
    };
  }
  var packetType = commons_js_1.PACKET_TYPES_REVERSE[type];
  if (!packetType) {
    return commons_js_1.ERROR_PACKET;
  }
  return encodedPacket.length > 1 ? {
    type: commons_js_1.PACKET_TYPES_REVERSE[type],
    data: encodedPacket.substring(1)
  } : {
    type: commons_js_1.PACKET_TYPES_REVERSE[type]
  };
};
exports.decodePacket = decodePacket;
var decodeBase64Packet = function decodeBase64Packet(data, binaryType) {
  if (withNativeArrayBuffer) {
    var decoded = (0, base64_arraybuffer_js_1.decode)(data);
    return mapBinary(decoded, binaryType);
  } else {
    return {
      base64: true,
      data: data
    }; // fallback for old browsers
  }
};
var mapBinary = function mapBinary(data, binaryType) {
  switch (binaryType) {
    case "blob":
      if (data instanceof Blob) {
        // from WebSocket + binaryType "blob"
        return data;
      } else {
        // from HTTP long-polling or WebTransport
        return new Blob([data]);
      }
    case "arraybuffer":
    default:
      if (data instanceof ArrayBuffer) {
        // from HTTP long-polling (base64) or WebSocket + binaryType "arraybuffer"
        return data;
      } else {
        // from WebTransport (Uint8Array)
        return data.buffer;
      }
  }
};

},{"./commons.js":24,"./contrib/base64-arraybuffer.js":25}],27:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.encodePacket = void 0;
exports.encodePacketToBinary = encodePacketToBinary;
var commons_js_1 = require("./commons.js");
var withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
var withNativeArrayBuffer = typeof ArrayBuffer === "function";
// ArrayBuffer.isView method is not defined in IE10
var isView = function isView(obj) {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;
};
var encodePacket = function encodePacket(_ref, supportsBinary, callback) {
  var type = _ref.type,
    data = _ref.data;
  if (withNativeBlob && data instanceof Blob) {
    if (supportsBinary) {
      return callback(data);
    } else {
      return encodeBlobAsBase64(data, callback);
    }
  } else if (withNativeArrayBuffer && (data instanceof ArrayBuffer || isView(data))) {
    if (supportsBinary) {
      return callback(data);
    } else {
      return encodeBlobAsBase64(new Blob([data]), callback);
    }
  }
  // plain string
  return callback(commons_js_1.PACKET_TYPES[type] + (data || ""));
};
exports.encodePacket = encodePacket;
var encodeBlobAsBase64 = function encodeBlobAsBase64(data, callback) {
  var fileReader = new FileReader();
  fileReader.onload = function () {
    var content = fileReader.result.split(",")[1];
    callback("b" + (content || ""));
  };
  return fileReader.readAsDataURL(data);
};
function toArray(data) {
  if (data instanceof Uint8Array) {
    return data;
  } else if (data instanceof ArrayBuffer) {
    return new Uint8Array(data);
  } else {
    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
  }
}
var TEXT_ENCODER;
function encodePacketToBinary(packet, callback) {
  if (withNativeBlob && packet.data instanceof Blob) {
    return packet.data.arrayBuffer().then(toArray).then(callback);
  } else if (withNativeArrayBuffer && (packet.data instanceof ArrayBuffer || isView(packet.data))) {
    return callback(toArray(packet.data));
  }
  encodePacket(packet, false, function (encoded) {
    if (!TEXT_ENCODER) {
      TEXT_ENCODER = new TextEncoder();
    }
    callback(TEXT_ENCODER.encode(encoded));
  });
}

},{"./commons.js":24}],28:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decodePayload = exports.decodePacket = exports.encodePayload = exports.encodePacket = exports.protocol = void 0;
exports.createPacketEncoderStream = createPacketEncoderStream;
exports.createPacketDecoderStream = createPacketDecoderStream;
var encodePacket_js_1 = require("./encodePacket.js");
Object.defineProperty(exports, "encodePacket", {
  enumerable: true,
  get: function get() {
    return encodePacket_js_1.encodePacket;
  }
});
var decodePacket_js_1 = require("./decodePacket.js");
Object.defineProperty(exports, "decodePacket", {
  enumerable: true,
  get: function get() {
    return decodePacket_js_1.decodePacket;
  }
});
var commons_js_1 = require("./commons.js");
var SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text
var encodePayload = function encodePayload(packets, callback) {
  // some packets may be added to the array while encoding, so the initial length must be saved
  var length = packets.length;
  var encodedPackets = new Array(length);
  var count = 0;
  packets.forEach(function (packet, i) {
    // force base64 encoding for binary packets
    (0, encodePacket_js_1.encodePacket)(packet, false, function (encodedPacket) {
      encodedPackets[i] = encodedPacket;
      if (++count === length) {
        callback(encodedPackets.join(SEPARATOR));
      }
    });
  });
};
exports.encodePayload = encodePayload;
var decodePayload = function decodePayload(encodedPayload, binaryType) {
  var encodedPackets = encodedPayload.split(SEPARATOR);
  var packets = [];
  for (var i = 0; i < encodedPackets.length; i++) {
    var decodedPacket = (0, decodePacket_js_1.decodePacket)(encodedPackets[i], binaryType);
    packets.push(decodedPacket);
    if (decodedPacket.type === "error") {
      break;
    }
  }
  return packets;
};
exports.decodePayload = decodePayload;
function createPacketEncoderStream() {
  return new TransformStream({
    transform: function transform(packet, controller) {
      (0, encodePacket_js_1.encodePacketToBinary)(packet, function (encodedPacket) {
        var payloadLength = encodedPacket.length;
        var header;
        // inspired by the WebSocket format: https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers#decoding_payload_length
        if (payloadLength < 126) {
          header = new Uint8Array(1);
          new DataView(header.buffer).setUint8(0, payloadLength);
        } else if (payloadLength < 65536) {
          header = new Uint8Array(3);
          var view = new DataView(header.buffer);
          view.setUint8(0, 126);
          view.setUint16(1, payloadLength);
        } else {
          header = new Uint8Array(9);
          var _view = new DataView(header.buffer);
          _view.setUint8(0, 127);
          _view.setBigUint64(1, BigInt(payloadLength));
        }
        // first bit indicates whether the payload is plain text (0) or binary (1)
        if (packet.data && typeof packet.data !== "string") {
          header[0] |= 0x80;
        }
        controller.enqueue(header);
        controller.enqueue(encodedPacket);
      });
    }
  });
}
var TEXT_DECODER;
function totalLength(chunks) {
  return chunks.reduce(function (acc, chunk) {
    return acc + chunk.length;
  }, 0);
}
function concatChunks(chunks, size) {
  if (chunks[0].length === size) {
    return chunks.shift();
  }
  var buffer = new Uint8Array(size);
  var j = 0;
  for (var i = 0; i < size; i++) {
    buffer[i] = chunks[0][j++];
    if (j === chunks[0].length) {
      chunks.shift();
      j = 0;
    }
  }
  if (chunks.length && j < chunks[0].length) {
    chunks[0] = chunks[0].slice(j);
  }
  return buffer;
}
function createPacketDecoderStream(maxPayload, binaryType) {
  if (!TEXT_DECODER) {
    TEXT_DECODER = new TextDecoder();
  }
  var chunks = [];
  var state = 0 /* State.READ_HEADER */;
  var expectedLength = -1;
  var isBinary = false;
  return new TransformStream({
    transform: function transform(chunk, controller) {
      chunks.push(chunk);
      while (true) {
        if (state === 0 /* State.READ_HEADER */) {
          if (totalLength(chunks) < 1) {
            break;
          }
          var header = concatChunks(chunks, 1);
          isBinary = (header[0] & 0x80) === 0x80;
          expectedLength = header[0] & 0x7f;
          if (expectedLength < 126) {
            state = 3 /* State.READ_PAYLOAD */;
          } else if (expectedLength === 126) {
            state = 1 /* State.READ_EXTENDED_LENGTH_16 */;
          } else {
            state = 2 /* State.READ_EXTENDED_LENGTH_64 */;
          }
        } else if (state === 1 /* State.READ_EXTENDED_LENGTH_16 */) {
          if (totalLength(chunks) < 2) {
            break;
          }
          var headerArray = concatChunks(chunks, 2);
          expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);
          state = 3 /* State.READ_PAYLOAD */;
        } else if (state === 2 /* State.READ_EXTENDED_LENGTH_64 */) {
          if (totalLength(chunks) < 8) {
            break;
          }
          var _headerArray = concatChunks(chunks, 8);
          var view = new DataView(_headerArray.buffer, _headerArray.byteOffset, _headerArray.length);
          var n = view.getUint32(0);
          if (n > Math.pow(2, 53 - 32) - 1) {
            // the maximum safe integer in JavaScript is 2^53 - 1
            controller.enqueue(commons_js_1.ERROR_PACKET);
            break;
          }
          expectedLength = n * Math.pow(2, 32) + view.getUint32(4);
          state = 3 /* State.READ_PAYLOAD */;
        } else {
          if (totalLength(chunks) < expectedLength) {
            break;
          }
          var data = concatChunks(chunks, expectedLength);
          controller.enqueue((0, decodePacket_js_1.decodePacket)(isBinary ? data : TEXT_DECODER.decode(data), binaryType));
          state = 0 /* State.READ_HEADER */;
        }
        if (expectedLength === 0 || expectedLength > maxPayload) {
          controller.enqueue(commons_js_1.ERROR_PACKET);
          break;
        }
      }
    }
  });
}
exports.protocol = 4;

},{"./commons.js":24,"./decodePacket.js":26,"./encodePacket.js":27}],29:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var R = (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === 'object' ? Reflect : null;
var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}
function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}
var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
};
function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;
function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + _typeof(listener));
  }
}
Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function get() {
    return defaultMaxListeners;
  },
  set: function set(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});
EventEmitter.init = function () {
  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};
function _getMaxListeners(that) {
  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = type === 'error';
  var events = this._events;
  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0) er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }
  var handler = events[type];
  if (handler === undefined) return false;
  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);
  }
  return true;
};
function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;
  checkListener(listener);
  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type, listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }
  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }
  return target;
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};
function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0) return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}
function _onceWrap(target, type, listener) {
  var state = {
    fired: false,
    wrapFn: undefined,
    target: target,
    type: type,
    listener: listener
  };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}
EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
};

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events, position, i, originalListener;
  checkListener(listener);
  events = this._events;
  if (events === undefined) return this;
  list = events[type];
  if (list === undefined) return this;
  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0) this._events = Object.create(null);else {
      delete events[type];
      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
    }
  } else if (typeof list !== 'function') {
    position = -1;
    for (i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }
    if (position < 0) return this;
    if (position === 0) list.shift();else {
      spliceOne(list, position);
    }
    if (list.length === 1) events[type] = list[0];
    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
  }
  return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners, events, i;
  events = this._events;
  if (events === undefined) return this;

  // not listening for removeListener, no need to emit
  if (events.removeListener === undefined) {
    if (arguments.length === 0) {
      this._events = Object.create(null);
      this._eventsCount = 0;
    } else if (events[type] !== undefined) {
      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];
    }
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    var keys = Object.keys(events);
    var key;
    for (i = 0; i < keys.length; ++i) {
      key = keys[i];
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = Object.create(null);
    this._eventsCount = 0;
    return this;
  }
  listeners = events[type];
  if (typeof listeners === 'function') {
    this.removeListener(type, listeners);
  } else if (listeners !== undefined) {
    // LIFO order
    for (i = listeners.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners[i]);
    }
  }
  return this;
};
function _listeners(target, type, unwrap) {
  var events = target._events;
  if (events === undefined) return [];
  var evlistener = events[type];
  if (evlistener === undefined) return [];
  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}
EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};
EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};
EventEmitter.listenerCount = function (emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;
  if (events !== undefined) {
    var evlistener = events[type];
    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i) copy[i] = arr[i];
  return copy;
}
function spliceOne(list, index) {
  for (; index + 1 < list.length; index++) list[index] = list[index + 1];
  list.pop();
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}
function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }
    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    }
    ;
    eventTargetAgnosticAddListener(emitter, name, resolver, {
      once: true
    });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, {
        once: true
      });
    }
  });
}
function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}
function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + _typeof(emitter));
  }
}

},{}],30:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FakeEventTarget = void 0;
var FakeEventTarget = /*#__PURE__*/function () {
  function FakeEventTarget() {
    _classCallCheck(this, FakeEventTarget);
    _defineProperty(this, "listeners", {});
  }
  return _createClass(FakeEventTarget, [{
    key: "addEventListener",
    value: function addEventListener(type, callback) {
      var _this$listeners, _this$listeners$type;
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      if (!callback) {
        return;
      }
      (_this$listeners$type = (_this$listeners = this.listeners)[type]) !== null && _this$listeners$type !== void 0 ? _this$listeners$type : _this$listeners[type] = [];
      this.listeners[type].push({
        callback: callback,
        once: options.once === true
      });
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener(type, callback) {
      if (!this.listeners[type]) {
        return;
      }
      this.listeners[type] = this.listeners[type].filter(function (listener) {
        return listener.callback !== callback;
      });
    }
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(event) {
      var _this = this;
      if (!event || typeof event.type !== 'string') {
        throw new Error('invalid event object');
      }
      var entries = this.listeners[event.type];
      if (!entries) {
        return true;
      }
      var _loop = function _loop() {
        var listener = _arr[_i];
        try {
          listener.callback.call(_this, event);
        } catch (error) {
          // Avoid that the error breaks the iteration.
          setTimeout(function () {
            throw error;
          }, 0);
        }
        if (listener.once) {
          _this.removeEventListener(event.type, listener.callback);
        }
      };
      for (var _i = 0, _arr = _toConsumableArray(entries); _i < _arr.length; _i++) {
        _loop();
      }
      return !event.defaultPrevented;
    }
  }]);
}();
exports.FakeEventTarget = FakeEventTarget;

},{}],31:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o("next", 0), o("throw", 1), o("return", 2); } }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FakeMediaStreamTrack = void 0;
var uuid_1 = require("uuid");
var FakeEventTarget_1 = require("./FakeEventTarget");
var utils_1 = require("./utils");
var _id = /*#__PURE__*/new WeakMap();
var _kind = /*#__PURE__*/new WeakMap();
var _label = /*#__PURE__*/new WeakMap();
var _readyState = /*#__PURE__*/new WeakMap();
var _enabled = /*#__PURE__*/new WeakMap();
var _muted = /*#__PURE__*/new WeakMap();
var _contentHint = /*#__PURE__*/new WeakMap();
var _capabilities = /*#__PURE__*/new WeakMap();
var _constraints = /*#__PURE__*/new WeakMap();
var _settings = /*#__PURE__*/new WeakMap();
var _data = /*#__PURE__*/new WeakMap();
var _onmute = /*#__PURE__*/new WeakMap();
var _onunmute = /*#__PURE__*/new WeakMap();
var _onended = /*#__PURE__*/new WeakMap();
var _onenabledchange = /*#__PURE__*/new WeakMap();
var _onstopped = /*#__PURE__*/new WeakMap();
var FakeMediaStreamTrack = /*#__PURE__*/function (_FakeEventTarget_1$Fa) {
  function FakeMediaStreamTrack(_ref) {
    var _this;
    var kind = _ref.kind,
      id = _ref.id,
      label = _ref.label,
      contentHint = _ref.contentHint,
      enabled = _ref.enabled,
      muted = _ref.muted,
      readyState = _ref.readyState,
      capabilities = _ref.capabilities,
      constraints = _ref.constraints,
      settings = _ref.settings,
      data = _ref.data;
    _classCallCheck(this, FakeMediaStreamTrack);
    _this = _callSuper(this, FakeMediaStreamTrack);
    _classPrivateFieldInitSpec(_this, _id, void 0);
    _classPrivateFieldInitSpec(_this, _kind, void 0);
    _classPrivateFieldInitSpec(_this, _label, void 0);
    _classPrivateFieldInitSpec(_this, _readyState, void 0);
    _classPrivateFieldInitSpec(_this, _enabled, void 0);
    _classPrivateFieldInitSpec(_this, _muted, void 0);
    _classPrivateFieldInitSpec(_this, _contentHint, void 0);
    _classPrivateFieldInitSpec(_this, _capabilities, void 0);
    _classPrivateFieldInitSpec(_this, _constraints, void 0);
    _classPrivateFieldInitSpec(_this, _settings, void 0);
    _classPrivateFieldInitSpec(_this, _data, void 0);
    // Events.
    _classPrivateFieldInitSpec(_this, _onmute, null);
    _classPrivateFieldInitSpec(_this, _onunmute, null);
    _classPrivateFieldInitSpec(_this, _onended, null);
    // Custom events.
    _classPrivateFieldInitSpec(_this, _onenabledchange, null);
    _classPrivateFieldInitSpec(_this, _onstopped, null);
    _classPrivateFieldSet(_id, _this, id !== null && id !== void 0 ? id : (0, uuid_1.v4)());
    _classPrivateFieldSet(_kind, _this, kind);
    _classPrivateFieldSet(_label, _this, label !== null && label !== void 0 ? label : '');
    _classPrivateFieldSet(_contentHint, _this, contentHint !== null && contentHint !== void 0 ? contentHint : '');
    _classPrivateFieldSet(_enabled, _this, enabled !== null && enabled !== void 0 ? enabled : true);
    _classPrivateFieldSet(_muted, _this, muted !== null && muted !== void 0 ? muted : false);
    _classPrivateFieldSet(_readyState, _this, readyState !== null && readyState !== void 0 ? readyState : 'live');
    _classPrivateFieldSet(_capabilities, _this, capabilities !== null && capabilities !== void 0 ? capabilities : {});
    _classPrivateFieldSet(_constraints, _this, constraints !== null && constraints !== void 0 ? constraints : {});
    _classPrivateFieldSet(_settings, _this, settings !== null && settings !== void 0 ? settings : {});
    _classPrivateFieldSet(_data, _this, data !== null && data !== void 0 ? data : {});
    return _this;
  }
  _inherits(FakeMediaStreamTrack, _FakeEventTarget_1$Fa);
  return _createClass(FakeMediaStreamTrack, [{
    key: "id",
    get: function get() {
      return _classPrivateFieldGet(_id, this);
    }
  }, {
    key: "kind",
    get: function get() {
      return _classPrivateFieldGet(_kind, this);
    }
  }, {
    key: "label",
    get: function get() {
      return _classPrivateFieldGet(_label, this);
    }
  }, {
    key: "contentHint",
    get: function get() {
      return _classPrivateFieldGet(_contentHint, this);
    },
    set: function set(contentHint) {
      _classPrivateFieldSet(_contentHint, this, contentHint);
    }
  }, {
    key: "enabled",
    get: function get() {
      return _classPrivateFieldGet(_enabled, this);
    }
    /**
     * Changes `enabled` member value and fires a custom "enabledchange" event.
     */,
    set: function set(enabled) {
      var changed = _classPrivateFieldGet(_enabled, this) !== enabled;
      _classPrivateFieldSet(_enabled, this, enabled);
      if (changed) {
        this.dispatchEvent(new Event('enabledchange'));
      }
    }
  }, {
    key: "muted",
    get: function get() {
      return _classPrivateFieldGet(_muted, this);
    }
  }, {
    key: "readyState",
    get: function get() {
      return _classPrivateFieldGet(_readyState, this);
    }
    /**
     * Application custom data getter.
     */
  }, {
    key: "data",
    get: function get() {
      return _classPrivateFieldGet(_data, this);
    }
    /**
     * Application custom data setter.
     */,
    set: function set(data) {
      _classPrivateFieldSet(_data, this, data);
    }
  }, {
    key: "onmute",
    get: function get() {
      return _classPrivateFieldGet(_onmute, this);
    },
    set: function set(handler) {
      if (_classPrivateFieldGet(_onmute, this)) {
        this.removeEventListener('mute', _classPrivateFieldGet(_onmute, this));
      }
      _classPrivateFieldSet(_onmute, this, handler);
      if (handler) {
        this.addEventListener('mute', handler);
      }
    }
  }, {
    key: "onunmute",
    get: function get() {
      return _classPrivateFieldGet(_onunmute, this);
    },
    set: function set(handler) {
      if (_classPrivateFieldGet(_onunmute, this)) {
        this.removeEventListener('unmute', _classPrivateFieldGet(_onunmute, this));
      }
      _classPrivateFieldSet(_onunmute, this, handler);
      if (handler) {
        this.addEventListener('unmute', handler);
      }
    }
  }, {
    key: "onended",
    get: function get() {
      return _classPrivateFieldGet(_onended, this);
    },
    set: function set(handler) {
      if (_classPrivateFieldGet(_onended, this)) {
        this.removeEventListener('ended', _classPrivateFieldGet(_onended, this));
      }
      _classPrivateFieldSet(_onended, this, handler);
      if (handler) {
        this.addEventListener('ended', handler);
      }
    }
  }, {
    key: "onenabledchange",
    get: function get() {
      return _classPrivateFieldGet(_onenabledchange, this);
    },
    set: function set(handler) {
      if (_classPrivateFieldGet(_onenabledchange, this)) {
        this.removeEventListener('enabledchange', _classPrivateFieldGet(_onenabledchange, this));
      }
      _classPrivateFieldSet(_onenabledchange, this, handler);
      if (handler) {
        this.addEventListener('enabledchange', handler);
      }
    }
  }, {
    key: "onstopped",
    get: function get() {
      return _classPrivateFieldGet(_onstopped, this);
    },
    set: function set(handler) {
      if (_classPrivateFieldGet(_onstopped, this)) {
        this.removeEventListener('stopped', _classPrivateFieldGet(_onstopped, this));
      }
      _classPrivateFieldSet(_onstopped, this, handler);
      if (handler) {
        this.addEventListener('stopped', handler);
      }
    }
  }, {
    key: "addEventListener",
    value: function addEventListener(type, listener, options) {
      _superPropGet(FakeMediaStreamTrack, "addEventListener", this, 3)([type, listener, options]);
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener(type, listener) {
      _superPropGet(FakeMediaStreamTrack, "removeEventListener", this, 3)([type, listener]);
    }
    /**
     * Changes `readyState` member to "ended" and fires a custom "stopped" event
     * (if not already stopped).
     */
  }, {
    key: "stop",
    value: function stop() {
      if (_classPrivateFieldGet(_readyState, this) === 'ended') {
        return;
      }
      _classPrivateFieldSet(_readyState, this, 'ended');
      this.dispatchEvent(new Event('stopped'));
    }
    /**
     * Clones current track into another FakeMediaStreamTrack. `id` and `data`
     * can be optionally given.
     */
  }, {
    key: "clone",
    value: function clone() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        id = _ref2.id,
        data = _ref2.data;
      return new FakeMediaStreamTrack({
        id: id !== null && id !== void 0 ? id : (0, uuid_1.v4)(),
        kind: _classPrivateFieldGet(_kind, this),
        label: _classPrivateFieldGet(_label, this),
        contentHint: _classPrivateFieldGet(_contentHint, this),
        enabled: _classPrivateFieldGet(_enabled, this),
        muted: _classPrivateFieldGet(_muted, this),
        readyState: _classPrivateFieldGet(_readyState, this),
        capabilities: (0, utils_1.clone)(_classPrivateFieldGet(_capabilities, this)),
        constraints: (0, utils_1.clone)(_classPrivateFieldGet(_constraints, this)),
        settings: (0, utils_1.clone)(_classPrivateFieldGet(_settings, this)),
        data: data !== null && data !== void 0 ? data : (0, utils_1.clone)(_classPrivateFieldGet(_data, this))
      });
    }
  }, {
    key: "getCapabilities",
    value: function getCapabilities() {
      return _classPrivateFieldGet(_capabilities, this);
    }
  }, {
    key: "getConstraints",
    value: function getConstraints() {
      return _classPrivateFieldGet(_constraints, this);
    }
  }, {
    key: "applyConstraints",
    value: function () {
      var _applyConstraints = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {
        var constraints,
          _args = arguments;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              constraints = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};
              _classPrivateFieldSet(_constraints, this, constraints);
              // To make it be "more" async so ESLint doesn't complain.
              return _context.a(2, Promise.resolve());
          }
        }, _callee, this);
      }));
      function applyConstraints() {
        return _applyConstraints.apply(this, arguments);
      }
      return applyConstraints;
    }()
  }, {
    key: "getSettings",
    value: function getSettings() {
      return _classPrivateFieldGet(_settings, this);
    }
    /**
     * Simulates a remotely triggered stop. It fires a custom "stopped" event and
     * the standard "ended" event (if the track was not already stopped).
     */
  }, {
    key: "remoteStop",
    value: function remoteStop() {
      if (_classPrivateFieldGet(_readyState, this) === 'ended') {
        return;
      }
      _classPrivateFieldSet(_readyState, this, 'ended');
      this.dispatchEvent(new Event('stopped'));
      this.dispatchEvent(new Event('ended'));
    }
    /**
     * Simulates a remotely triggered mute. It fires a "mute" event (if the track
     * was not already muted).
     */
  }, {
    key: "remoteMute",
    value: function remoteMute() {
      if (_classPrivateFieldGet(_muted, this)) {
        return;
      }
      _classPrivateFieldSet(_muted, this, true);
      this.dispatchEvent(new Event('mute'));
    }
    /**
     * Simulates a remotely triggered unmute. It fires an "unmute" event (if the
     * track was muted).
     */
  }, {
    key: "remoteUnmute",
    value: function remoteUnmute() {
      if (!_classPrivateFieldGet(_muted, this)) {
        return;
      }
      _classPrivateFieldSet(_muted, this, false);
      this.dispatchEvent(new Event('unmute'));
    }
  }]);
}(FakeEventTarget_1.FakeEventTarget);
exports.FakeMediaStreamTrack = FakeMediaStreamTrack;

},{"./FakeEventTarget":30,"./utils":32,"uuid":93}],32:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clone = clone;
/**
 * Clones the given value.
 */
function clone(value) {
  if (value === undefined) {
    return undefined;
  } else if (Number.isNaN(value)) {
    return NaN;
  } else if (typeof structuredClone === 'function') {
    // Available in Node >= 18.
    return structuredClone(value);
  } else {
    return JSON.parse(JSON.stringify(value));
  }
}

},{}],33:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Logger = void 0;
var debug_1 = __importDefault(require("debug"));
var APP_NAME = 'h264-profile-level-id';
var Logger = /*#__PURE__*/function () {
  function Logger(prefix) {
    _classCallCheck(this, Logger);
    if (prefix) {
      this._debug = (0, debug_1["default"])("".concat(APP_NAME, ":").concat(prefix));
      this._warn = (0, debug_1["default"])("".concat(APP_NAME, ":WARN:").concat(prefix));
      this._error = (0, debug_1["default"])("".concat(APP_NAME, ":ERROR:").concat(prefix));
    } else {
      this._debug = (0, debug_1["default"])(APP_NAME);
      this._warn = (0, debug_1["default"])("".concat(APP_NAME, ":WARN"));
      this._error = (0, debug_1["default"])("".concat(APP_NAME, ":ERROR"));
    }
    /* eslint-disable no-console */
    this._debug.log = console.info.bind(console);
    this._warn.log = console.warn.bind(console);
    this._error.log = console.error.bind(console);
    /* eslint-enable no-console */
  }
  return _createClass(Logger, [{
    key: "debug",
    get: function get() {
      return this._debug;
    }
  }, {
    key: "warn",
    get: function get() {
      return this._warn;
    }
  }, {
    key: "error",
    get: function get() {
      return this._error;
    }
  }]);
}();
exports.Logger = Logger;

},{"debug":6}],34:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ProfileLevelId = exports.Level = exports.Profile = void 0;
exports.parseProfileLevelId = parseProfileLevelId;
exports.profileLevelIdToString = profileLevelIdToString;
exports.profileToString = profileToString;
exports.levelToString = levelToString;
exports.parseSdpProfileLevelId = parseSdpProfileLevelId;
exports.isSameProfile = isSameProfile;
exports.isSameProfileAndLevel = isSameProfileAndLevel;
exports.generateProfileLevelIdStringForAnswer = generateProfileLevelIdStringForAnswer;
exports.supportedLevel = supportedLevel;
var Logger_1 = require("./Logger");
var logger = new Logger_1.Logger();
/**
 * Supported profiles.
 */
var Profile;
(function (Profile) {
  Profile[Profile["ConstrainedBaseline"] = 1] = "ConstrainedBaseline";
  Profile[Profile["Baseline"] = 2] = "Baseline";
  Profile[Profile["Main"] = 3] = "Main";
  Profile[Profile["ConstrainedHigh"] = 4] = "ConstrainedHigh";
  Profile[Profile["High"] = 5] = "High";
  Profile[Profile["PredictiveHigh444"] = 6] = "PredictiveHigh444";
})(Profile || (exports.Profile = Profile = {}));
/**
 * Supported levels.
 */
var Level;
(function (Level) {
  Level[Level["L1_b"] = 0] = "L1_b";
  Level[Level["L1"] = 10] = "L1";
  Level[Level["L1_1"] = 11] = "L1_1";
  Level[Level["L1_2"] = 12] = "L1_2";
  Level[Level["L1_3"] = 13] = "L1_3";
  Level[Level["L2"] = 20] = "L2";
  Level[Level["L2_1"] = 21] = "L2_1";
  Level[Level["L2_2"] = 22] = "L2_2";
  Level[Level["L3"] = 30] = "L3";
  Level[Level["L3_1"] = 31] = "L3_1";
  Level[Level["L3_2"] = 32] = "L3_2";
  Level[Level["L4"] = 40] = "L4";
  Level[Level["L4_1"] = 41] = "L4_1";
  Level[Level["L4_2"] = 42] = "L4_2";
  Level[Level["L5"] = 50] = "L5";
  Level[Level["L5_1"] = 51] = "L5_1";
  Level[Level["L5_2"] = 52] = "L5_2";
})(Level || (exports.Level = Level = {}));
/**
 * Represents a parsed h264 profile-level-id value.
 */
var ProfileLevelId = /*#__PURE__*/_createClass(function ProfileLevelId(profile, level) {
  _classCallCheck(this, ProfileLevelId);
  this.profile = profile;
  this.level = level;
});
exports.ProfileLevelId = ProfileLevelId;
// Default ProfileLevelId.
//
// TODO: The default should really be profile Baseline and level 1 according to
// the spec: https://tools.ietf.org/html/rfc6184#section-8.1. In order to not
// break backwards compatibility with older versions of WebRTC where external
// codecs don't have any parameters, use profile ConstrainedBaseline level 3_1
// instead. This workaround will only be done in an interim period to allow
// external clients to update their code.
//
// http://crbug/webrtc/6337.
var DefaultProfileLevelId = new ProfileLevelId(Profile.ConstrainedBaseline, Level.L3_1);
/**
 * Class for matching bit patterns such as "x1xx0000" where 'x' is allowed to
 * be either 0 or 1.
 */
var BitPattern = /*#__PURE__*/function () {
  function BitPattern(str) {
    _classCallCheck(this, BitPattern);
    this.mask = ~byteMaskString('x', str);
    this.masked_value = byteMaskString('1', str);
  }
  return _createClass(BitPattern, [{
    key: "isMatch",
    value: function isMatch(value) {
      return this.masked_value === (value & this.mask);
    }
  }]);
}();
/**
 * Class for converting between profile_idc/profile_iop to Profile.
 */
var ProfilePattern = /*#__PURE__*/_createClass(function ProfilePattern(profile_idc, profile_iop, profile) {
  _classCallCheck(this, ProfilePattern);
  this.profile_idc = profile_idc;
  this.profile_iop = profile_iop;
  this.profile = profile;
}); // This is from https://tools.ietf.org/html/rfc6184#section-8.1.
var ProfilePatterns = [new ProfilePattern(0x42, new BitPattern('x1xx0000'), Profile.ConstrainedBaseline), new ProfilePattern(0x4d, new BitPattern('1xxx0000'), Profile.ConstrainedBaseline), new ProfilePattern(0x58, new BitPattern('11xx0000'), Profile.ConstrainedBaseline), new ProfilePattern(0x42, new BitPattern('x0xx0000'), Profile.Baseline), new ProfilePattern(0x58, new BitPattern('10xx0000'), Profile.Baseline), new ProfilePattern(0x4d, new BitPattern('0x0x0000'), Profile.Main), new ProfilePattern(0x64, new BitPattern('00000000'), Profile.High), new ProfilePattern(0x64, new BitPattern('00001100'), Profile.ConstrainedHigh), new ProfilePattern(0xf4, new BitPattern('00000000'), Profile.PredictiveHigh444)];
// This is from ITU-T H.264 (02/2016) Table A-1 – Level limits.
var LevelConstraints = [{
  max_macroblocks_per_second: 1485,
  max_macroblock_frame_size: 99,
  level: Level.L1
}, {
  max_macroblocks_per_second: 1485,
  max_macroblock_frame_size: 99,
  level: Level.L1_b
}, {
  max_macroblocks_per_second: 3000,
  max_macroblock_frame_size: 396,
  level: Level.L1_1
}, {
  max_macroblocks_per_second: 6000,
  max_macroblock_frame_size: 396,
  level: Level.L1_2
}, {
  max_macroblocks_per_second: 11880,
  max_macroblock_frame_size: 396,
  level: Level.L1_3
}, {
  max_macroblocks_per_second: 11880,
  max_macroblock_frame_size: 396,
  level: Level.L2
}, {
  max_macroblocks_per_second: 19800,
  max_macroblock_frame_size: 792,
  level: Level.L2_1
}, {
  max_macroblocks_per_second: 20250,
  max_macroblock_frame_size: 1620,
  level: Level.L2_2
}, {
  max_macroblocks_per_second: 40500,
  max_macroblock_frame_size: 1620,
  level: Level.L3
}, {
  max_macroblocks_per_second: 108000,
  max_macroblock_frame_size: 3600,
  level: Level.L3_1
}, {
  max_macroblocks_per_second: 216000,
  max_macroblock_frame_size: 5120,
  level: Level.L3_2
}, {
  max_macroblocks_per_second: 245760,
  max_macroblock_frame_size: 8192,
  level: Level.L4
}, {
  max_macroblocks_per_second: 245760,
  max_macroblock_frame_size: 8192,
  level: Level.L4_1
}, {
  max_macroblocks_per_second: 522240,
  max_macroblock_frame_size: 8704,
  level: Level.L4_2
}, {
  max_macroblocks_per_second: 589824,
  max_macroblock_frame_size: 22080,
  level: Level.L5
}, {
  max_macroblocks_per_second: 983040,
  max_macroblock_frame_size: 36864,
  level: Level.L5_1
}, {
  max_macroblocks_per_second: 2073600,
  max_macroblock_frame_size: 36864,
  level: Level.L5_2
}];
/**
 * Parse profile level id that is represented as a string of 3 hex bytes.
 * Nothing will be returned if the string is not a recognized H264 profile
 * level id.
 */
function parseProfileLevelId(str) {
  // For level_idc=11 and profile_idc=0x42, 0x4D, or 0x58, the constraint set3
  // flag specifies if level 1b or level 1.1 is used.
  var ConstraintSet3Flag = 0x10;
  // The string should consist of 3 bytes in hexadecimal format.
  if (typeof str !== 'string' || str.length !== 6) {
    return undefined;
  }
  var profile_level_id_numeric = parseInt(str, 16);
  if (profile_level_id_numeric === 0) {
    return undefined;
  }
  // Separate into three bytes.
  var level_idc = profile_level_id_numeric & 0xff;
  var profile_iop = profile_level_id_numeric >> 8 & 0xff;
  var profile_idc = profile_level_id_numeric >> 16 & 0xff;
  // Parse level based on level_idc and constraint set 3 flag.
  var level;
  switch (level_idc) {
    case Level.L1_1:
      {
        level = (profile_iop & ConstraintSet3Flag) !== 0 ? Level.L1_b : Level.L1_1;
        break;
      }
    case Level.L1:
    case Level.L1_2:
    case Level.L1_3:
    case Level.L2:
    case Level.L2_1:
    case Level.L2_2:
    case Level.L3:
    case Level.L3_1:
    case Level.L3_2:
    case Level.L4:
    case Level.L4_1:
    case Level.L4_2:
    case Level.L5:
    case Level.L5_1:
    case Level.L5_2:
      {
        level = level_idc;
        break;
      }
    // Unrecognized level_idc.
    default:
      {
        logger.warn("parseProfileLevelId() | unrecognized level_idc [str:".concat(str, ", level_idc:").concat(level_idc, "]"));
        return undefined;
      }
  }
  // Parse profile_idc/profile_iop into a Profile enum.
  var _iterator = _createForOfIteratorHelper(ProfilePatterns),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var pattern = _step.value;
      if (profile_idc === pattern.profile_idc && pattern.profile_iop.isMatch(profile_iop)) {
        logger.debug("parseProfileLevelId() | result [str:".concat(str, ", profile:").concat(pattern.profile, ", level:").concat(level, "]"));
        return new ProfileLevelId(pattern.profile, level);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  logger.warn("parseProfileLevelId() | unrecognized profile_idc/profile_iop combination [str:".concat(str, ", profile_idc:").concat(profile_idc, ", profile_iop:").concat(profile_iop, "]"));
  return undefined;
}
/**
 * Returns canonical string representation as three hex bytes of the profile
 * level id, or returns nothing for invalid profile level ids.
 */
function profileLevelIdToString(profile_level_id) {
  // Handle special case level == 1b.
  if (profile_level_id.level == Level.L1_b) {
    switch (profile_level_id.profile) {
      case Profile.ConstrainedBaseline:
        {
          return '42f00b';
        }
      case Profile.Baseline:
        {
          return '42100b';
        }
      case Profile.Main:
        {
          return '4d100b';
        }
      // Level 1_b is not allowed for other profiles.
      default:
        {
          logger.warn("profileLevelIdToString() | Level 1_b not is allowed for profile ".concat(profile_level_id.profile));
          return undefined;
        }
    }
  }
  var profile_idc_iop_string;
  switch (profile_level_id.profile) {
    case Profile.ConstrainedBaseline:
      {
        profile_idc_iop_string = '42e0';
        break;
      }
    case Profile.Baseline:
      {
        profile_idc_iop_string = '4200';
        break;
      }
    case Profile.Main:
      {
        profile_idc_iop_string = '4d00';
        break;
      }
    case Profile.ConstrainedHigh:
      {
        profile_idc_iop_string = '640c';
        break;
      }
    case Profile.High:
      {
        profile_idc_iop_string = '6400';
        break;
      }
    case Profile.PredictiveHigh444:
      {
        profile_idc_iop_string = 'f400';
        break;
      }
    default:
      {
        logger.warn("profileLevelIdToString() | unrecognized profile ".concat(profile_level_id.profile));
        return undefined;
      }
  }
  var levelStr = profile_level_id.level.toString(16);
  if (levelStr.length === 1) {
    levelStr = "0".concat(levelStr);
  }
  return "".concat(profile_idc_iop_string).concat(levelStr);
}
/**
 * Returns a human friendly name for the given profile.
 */
function profileToString(profile) {
  switch (profile) {
    case Profile.ConstrainedBaseline:
      {
        return 'ConstrainedBaseline';
      }
    case Profile.Baseline:
      {
        return 'Baseline';
      }
    case Profile.Main:
      {
        return 'Main';
      }
    case Profile.ConstrainedHigh:
      {
        return 'ConstrainedHigh';
      }
    case Profile.High:
      {
        return 'High';
      }
    case Profile.PredictiveHigh444:
      {
        return 'PredictiveHigh444';
      }
    default:
      {
        logger.warn("profileToString() | unrecognized profile ".concat(profile));
        return undefined;
      }
  }
}
/**
 * Returns a human friendly name for the given level.
 */
function levelToString(level) {
  switch (level) {
    case Level.L1_b:
      {
        return '1b';
      }
    case Level.L1:
      {
        return '1';
      }
    case Level.L1_1:
      {
        return '1.1';
      }
    case Level.L1_2:
      {
        return '1.2';
      }
    case Level.L1_3:
      {
        return '1.3';
      }
    case Level.L2:
      {
        return '2';
      }
    case Level.L2_1:
      {
        return '2.1';
      }
    case Level.L2_2:
      {
        return '2.2';
      }
    case Level.L3:
      {
        return '3';
      }
    case Level.L3_1:
      {
        return '3.1';
      }
    case Level.L3_2:
      {
        return '3.2';
      }
    case Level.L4:
      {
        return '4';
      }
    case Level.L4_1:
      {
        return '4.1';
      }
    case Level.L4_2:
      {
        return '4.2';
      }
    case Level.L5:
      {
        return '5';
      }
    case Level.L5_1:
      {
        return '5.1';
      }
    case Level.L5_2:
      {
        return '5.2';
      }
    default:
      {
        logger.warn("levelToString() | unrecognized level ".concat(level));
        return undefined;
      }
  }
}
/**
 * Parse profile level id that is represented as a string of 3 hex bytes
 * contained in an SDP key-value map. A default profile level id will be
 * returned if the profile-level-id key is missing. Nothing will be returned
 * if the key is present but the string is invalid.
 */
function parseSdpProfileLevelId() {
  var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var profile_level_id = params['profile-level-id'];
  return profile_level_id ? parseProfileLevelId(profile_level_id) : DefaultProfileLevelId;
}
/**
 * Returns true if the codec parameters have the same H264 profile, i.e. the
 * same H264 profile (Baseline, High, etc).
 */
function isSameProfile() {
  var params1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var params2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var profile_level_id_1 = parseSdpProfileLevelId(params1);
  var profile_level_id_2 = parseSdpProfileLevelId(params2);
  // Compare H264 profiles, but not levels.
  return Boolean(profile_level_id_1 && profile_level_id_2 && profile_level_id_1.profile === profile_level_id_2.profile);
}
/**
 * Returns true if the codec parameters have the same H264 profile, i.e. the
 * same H264 profile (Baseline, High, etc) and same level.
 */
function isSameProfileAndLevel() {
  var params1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var params2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var profile_level_id_1 = parseSdpProfileLevelId(params1);
  var profile_level_id_2 = parseSdpProfileLevelId(params2);
  // Compare H264 profiles, but not levels.
  return Boolean(profile_level_id_1 && profile_level_id_2 && profile_level_id_1.profile === profile_level_id_2.profile && profile_level_id_1.level == profile_level_id_2.level);
}
/**
 * Generate codec parameters that will be used as answer in an SDP negotiation
 * based on local supported parameters and remote offered parameters. Both
 * local_supported_params and remote_offered_params represent sendrecv media
 * descriptions, i.e they are a mix of both encode and decode capabilities. In
 * theory, when the profile in local_supported_params represent a strict
 * superset of the profile in remote_offered_params, we could limit the profile
 * in the answer to the profile in remote_offered_params.
 *
 * However, to simplify the code, each supported H264 profile should be listed
 * explicitly in the list of local supported codecs, even if they are redundant.
 * Then each local codec in the list should be tested one at a time against the
 * remote codec, and only when the profiles are equal should this function be
 * called. Therefore, this function does not need to handle profile intersection,
 * and the profile of local_supported_params and remote_offered_params must be
 * equal before calling this function. The parameters that are used when
 * negotiating are the level part of profile-level-id and
 * level-asymmetry-allowed.
 */
function generateProfileLevelIdStringForAnswer() {
  var local_supported_params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var remote_offered_params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  // If both local and remote params do not contain profile-level-id, they are
  // both using the default profile. In this case, don't return anything.
  if (!local_supported_params['profile-level-id'] && !remote_offered_params['profile-level-id']) {
    logger.warn('generateProfileLevelIdStringForAnswer() | profile-level-id missing in local and remote params');
    return undefined;
  }
  // Parse profile-level-ids.
  var local_profile_level_id = parseSdpProfileLevelId(local_supported_params);
  var remote_profile_level_id = parseSdpProfileLevelId(remote_offered_params);
  // The local and remote codec must have valid and equal H264 Profiles.
  if (!local_profile_level_id) {
    throw new TypeError('invalid local_profile_level_id');
  }
  if (!remote_profile_level_id) {
    throw new TypeError('invalid remote_profile_level_id');
  }
  if (local_profile_level_id.profile !== remote_profile_level_id.profile) {
    throw new TypeError('H264 Profile mismatch');
  }
  // Parse level information.
  var level_asymmetry_allowed = isLevelAsymmetryAllowed(local_supported_params) && isLevelAsymmetryAllowed(remote_offered_params);
  var local_level = local_profile_level_id.level;
  var remote_level = remote_profile_level_id.level;
  var min_level = minLevel(local_level, remote_level);
  // Determine answer level. When level asymmetry is not allowed, level upgrade
  // is not allowed, i.e., the level in the answer must be equal to or lower
  // than the level in the offer.
  var answer_level = level_asymmetry_allowed ? local_level : min_level;
  logger.debug("generateProfileLevelIdStringForAnswer() | result [profile:".concat(local_profile_level_id.profile, ", level:").concat(answer_level, "]"));
  // Return the resulting profile-level-id for the answer parameters.
  return profileLevelIdToString(new ProfileLevelId(local_profile_level_id.profile, answer_level));
}
/**
 * Given that a decoder supports up to a given frame size (in pixels) at up to
 * a given number of frames per second, return the highest H264 level where it
 * can guarantee that it will be able to support all valid encoded streams that
 * are within that level.
 */
function supportedLevel(max_frame_pixel_count, max_fps) {
  var PixelsPerMacroblock = 16 * 16;
  for (var i = LevelConstraints.length - 1; i >= 0; --i) {
    var level_constraint = LevelConstraints[i];
    if (level_constraint.max_macroblock_frame_size * PixelsPerMacroblock <= max_frame_pixel_count && level_constraint.max_macroblocks_per_second <= max_fps * level_constraint.max_macroblock_frame_size) {
      logger.debug("supportedLevel() | result [max_frame_pixel_count:".concat(max_frame_pixel_count, ", max_fps:").concat(max_fps, ", level:").concat(level_constraint.level, "]"));
      return level_constraint.level;
    }
  }
  // No level supported.
  logger.warn("supportedLevel() | no level supported [max_frame_pixel_count:".concat(max_frame_pixel_count, ", max_fps:").concat(max_fps, "]"));
  return undefined;
}
/**
 * Convert a string of 8 characters into a byte where the positions containing
 * character c will have their bit set. For example, c = 'x', str = "x1xx0000"
 * will return 0b10110000.
 */
function byteMaskString(c, str) {
  return Number(str[0] === c) << 7 | Number(str[1] === c) << 6 | Number(str[2] === c) << 5 | Number(str[3] === c) << 4 | Number(str[4] === c) << 3 | Number(str[5] === c) << 2 | Number(str[6] === c) << 1 | Number(str[7] === c) << 0;
}
// Compare H264 levels and handle the level 1b case.
function isLessLevel(a, b) {
  if (a === Level.L1_b) {
    return b !== Level.L1 && b !== Level.L1_b;
  }
  if (b === Level.L1_b) {
    return a !== Level.L1;
  }
  return a < b;
}
function minLevel(a, b) {
  return isLessLevel(a, b) ? a : b;
}
function isLevelAsymmetryAllowed() {
  var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var level_asymmetry_allowed = params['level-asymmetry-allowed'];
  return level_asymmetry_allowed === true || level_asymmetry_allowed === 1 || level_asymmetry_allowed === '1';
}

},{"./Logger":33}],35:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o("next", 0), o("throw", 1), o("return", 2); } }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Consumer = void 0;
var Logger_1 = require("./Logger");
var enhancedEvents_1 = require("./enhancedEvents");
var errors_1 = require("./errors");
var logger = new Logger_1.Logger('Consumer');
var Consumer = /*#__PURE__*/function (_enhancedEvents_1$Enh) {
  function Consumer(_ref) {
    var _this;
    var id = _ref.id,
      localId = _ref.localId,
      producerId = _ref.producerId,
      rtpReceiver = _ref.rtpReceiver,
      track = _ref.track,
      rtpParameters = _ref.rtpParameters,
      appData = _ref.appData;
    _classCallCheck(this, Consumer);
    _this = _callSuper(this, Consumer);
    // Id.
    _defineProperty(_this, "_id", void 0);
    // Local id.
    _defineProperty(_this, "_localId", void 0);
    // Associated Producer id.
    _defineProperty(_this, "_producerId", void 0);
    // Closed flag.
    _defineProperty(_this, "_closed", false);
    // Associated RTCRtpReceiver.
    _defineProperty(_this, "_rtpReceiver", void 0);
    // Remote track.
    _defineProperty(_this, "_track", void 0);
    // RTP parameters.
    _defineProperty(_this, "_rtpParameters", void 0);
    // Paused flag.
    _defineProperty(_this, "_paused", void 0);
    // App custom data.
    _defineProperty(_this, "_appData", void 0);
    // Observer instance.
    _defineProperty(_this, "_observer", new enhancedEvents_1.EnhancedEventEmitter());
    logger.debug('constructor()');
    _this._id = id;
    _this._localId = localId;
    _this._producerId = producerId;
    _this._rtpReceiver = rtpReceiver;
    _this._track = track;
    _this._rtpParameters = rtpParameters;
    _this._paused = !track.enabled;
    _this._appData = appData !== null && appData !== void 0 ? appData : {};
    _this.onTrackEnded = _this.onTrackEnded.bind(_this);
    _this.handleTrack();
    return _this;
  }
  /**
   * Consumer id.
   */
  _inherits(Consumer, _enhancedEvents_1$Enh);
  return _createClass(Consumer, [{
    key: "id",
    get: function get() {
      return this._id;
    }
    /**
     * Local id.
     */
  }, {
    key: "localId",
    get: function get() {
      return this._localId;
    }
    /**
     * Associated Producer id.
     */
  }, {
    key: "producerId",
    get: function get() {
      return this._producerId;
    }
    /**
     * Whether the Consumer is closed.
     */
  }, {
    key: "closed",
    get: function get() {
      return this._closed;
    }
    /**
     * Media kind.
     */
  }, {
    key: "kind",
    get: function get() {
      return this._track.kind;
    }
    /**
     * Associated RTCRtpReceiver.
     */
  }, {
    key: "rtpReceiver",
    get: function get() {
      return this._rtpReceiver;
    }
    /**
     * The associated track.
     */
  }, {
    key: "track",
    get: function get() {
      return this._track;
    }
    /**
     * RTP parameters.
     */
  }, {
    key: "rtpParameters",
    get: function get() {
      return this._rtpParameters;
    }
    /**
     * Whether the Consumer is paused.
     */
  }, {
    key: "paused",
    get: function get() {
      return this._paused;
    }
    /**
     * App custom data.
     */
  }, {
    key: "appData",
    get: function get() {
      return this._appData;
    }
    /**
     * App custom data setter.
     */,
    set: function set(appData) {
      this._appData = appData;
    }
  }, {
    key: "observer",
    get: function get() {
      return this._observer;
    }
    /**
     * Closes the Consumer.
     */
  }, {
    key: "close",
    value: function close() {
      if (this._closed) {
        return;
      }
      logger.debug('close()');
      this._closed = true;
      this.destroyTrack();
      this.emit('@close');
      // Emit observer event.
      this._observer.safeEmit('close');
    }
    /**
     * Transport was closed.
     */
  }, {
    key: "transportClosed",
    value: function transportClosed() {
      if (this._closed) {
        return;
      }
      logger.debug('transportClosed()');
      this._closed = true;
      this.destroyTrack();
      this.safeEmit('transportclose');
      // Emit observer event.
      this._observer.safeEmit('close');
    }
    /**
     * Get associated RTCRtpReceiver stats.
     */
  }, {
    key: "getStats",
    value: (function () {
      var _getStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {
        var _this2 = this;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              if (!this._closed) {
                _context.n = 1;
                break;
              }
              throw new errors_1.InvalidStateError('closed');
            case 1:
              return _context.a(2, new Promise(function (resolve, reject) {
                _this2.safeEmit('@getstats', resolve, reject);
              }));
          }
        }, _callee, this);
      }));
      function getStats() {
        return _getStats.apply(this, arguments);
      }
      return getStats;
    }()
    /**
     * Pauses receiving media.
     */
    )
  }, {
    key: "pause",
    value: function pause() {
      logger.debug('pause()');
      if (this._closed) {
        logger.error('pause() | Consumer closed');
        return;
      }
      if (this._paused) {
        logger.debug('pause() | Consumer is already paused');
        return;
      }
      this._paused = true;
      this._track.enabled = false;
      this.emit('@pause');
      // Emit observer event.
      this._observer.safeEmit('pause');
    }
    /**
     * Resumes receiving media.
     */
  }, {
    key: "resume",
    value: function resume() {
      logger.debug('resume()');
      if (this._closed) {
        logger.error('resume() | Consumer closed');
        return;
      }
      if (!this._paused) {
        logger.debug('resume() | Consumer is already resumed');
        return;
      }
      this._paused = false;
      this._track.enabled = true;
      this.emit('@resume');
      // Emit observer event.
      this._observer.safeEmit('resume');
    }
  }, {
    key: "onTrackEnded",
    value: function onTrackEnded() {
      logger.debug('track "ended" event');
      this.safeEmit('trackended');
      // Emit observer event.
      this._observer.safeEmit('trackended');
    }
  }, {
    key: "handleTrack",
    value: function handleTrack() {
      this._track.addEventListener('ended', this.onTrackEnded);
    }
  }, {
    key: "destroyTrack",
    value: function destroyTrack() {
      try {
        this._track.removeEventListener('ended', this.onTrackEnded);
        this._track.stop();
      } catch (error) {}
    }
  }]);
}(enhancedEvents_1.EnhancedEventEmitter);
exports.Consumer = Consumer;

},{"./Logger":39,"./enhancedEvents":44,"./errors":45}],36:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DataConsumer = void 0;
var Logger_1 = require("./Logger");
var enhancedEvents_1 = require("./enhancedEvents");
var logger = new Logger_1.Logger('DataConsumer');
var DataConsumer = /*#__PURE__*/function (_enhancedEvents_1$Enh) {
  function DataConsumer(_ref) {
    var _this;
    var id = _ref.id,
      dataProducerId = _ref.dataProducerId,
      dataChannel = _ref.dataChannel,
      sctpStreamParameters = _ref.sctpStreamParameters,
      appData = _ref.appData;
    _classCallCheck(this, DataConsumer);
    _this = _callSuper(this, DataConsumer);
    // Id.
    _defineProperty(_this, "_id", void 0);
    // Associated DataProducer Id.
    _defineProperty(_this, "_dataProducerId", void 0);
    // The underlying RTCDataChannel instance.
    _defineProperty(_this, "_dataChannel", void 0);
    // Closed flag.
    _defineProperty(_this, "_closed", false);
    // SCTP stream parameters.
    _defineProperty(_this, "_sctpStreamParameters", void 0);
    // App custom data.
    _defineProperty(_this, "_appData", void 0);
    // Observer instance.
    _defineProperty(_this, "_observer", new enhancedEvents_1.EnhancedEventEmitter());
    logger.debug('constructor()');
    _this._id = id;
    _this._dataProducerId = dataProducerId;
    _this._dataChannel = dataChannel;
    _this._sctpStreamParameters = sctpStreamParameters;
    _this._appData = appData !== null && appData !== void 0 ? appData : {};
    _this.handleDataChannel();
    return _this;
  }
  /**
   * DataConsumer id.
   */
  _inherits(DataConsumer, _enhancedEvents_1$Enh);
  return _createClass(DataConsumer, [{
    key: "id",
    get: function get() {
      return this._id;
    }
    /**
     * Associated DataProducer id.
     */
  }, {
    key: "dataProducerId",
    get: function get() {
      return this._dataProducerId;
    }
    /**
     * Whether the DataConsumer is closed.
     */
  }, {
    key: "closed",
    get: function get() {
      return this._closed;
    }
    /**
     * SCTP stream parameters.
     */
  }, {
    key: "sctpStreamParameters",
    get: function get() {
      return this._sctpStreamParameters;
    }
    /**
     * DataChannel readyState.
     */
  }, {
    key: "readyState",
    get: function get() {
      return this._dataChannel.readyState;
    }
    /**
     * DataChannel label.
     */
  }, {
    key: "label",
    get: function get() {
      return this._dataChannel.label;
    }
    /**
     * DataChannel protocol.
     */
  }, {
    key: "protocol",
    get: function get() {
      return this._dataChannel.protocol;
    }
    /**
     * DataChannel binaryType.
     */
  }, {
    key: "binaryType",
    get: function get() {
      return this._dataChannel.binaryType;
    }
    /**
     * Set DataChannel binaryType.
     */,
    set: function set(binaryType) {
      this._dataChannel.binaryType = binaryType;
    }
    /**
     * App custom data.
     */
  }, {
    key: "appData",
    get: function get() {
      return this._appData;
    }
    /**
     * App custom data setter.
     */,
    set: function set(appData) {
      this._appData = appData;
    }
  }, {
    key: "observer",
    get: function get() {
      return this._observer;
    }
    /**
     * Closes the DataConsumer.
     */
  }, {
    key: "close",
    value: function close() {
      if (this._closed) {
        return;
      }
      logger.debug('close()');
      this._closed = true;
      this._dataChannel.close();
      this.emit('@close');
      // Emit observer event.
      this._observer.safeEmit('close');
    }
    /**
     * Transport was closed.
     */
  }, {
    key: "transportClosed",
    value: function transportClosed() {
      if (this._closed) {
        return;
      }
      logger.debug('transportClosed()');
      this._closed = true;
      this._dataChannel.close();
      this.safeEmit('transportclose');
      // Emit observer event.
      this._observer.safeEmit('close');
    }
  }, {
    key: "handleDataChannel",
    value: function handleDataChannel() {
      var _this2 = this;
      this._dataChannel.addEventListener('open', function () {
        if (_this2._closed) {
          return;
        }
        logger.debug('DataChannel "open" event');
        _this2.safeEmit('open');
      });
      this._dataChannel.addEventListener('error', function (event) {
        if (_this2._closed) {
          return;
        }
        var error = event.error;
        if (!error) {
          error = new Error('unknown DataChannel error');
        }
        if (error.errorDetail === 'sctp-failure') {
          logger.error('DataChannel SCTP error [sctpCauseCode:%s]: %s', error.sctpCauseCode, error.message);
        } else {
          logger.error('DataChannel "error" event: %o', error);
        }
        _this2.safeEmit('error', error);
      });
      this._dataChannel.addEventListener('close', function () {
        if (_this2._closed) {
          return;
        }
        logger.warn('DataChannel "close" event');
        _this2._closed = true;
        _this2.emit('@close');
        _this2.safeEmit('close');
        // Emit observer event.
        _this2._observer.safeEmit('close');
      });
      this._dataChannel.addEventListener('message', function (event) {
        if (_this2._closed) {
          return;
        }
        _this2.safeEmit('message', event.data);
      });
    }
  }]);
}(enhancedEvents_1.EnhancedEventEmitter);
exports.DataConsumer = DataConsumer;

},{"./Logger":39,"./enhancedEvents":44}],37:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DataProducer = void 0;
var Logger_1 = require("./Logger");
var enhancedEvents_1 = require("./enhancedEvents");
var errors_1 = require("./errors");
var logger = new Logger_1.Logger('DataProducer');
var DataProducer = /*#__PURE__*/function (_enhancedEvents_1$Enh) {
  function DataProducer(_ref) {
    var _this;
    var id = _ref.id,
      dataChannel = _ref.dataChannel,
      sctpStreamParameters = _ref.sctpStreamParameters,
      appData = _ref.appData;
    _classCallCheck(this, DataProducer);
    _this = _callSuper(this, DataProducer);
    // Id.
    _defineProperty(_this, "_id", void 0);
    // The underlying RTCDataChannel instance.
    _defineProperty(_this, "_dataChannel", void 0);
    // Closed flag.
    _defineProperty(_this, "_closed", false);
    // SCTP stream parameters.
    _defineProperty(_this, "_sctpStreamParameters", void 0);
    // App custom data.
    _defineProperty(_this, "_appData", void 0);
    // Observer instance.
    _defineProperty(_this, "_observer", new enhancedEvents_1.EnhancedEventEmitter());
    logger.debug('constructor()');
    _this._id = id;
    _this._dataChannel = dataChannel;
    _this._sctpStreamParameters = sctpStreamParameters;
    _this._appData = appData !== null && appData !== void 0 ? appData : {};
    _this.handleDataChannel();
    return _this;
  }
  /**
   * DataProducer id.
   */
  _inherits(DataProducer, _enhancedEvents_1$Enh);
  return _createClass(DataProducer, [{
    key: "id",
    get: function get() {
      return this._id;
    }
    /**
     * Whether the DataProducer is closed.
     */
  }, {
    key: "closed",
    get: function get() {
      return this._closed;
    }
    /**
     * SCTP stream parameters.
     */
  }, {
    key: "sctpStreamParameters",
    get: function get() {
      return this._sctpStreamParameters;
    }
    /**
     * DataChannel readyState.
     */
  }, {
    key: "readyState",
    get: function get() {
      return this._dataChannel.readyState;
    }
    /**
     * DataChannel label.
     */
  }, {
    key: "label",
    get: function get() {
      return this._dataChannel.label;
    }
    /**
     * DataChannel protocol.
     */
  }, {
    key: "protocol",
    get: function get() {
      return this._dataChannel.protocol;
    }
    /**
     * DataChannel bufferedAmount.
     */
  }, {
    key: "bufferedAmount",
    get: function get() {
      return this._dataChannel.bufferedAmount;
    }
    /**
     * DataChannel bufferedAmountLowThreshold.
     */
  }, {
    key: "bufferedAmountLowThreshold",
    get: function get() {
      return this._dataChannel.bufferedAmountLowThreshold;
    }
    /**
     * Set DataChannel bufferedAmountLowThreshold.
     */,
    set: function set(bufferedAmountLowThreshold) {
      this._dataChannel.bufferedAmountLowThreshold = bufferedAmountLowThreshold;
    }
    /**
     * App custom data.
     */
  }, {
    key: "appData",
    get: function get() {
      return this._appData;
    }
    /**
     * App custom data setter.
     */,
    set: function set(appData) {
      this._appData = appData;
    }
  }, {
    key: "observer",
    get: function get() {
      return this._observer;
    }
    /**
     * Closes the DataProducer.
     */
  }, {
    key: "close",
    value: function close() {
      if (this._closed) {
        return;
      }
      logger.debug('close()');
      this._closed = true;
      this._dataChannel.close();
      this.emit('@close');
      // Emit observer event.
      this._observer.safeEmit('close');
    }
    /**
     * Transport was closed.
     */
  }, {
    key: "transportClosed",
    value: function transportClosed() {
      if (this._closed) {
        return;
      }
      logger.debug('transportClosed()');
      this._closed = true;
      this._dataChannel.close();
      this.safeEmit('transportclose');
      // Emit observer event.
      this._observer.safeEmit('close');
    }
    /**
     * Send a message.
     *
     * @param {String|Blob|ArrayBuffer|ArrayBufferView} data.
     */
  }, {
    key: "send",
    value: function send(data) {
      logger.debug('send()');
      if (this._closed) {
        throw new errors_1.InvalidStateError('closed');
      }
      this._dataChannel.send(data);
    }
  }, {
    key: "handleDataChannel",
    value: function handleDataChannel() {
      var _this2 = this;
      this._dataChannel.addEventListener('open', function () {
        if (_this2._closed) {
          return;
        }
        logger.debug('DataChannel "open" event');
        _this2.safeEmit('open');
      });
      this._dataChannel.addEventListener('error', function (event) {
        if (_this2._closed) {
          return;
        }
        var error = event.error;
        if (!error) {
          error = new Error('unknown DataChannel error');
        }
        if (error.errorDetail === 'sctp-failure') {
          logger.error('DataChannel SCTP error [sctpCauseCode:%s]: %s', error.sctpCauseCode, error.message);
        } else {
          logger.error('DataChannel "error" event: %o', error);
        }
        _this2.safeEmit('error', error);
      });
      this._dataChannel.addEventListener('close', function () {
        if (_this2._closed) {
          return;
        }
        logger.warn('DataChannel "close" event');
        _this2._closed = true;
        _this2.emit('@close');
        _this2.safeEmit('close');
        // Emit observer event.
        _this2._observer.safeEmit('close');
      });
      this._dataChannel.addEventListener('message', function () {
        if (_this2._closed) {
          return;
        }
        logger.warn('DataChannel "message" event in a DataProducer, message discarded');
      });
      this._dataChannel.addEventListener('bufferedamountlow', function () {
        if (_this2._closed) {
          return;
        }
        _this2.safeEmit('bufferedamountlow');
      });
    }
  }]);
}(enhancedEvents_1.EnhancedEventEmitter);
exports.DataProducer = DataProducer;

},{"./Logger":39,"./enhancedEvents":44,"./errors":45}],38:[function(require,module,exports){
"use strict";

function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o("next", 0), o("throw", 1), o("return", 2); } }, _regeneratorDefine2(e, r, n, t); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Device = void 0;
exports.detectDeviceAsync = detectDeviceAsync;
exports.detectDevice = detectDevice;
var ua_parser_js_1 = require("ua-parser-js");
var Logger_1 = require("./Logger");
var enhancedEvents_1 = require("./enhancedEvents");
var errors_1 = require("./errors");
var utils = require("./utils");
var ortc = require("./ortc");
var Transport_1 = require("./Transport");
var Chrome111_1 = require("./handlers/Chrome111");
var Chrome74_1 = require("./handlers/Chrome74");
var Chrome70_1 = require("./handlers/Chrome70");
var Chrome67_1 = require("./handlers/Chrome67");
var Chrome55_1 = require("./handlers/Chrome55");
var Firefox120_1 = require("./handlers/Firefox120");
var Firefox60_1 = require("./handlers/Firefox60");
var Safari12_1 = require("./handlers/Safari12");
var Safari11_1 = require("./handlers/Safari11");
var Edge11_1 = require("./handlers/Edge11");
var ReactNativeUnifiedPlan_1 = require("./handlers/ReactNativeUnifiedPlan");
var ReactNative_1 = require("./handlers/ReactNative");
var logger = new Logger_1.Logger('Device');
/**
 * Async mediasoup-client Handler detection. More powerful than
 * `detectDevice()`.
 */
function detectDeviceAsync(_x) {
  return _detectDeviceAsync.apply(this, arguments);
}
/**
 * Sync mediasoup-client Handler detection.
 *
 * @deprecated It only relies on navigator.userAgent. Use `detectDeviceAsync()`
 * instead.
 */
function _detectDeviceAsync() {
  _detectDeviceAsync = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(userAgent) {
    var uaParserResult;
    return _regenerator().w(function (_context3) {
      while (1) switch (_context3.n) {
        case 0:
          logger.debug('detectDeviceAsync() [userAgent:%s]', userAgent);
          if (!userAgent && (typeof navigator === "undefined" ? "undefined" : _typeof(navigator)) === 'object') {
            userAgent = navigator.userAgent;
          }
          _context3.n = 1;
          return (0, ua_parser_js_1.UAParser)(userAgent).withFeatureCheck();
        case 1:
          uaParserResult = _context3.v;
          return _context3.a(2, detectDeviceImpl(uaParserResult));
      }
    }, _callee3);
  }));
  return _detectDeviceAsync.apply(this, arguments);
}
function detectDevice(userAgent) {
  logger.debug('detectDevice() [userAgent:%s]', userAgent);
  if (!userAgent && (typeof navigator === "undefined" ? "undefined" : _typeof(navigator)) === 'object') {
    userAgent = navigator.userAgent;
  }
  var uaParserResult = (0, ua_parser_js_1.UAParser)(userAgent);
  return detectDeviceImpl(uaParserResult);
}
var Device = /*#__PURE__*/function () {
  /**
   * Create a new Device to connect to mediasoup server.
   *
   * @throws {UnsupportedError} if device is not supported.
   */
  function Device() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      handlerName = _ref.handlerName,
      handlerFactory = _ref.handlerFactory;
    _classCallCheck(this, Device);
    // RTC handler factory.
    _defineProperty(this, "_handlerFactory", void 0);
    // Handler name.
    _defineProperty(this, "_handlerName", void 0);
    // Loaded flag.
    _defineProperty(this, "_loaded", false);
    // Extended RTP capabilities.
    _defineProperty(this, "_extendedRtpCapabilities", void 0);
    // Local RTP capabilities for receiving media.
    _defineProperty(this, "_recvRtpCapabilities", void 0);
    // Whether we can produce audio/video based on computed extended RTP
    // capabilities.
    _defineProperty(this, "_canProduceByKind", void 0);
    // Local SCTP capabilities.
    _defineProperty(this, "_sctpCapabilities", void 0);
    // Observer instance.
    _defineProperty(this, "_observer", new enhancedEvents_1.EnhancedEventEmitter());
    logger.debug('constructor()');
    if (handlerName && handlerFactory) {
      throw new TypeError('just one of handlerName or handlerInterface can be given');
    }
    if (handlerFactory) {
      this._handlerFactory = handlerFactory;
    } else {
      if (handlerName) {
        logger.debug('constructor() | handler given: %s', handlerName);
      } else {
        handlerName = detectDevice();
        if (handlerName) {
          logger.debug('constructor() | detected handler: %s', handlerName);
        } else {
          throw new errors_1.UnsupportedError('device not supported');
        }
      }
      switch (handlerName) {
        case 'Chrome111':
          {
            this._handlerFactory = Chrome111_1.Chrome111.createFactory();
            break;
          }
        case 'Chrome74':
          {
            this._handlerFactory = Chrome74_1.Chrome74.createFactory();
            break;
          }
        case 'Chrome70':
          {
            this._handlerFactory = Chrome70_1.Chrome70.createFactory();
            break;
          }
        case 'Chrome67':
          {
            this._handlerFactory = Chrome67_1.Chrome67.createFactory();
            break;
          }
        case 'Chrome55':
          {
            this._handlerFactory = Chrome55_1.Chrome55.createFactory();
            break;
          }
        case 'Firefox120':
          {
            this._handlerFactory = Firefox120_1.Firefox120.createFactory();
            break;
          }
        case 'Firefox60':
          {
            this._handlerFactory = Firefox60_1.Firefox60.createFactory();
            break;
          }
        case 'Safari12':
          {
            this._handlerFactory = Safari12_1.Safari12.createFactory();
            break;
          }
        case 'Safari11':
          {
            this._handlerFactory = Safari11_1.Safari11.createFactory();
            break;
          }
        case 'Edge11':
          {
            this._handlerFactory = Edge11_1.Edge11.createFactory();
            break;
          }
        case 'ReactNativeUnifiedPlan':
          {
            this._handlerFactory = ReactNativeUnifiedPlan_1.ReactNativeUnifiedPlan.createFactory();
            break;
          }
        case 'ReactNative':
          {
            this._handlerFactory = ReactNative_1.ReactNative.createFactory();
            break;
          }
        default:
          {
            throw new TypeError("unknown handlerName \"".concat(handlerName, "\""));
          }
      }
    }
    // Create a temporal handler to get its name.
    var handler = this._handlerFactory();
    this._handlerName = handler.name;
    handler.close();
    this._extendedRtpCapabilities = undefined;
    this._recvRtpCapabilities = undefined;
    this._canProduceByKind = {
      audio: false,
      video: false
    };
    this._sctpCapabilities = undefined;
  }
  /**
   * The RTC handler name.
   */
  return _createClass(Device, [{
    key: "handlerName",
    get: function get() {
      return this._handlerName;
    }
    /**
     * Whether the Device is loaded.
     */
  }, {
    key: "loaded",
    get: function get() {
      return this._loaded;
    }
    /**
     * RTP capabilities of the Device for receiving media.
     *
     * @throws {InvalidStateError} if not loaded.
     */
  }, {
    key: "rtpCapabilities",
    get: function get() {
      if (!this._loaded) {
        throw new errors_1.InvalidStateError('not loaded');
      }
      return this._recvRtpCapabilities;
    }
    /**
     * SCTP capabilities of the Device.
     *
     * @throws {InvalidStateError} if not loaded.
     */
  }, {
    key: "sctpCapabilities",
    get: function get() {
      if (!this._loaded) {
        throw new errors_1.InvalidStateError('not loaded');
      }
      return this._sctpCapabilities;
    }
  }, {
    key: "observer",
    get: function get() {
      return this._observer;
    }
    /**
     * Initialize the Device.
     */
  }, {
    key: "load",
    value: (function () {
      var _load = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(_ref2) {
        var routerRtpCapabilities, _ref2$preferLocalCode, preferLocalCodecsOrder, handler, clonedRouterRtpCapabilities, nativeRtpCapabilities, clonedNativeRtpCapabilities, _t;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              routerRtpCapabilities = _ref2.routerRtpCapabilities, _ref2$preferLocalCode = _ref2.preferLocalCodecsOrder, preferLocalCodecsOrder = _ref2$preferLocalCode === void 0 ? false : _ref2$preferLocalCode;
              logger.debug('load() [routerRtpCapabilities:%o]', routerRtpCapabilities);
              // Temporal handler to get its capabilities.
              _context.p = 1;
              if (!this._loaded) {
                _context.n = 2;
                break;
              }
              throw new errors_1.InvalidStateError('already loaded');
            case 2:
              // Clone given router RTP capabilities to not modify input data.
              clonedRouterRtpCapabilities = utils.clone(routerRtpCapabilities); // This may throw.
              ortc.validateRtpCapabilities(clonedRouterRtpCapabilities);
              handler = this._handlerFactory();
              _context.n = 3;
              return handler.getNativeRtpCapabilities();
            case 3:
              nativeRtpCapabilities = _context.v;
              logger.debug('load() | got native RTP capabilities:%o', nativeRtpCapabilities);
              // Clone obtained native RTP capabilities to not modify input data.
              clonedNativeRtpCapabilities = utils.clone(nativeRtpCapabilities); // This may throw.
              ortc.validateRtpCapabilities(clonedNativeRtpCapabilities);
              // Get extended RTP capabilities.
              this._extendedRtpCapabilities = ortc.getExtendedRtpCapabilities(clonedNativeRtpCapabilities, clonedRouterRtpCapabilities, preferLocalCodecsOrder);
              logger.debug('load() | got extended RTP capabilities:%o', this._extendedRtpCapabilities);
              // Check whether we can produce audio/video.
              this._canProduceByKind.audio = ortc.canSend('audio', this._extendedRtpCapabilities);
              this._canProduceByKind.video = ortc.canSend('video', this._extendedRtpCapabilities);
              // Generate our receiving RTP capabilities for receiving media.
              this._recvRtpCapabilities = ortc.getRecvRtpCapabilities(this._extendedRtpCapabilities);
              // This may throw.
              ortc.validateRtpCapabilities(this._recvRtpCapabilities);
              logger.debug('load() | got receiving RTP capabilities:%o', this._recvRtpCapabilities);
              // Generate our SCTP capabilities.
              _context.n = 4;
              return handler.getNativeSctpCapabilities();
            case 4:
              this._sctpCapabilities = _context.v;
              logger.debug('load() | got native SCTP capabilities:%o', this._sctpCapabilities);
              // This may throw.
              ortc.validateSctpCapabilities(this._sctpCapabilities);
              logger.debug('load() succeeded');
              this._loaded = true;
              handler.close();
              _context.n = 6;
              break;
            case 5:
              _context.p = 5;
              _t = _context.v;
              if (handler) {
                handler.close();
              }
              throw _t;
            case 6:
              return _context.a(2);
          }
        }, _callee, this, [[1, 5]]);
      }));
      function load(_x2) {
        return _load.apply(this, arguments);
      }
      return load;
    }()
    /**
     * Whether we can produce audio/video.
     *
     * @throws {InvalidStateError} if not loaded.
     * @throws {TypeError} if wrong arguments.
     */
    )
  }, {
    key: "canProduce",
    value: function canProduce(kind) {
      if (!this._loaded) {
        throw new errors_1.InvalidStateError('not loaded');
      } else if (kind !== 'audio' && kind !== 'video') {
        throw new TypeError("invalid kind \"".concat(kind, "\""));
      }
      return this._canProduceByKind[kind];
    }
    /**
     * Creates a Transport for sending media.
     *
     * @throws {InvalidStateError} if not loaded.
     * @throws {TypeError} if wrong arguments.
     */
  }, {
    key: "createSendTransport",
    value: function createSendTransport(_ref3) {
      var id = _ref3.id,
        iceParameters = _ref3.iceParameters,
        iceCandidates = _ref3.iceCandidates,
        dtlsParameters = _ref3.dtlsParameters,
        sctpParameters = _ref3.sctpParameters,
        iceServers = _ref3.iceServers,
        iceTransportPolicy = _ref3.iceTransportPolicy,
        additionalSettings = _ref3.additionalSettings,
        proprietaryConstraints = _ref3.proprietaryConstraints,
        appData = _ref3.appData;
      logger.debug('createSendTransport()');
      return this.createTransport({
        direction: 'send',
        id: id,
        iceParameters: iceParameters,
        iceCandidates: iceCandidates,
        dtlsParameters: dtlsParameters,
        sctpParameters: sctpParameters,
        iceServers: iceServers,
        iceTransportPolicy: iceTransportPolicy,
        additionalSettings: additionalSettings,
        proprietaryConstraints: proprietaryConstraints,
        appData: appData
      });
    }
    /**
     * Creates a Transport for receiving media.
     *
     * @throws {InvalidStateError} if not loaded.
     * @throws {TypeError} if wrong arguments.
     */
  }, {
    key: "createRecvTransport",
    value: function createRecvTransport(_ref4) {
      var id = _ref4.id,
        iceParameters = _ref4.iceParameters,
        iceCandidates = _ref4.iceCandidates,
        dtlsParameters = _ref4.dtlsParameters,
        sctpParameters = _ref4.sctpParameters,
        iceServers = _ref4.iceServers,
        iceTransportPolicy = _ref4.iceTransportPolicy,
        additionalSettings = _ref4.additionalSettings,
        proprietaryConstraints = _ref4.proprietaryConstraints,
        appData = _ref4.appData;
      logger.debug('createRecvTransport()');
      return this.createTransport({
        direction: 'recv',
        id: id,
        iceParameters: iceParameters,
        iceCandidates: iceCandidates,
        dtlsParameters: dtlsParameters,
        sctpParameters: sctpParameters,
        iceServers: iceServers,
        iceTransportPolicy: iceTransportPolicy,
        additionalSettings: additionalSettings,
        proprietaryConstraints: proprietaryConstraints,
        appData: appData
      });
    }
  }, {
    key: "createTransport",
    value: function createTransport(_ref5) {
      var direction = _ref5.direction,
        id = _ref5.id,
        iceParameters = _ref5.iceParameters,
        iceCandidates = _ref5.iceCandidates,
        dtlsParameters = _ref5.dtlsParameters,
        sctpParameters = _ref5.sctpParameters,
        iceServers = _ref5.iceServers,
        iceTransportPolicy = _ref5.iceTransportPolicy,
        additionalSettings = _ref5.additionalSettings,
        proprietaryConstraints = _ref5.proprietaryConstraints,
        appData = _ref5.appData;
      if (!this._loaded) {
        throw new errors_1.InvalidStateError('not loaded');
      } else if (typeof id !== 'string') {
        throw new TypeError('missing id');
      } else if (_typeof(iceParameters) !== 'object') {
        throw new TypeError('missing iceParameters');
      } else if (!Array.isArray(iceCandidates)) {
        throw new TypeError('missing iceCandidates');
      } else if (_typeof(dtlsParameters) !== 'object') {
        throw new TypeError('missing dtlsParameters');
      } else if (sctpParameters && _typeof(sctpParameters) !== 'object') {
        throw new TypeError('wrong sctpParameters');
      } else if (appData && _typeof(appData) !== 'object') {
        throw new TypeError('if given, appData must be an object');
      }
      // Create a new Transport.
      var transport = new Transport_1.Transport({
        direction: direction,
        id: id,
        iceParameters: iceParameters,
        iceCandidates: iceCandidates,
        dtlsParameters: dtlsParameters,
        sctpParameters: sctpParameters,
        iceServers: iceServers,
        iceTransportPolicy: iceTransportPolicy,
        additionalSettings: additionalSettings,
        proprietaryConstraints: proprietaryConstraints,
        appData: appData,
        handlerFactory: this._handlerFactory,
        extendedRtpCapabilities: this._extendedRtpCapabilities,
        canProduceByKind: this._canProduceByKind
      });
      // Emit observer event.
      this._observer.safeEmit('newtransport', transport);
      return transport;
    }
  }], [{
    key: "factory",
    value: (
    /**
     * Create a new Device to connect to mediasoup server. It uses a more advanced
     * device detection.
     *
     * @throws {UnsupportedError} if device is not supported.
     */
    function () {
      var _factory = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2() {
        var _ref6,
          handlerName,
          handlerFactory,
          _args2 = arguments;
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.n) {
            case 0:
              _ref6 = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {}, handlerName = _ref6.handlerName, handlerFactory = _ref6.handlerFactory;
              logger.debug('factory()');
              if (!(handlerName && handlerFactory)) {
                _context2.n = 1;
                break;
              }
              throw new TypeError('just one of handlerName or handlerInterface can be given');
            case 1:
              if (!(!handlerName && !handlerFactory)) {
                _context2.n = 3;
                break;
              }
              _context2.n = 2;
              return detectDeviceAsync();
            case 2:
              handlerName = _context2.v;
              if (handlerName) {
                _context2.n = 3;
                break;
              }
              throw new errors_1.UnsupportedError('device not supported');
            case 3:
              return _context2.a(2, new Device({
                handlerName: handlerName,
                handlerFactory: handlerFactory
              }));
          }
        }, _callee2);
      }));
      function factory() {
        return _factory.apply(this, arguments);
      }
      return factory;
    }())
  }]);
}();
exports.Device = Device;
function detectDeviceImpl(uaParserResult) {
  // React-Native.
  // NOTE: react-native-webrtc >= 1.75.0 is required.
  // NOTE: For Unified-Plan support, react-native-webrtc version >= 106.0.0 is
  // required.
  if ((typeof navigator === "undefined" ? "undefined" : _typeof(navigator)) === 'object' && navigator.product === 'ReactNative') {
    logger.debug('detectDeviceImpl() | React-Native detected');
    if (typeof RTCPeerConnection === 'undefined') {
      logger.warn('detectDeviceImpl() | unsupported react-native-webrtc without RTCPeerConnection, forgot to call registerGlobals()?');
      return undefined;
    }
    if (typeof RTCRtpTransceiver !== 'undefined') {
      logger.debug('detectDeviceImpl() | ReactNative UnifiedPlan handler chosen');
      return 'ReactNativeUnifiedPlan';
    } else {
      logger.debug('detectDeviceImpl() | ReactNative PlanB handler chosen');
      return 'ReactNative';
    }
  }
  // Browser.
  else {
    var _browser$name, _browser$major, _engine$name, _os$name, _os$version, _device$model;
    logger.debug('detectDeviceImpl() | browser detected [userAgent:%s, parsed:%o]', uaParserResult.ua, uaParserResult);
    var browser = uaParserResult.browser;
    var browserName = (_browser$name = browser.name) === null || _browser$name === void 0 ? void 0 : _browser$name.toLowerCase();
    var browserVersion = parseInt((_browser$major = browser.major) !== null && _browser$major !== void 0 ? _browser$major : '0');
    var engine = uaParserResult.engine;
    var engineName = (_engine$name = engine.name) === null || _engine$name === void 0 ? void 0 : _engine$name.toLowerCase();
    var os = uaParserResult.os;
    var osName = (_os$name = os.name) === null || _os$name === void 0 ? void 0 : _os$name.toLowerCase();
    var osVersion = parseFloat((_os$version = os.version) !== null && _os$version !== void 0 ? _os$version : '0');
    var device = uaParserResult.device;
    var deviceModel = (_device$model = device.model) === null || _device$model === void 0 ? void 0 : _device$model.toLowerCase();
    var isIOS = osName === 'ios' || deviceModel === 'ipad';
    var isChrome = browserName && ['chrome', 'chromium', 'mobile chrome', 'chrome webview', 'chrome headless'].includes(browserName);
    var isFirefox = browserName && ['firefox', 'mobile firefox', 'mobile focus'].includes(browserName);
    var isSafari = browserName && ['safari', 'mobile safari'].includes(browserName);
    var isEdge = browserName && ['edge'].includes(browserName);
    // Chrome, Chromium, and Edge.
    if ((isChrome || isEdge) && !isIOS && browserVersion >= 111) {
      return 'Chrome111';
    } else if (isChrome && !isIOS && browserVersion >= 74 || isEdge && !isIOS && browserVersion >= 88) {
      return 'Chrome74';
    } else if (isChrome && !isIOS && browserVersion >= 70) {
      return 'Chrome70';
    } else if (isChrome && !isIOS && browserVersion >= 67) {
      return 'Chrome67';
    } else if (isChrome && !isIOS && browserVersion >= 55) {
      return 'Chrome55';
    }
    // Firefox.
    else if (isFirefox && !isIOS && browserVersion >= 120) {
      return 'Firefox120';
    } else if (isFirefox && !isIOS && browserVersion >= 60) {
      return 'Firefox60';
    }
    // Firefox on iOS (so Safari).
    else if (isFirefox && isIOS && osVersion >= 14.3) {
      return 'Safari12';
    }
    // Safari with Unified-Plan support enabled.
    else if (isSafari && browserVersion >= 12 && typeof RTCRtpTransceiver !== 'undefined' && RTCRtpTransceiver.prototype.hasOwnProperty('currentDirection')) {
      return 'Safari12';
    }
    // Safari with Plab-B support.
    else if (isSafari && browserVersion >= 11) {
      return 'Safari11';
    }
    // Old Edge with ORTC support.
    else if (isEdge && !isIOS && browserVersion >= 11 && browserVersion <= 18) {
      return 'Edge11';
    }
    // Best effort for WebKit based browsers in iOS.
    else if (engineName === 'webkit' && isIOS && typeof RTCRtpTransceiver !== 'undefined' && RTCRtpTransceiver.prototype.hasOwnProperty('currentDirection')) {
      return 'Safari12';
    }
    // Best effort for Chromium based browsers.
    else if (engineName === 'blink') {
      // eslint-disable-next-line @typescript-eslint/prefer-regexp-exec
      var match = uaParserResult.ua.match(/(?:(?:Chrome|Chromium))[ /](\w+)/i);
      if (match) {
        var version = Number(match[1]);
        if (version >= 111) {
          return 'Chrome111';
        } else if (version >= 74) {
          return 'Chrome74';
        } else if (version >= 70) {
          return 'Chrome70';
        } else if (version >= 67) {
          return 'Chrome67';
        } else {
          return 'Chrome55';
        }
      } else {
        return 'Chrome111';
      }
    }
    // Unsupported browser.
    else {
      logger.warn('detectDeviceImpl() | browser not supported [name:%s, version:%s]', browserName, browserVersion);
      return undefined;
    }
  }
}

},{"./Logger":39,"./Transport":43,"./enhancedEvents":44,"./errors":45,"./handlers/Chrome111":46,"./handlers/Chrome55":47,"./handlers/Chrome67":48,"./handlers/Chrome70":49,"./handlers/Chrome74":50,"./handlers/Edge11":51,"./handlers/Firefox120":53,"./handlers/Firefox60":54,"./handlers/ReactNative":56,"./handlers/ReactNativeUnifiedPlan":57,"./handlers/Safari11":58,"./handlers/Safari12":59,"./ortc":68,"./utils":72,"ua-parser-js":92}],39:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Logger = void 0;
var debug_1 = require("debug");
var APP_NAME = 'mediasoup-client';
var Logger = /*#__PURE__*/function () {
  function Logger(prefix) {
    _classCallCheck(this, Logger);
    _defineProperty(this, "_debug", void 0);
    _defineProperty(this, "_warn", void 0);
    _defineProperty(this, "_error", void 0);
    if (prefix) {
      this._debug = (0, debug_1["default"])("".concat(APP_NAME, ":").concat(prefix));
      this._warn = (0, debug_1["default"])("".concat(APP_NAME, ":WARN:").concat(prefix));
      this._error = (0, debug_1["default"])("".concat(APP_NAME, ":ERROR:").concat(prefix));
    } else {
      this._debug = (0, debug_1["default"])(APP_NAME);
      this._warn = (0, debug_1["default"])("".concat(APP_NAME, ":WARN"));
      this._error = (0, debug_1["default"])("".concat(APP_NAME, ":ERROR"));
    }
    /* eslint-disable no-console */
    this._debug.log = console.info.bind(console);
    this._warn.log = console.warn.bind(console);
    this._error.log = console.error.bind(console);
    /* eslint-enable no-console */
  }
  return _createClass(Logger, [{
    key: "debug",
    get: function get() {
      return this._debug;
    }
  }, {
    key: "warn",
    get: function get() {
      return this._warn;
    }
  }, {
    key: "error",
    get: function get() {
      return this._error;
    }
  }]);
}();
exports.Logger = Logger;

},{"debug":6}],40:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o("next", 0), o("throw", 1), o("return", 2); } }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Producer = void 0;
var Logger_1 = require("./Logger");
var enhancedEvents_1 = require("./enhancedEvents");
var errors_1 = require("./errors");
var logger = new Logger_1.Logger('Producer');
var Producer = /*#__PURE__*/function (_enhancedEvents_1$Enh) {
  function Producer(_ref) {
    var _this;
    var id = _ref.id,
      localId = _ref.localId,
      rtpSender = _ref.rtpSender,
      track = _ref.track,
      rtpParameters = _ref.rtpParameters,
      stopTracks = _ref.stopTracks,
      disableTrackOnPause = _ref.disableTrackOnPause,
      zeroRtpOnPause = _ref.zeroRtpOnPause,
      appData = _ref.appData;
    _classCallCheck(this, Producer);
    _this = _callSuper(this, Producer);
    // Id.
    _defineProperty(_this, "_id", void 0);
    // Local id.
    _defineProperty(_this, "_localId", void 0);
    // Closed flag.
    _defineProperty(_this, "_closed", false);
    // Associated RTCRtpSender.
    _defineProperty(_this, "_rtpSender", void 0);
    // Local track.
    _defineProperty(_this, "_track", void 0);
    // Producer kind.
    _defineProperty(_this, "_kind", void 0);
    // RTP parameters.
    _defineProperty(_this, "_rtpParameters", void 0);
    // Paused flag.
    _defineProperty(_this, "_paused", void 0);
    // Video max spatial layer.
    _defineProperty(_this, "_maxSpatialLayer", void 0);
    // Whether the Producer should call stop() in given tracks.
    _defineProperty(_this, "_stopTracks", void 0);
    // Whether the Producer should set track.enabled = false when paused.
    _defineProperty(_this, "_disableTrackOnPause", void 0);
    // Whether we should replace the RTCRtpSender.track with null when paused.
    _defineProperty(_this, "_zeroRtpOnPause", void 0);
    // App custom data.
    _defineProperty(_this, "_appData", void 0);
    // Observer instance.
    _defineProperty(_this, "_observer", new enhancedEvents_1.EnhancedEventEmitter());
    logger.debug('constructor()');
    _this._id = id;
    _this._localId = localId;
    _this._rtpSender = rtpSender;
    _this._track = track;
    _this._kind = track.kind;
    _this._rtpParameters = rtpParameters;
    _this._paused = disableTrackOnPause ? !track.enabled : false;
    _this._maxSpatialLayer = undefined;
    _this._stopTracks = stopTracks;
    _this._disableTrackOnPause = disableTrackOnPause;
    _this._zeroRtpOnPause = zeroRtpOnPause;
    _this._appData = appData !== null && appData !== void 0 ? appData : {};
    _this.onTrackEnded = _this.onTrackEnded.bind(_this);
    // NOTE: Minor issue. If zeroRtpOnPause is true, we cannot emit the
    // '@replacetrack' event here, so RTCRtpSender.track won't be null.
    _this.handleTrack();
    return _this;
  }
  /**
   * Producer id.
   */
  _inherits(Producer, _enhancedEvents_1$Enh);
  return _createClass(Producer, [{
    key: "id",
    get: function get() {
      return this._id;
    }
    /**
     * Local id.
     */
  }, {
    key: "localId",
    get: function get() {
      return this._localId;
    }
    /**
     * Whether the Producer is closed.
     */
  }, {
    key: "closed",
    get: function get() {
      return this._closed;
    }
    /**
     * Media kind.
     */
  }, {
    key: "kind",
    get: function get() {
      return this._kind;
    }
    /**
     * Associated RTCRtpSender.
     */
  }, {
    key: "rtpSender",
    get: function get() {
      return this._rtpSender;
    }
    /**
     * The associated track.
     */
  }, {
    key: "track",
    get: function get() {
      return this._track;
    }
    /**
     * RTP parameters.
     */
  }, {
    key: "rtpParameters",
    get: function get() {
      return this._rtpParameters;
    }
    /**
     * Whether the Producer is paused.
     */
  }, {
    key: "paused",
    get: function get() {
      return this._paused;
    }
    /**
     * Max spatial layer.
     *
     * @type {Number | undefined}
     */
  }, {
    key: "maxSpatialLayer",
    get: function get() {
      return this._maxSpatialLayer;
    }
    /**
     * App custom data.
     */
  }, {
    key: "appData",
    get: function get() {
      return this._appData;
    }
    /**
     * App custom data setter.
     */,
    set: function set(appData) {
      this._appData = appData;
    }
  }, {
    key: "observer",
    get: function get() {
      return this._observer;
    }
    /**
     * Closes the Producer.
     */
  }, {
    key: "close",
    value: function close() {
      if (this._closed) {
        return;
      }
      logger.debug('close()');
      this._closed = true;
      this.destroyTrack();
      this.emit('@close');
      // Emit observer event.
      this._observer.safeEmit('close');
    }
    /**
     * Transport was closed.
     */
  }, {
    key: "transportClosed",
    value: function transportClosed() {
      if (this._closed) {
        return;
      }
      logger.debug('transportClosed()');
      this._closed = true;
      this.destroyTrack();
      this.safeEmit('transportclose');
      // Emit observer event.
      this._observer.safeEmit('close');
    }
    /**
     * Get associated RTCRtpSender stats.
     */
  }, {
    key: "getStats",
    value: (function () {
      var _getStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {
        var _this2 = this;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              if (!this._closed) {
                _context.n = 1;
                break;
              }
              throw new errors_1.InvalidStateError('closed');
            case 1:
              return _context.a(2, new Promise(function (resolve, reject) {
                _this2.safeEmit('@getstats', resolve, reject);
              }));
          }
        }, _callee, this);
      }));
      function getStats() {
        return _getStats.apply(this, arguments);
      }
      return getStats;
    }()
    /**
     * Pauses sending media.
     */
    )
  }, {
    key: "pause",
    value: function pause() {
      var _this3 = this;
      logger.debug('pause()');
      if (this._closed) {
        logger.error('pause() | Producer closed');
        return;
      }
      this._paused = true;
      if (this._track && this._disableTrackOnPause) {
        this._track.enabled = false;
      }
      if (this._zeroRtpOnPause) {
        new Promise(function (resolve, reject) {
          _this3.safeEmit('@pause', resolve, reject);
        })["catch"](function () {});
      }
      // Emit observer event.
      this._observer.safeEmit('pause');
    }
    /**
     * Resumes sending media.
     */
  }, {
    key: "resume",
    value: function resume() {
      var _this4 = this;
      logger.debug('resume()');
      if (this._closed) {
        logger.error('resume() | Producer closed');
        return;
      }
      this._paused = false;
      if (this._track && this._disableTrackOnPause) {
        this._track.enabled = true;
      }
      if (this._zeroRtpOnPause) {
        new Promise(function (resolve, reject) {
          _this4.safeEmit('@resume', resolve, reject);
        })["catch"](function () {});
      }
      // Emit observer event.
      this._observer.safeEmit('resume');
    }
    /**
     * Replaces the current track with a new one or null.
     */
  }, {
    key: "replaceTrack",
    value: (function () {
      var _replaceTrack = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(_ref2) {
        var _this5 = this;
        var track;
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.n) {
            case 0:
              track = _ref2.track;
              logger.debug('replaceTrack() [track:%o]', track);
              if (!this._closed) {
                _context2.n = 1;
                break;
              }
              // This must be done here. Otherwise there is no chance to stop the given
              // track.
              if (track && this._stopTracks) {
                try {
                  track.stop();
                } catch (error) {}
              }
              throw new errors_1.InvalidStateError('closed');
            case 1:
              if (!(track && track.readyState === 'ended')) {
                _context2.n = 2;
                break;
              }
              throw new errors_1.InvalidStateError('track ended');
            case 2:
              if (!(track === this._track)) {
                _context2.n = 3;
                break;
              }
              logger.debug('replaceTrack() | same track, ignored');
              return _context2.a(2);
            case 3:
              _context2.n = 4;
              return new Promise(function (resolve, reject) {
                _this5.safeEmit('@replacetrack', track, resolve, reject);
              });
            case 4:
              // Destroy the previous track.
              this.destroyTrack();
              // Set the new track.
              this._track = track;
              // If this Producer was paused/resumed and the state of the new
              // track does not match, fix it.
              if (this._track && this._disableTrackOnPause) {
                if (!this._paused) {
                  this._track.enabled = true;
                } else if (this._paused) {
                  this._track.enabled = false;
                }
              }
              // Handle the effective track.
              this.handleTrack();
            case 5:
              return _context2.a(2);
          }
        }, _callee2, this);
      }));
      function replaceTrack(_x) {
        return _replaceTrack.apply(this, arguments);
      }
      return replaceTrack;
    }()
    /**
     * Sets the video max spatial layer to be sent.
     */
    )
  }, {
    key: "setMaxSpatialLayer",
    value: (function () {
      var _setMaxSpatialLayer = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(spatialLayer) {
        var _this6 = this;
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.n) {
            case 0:
              if (!this._closed) {
                _context3.n = 1;
                break;
              }
              throw new errors_1.InvalidStateError('closed');
            case 1:
              if (!(this._kind !== 'video')) {
                _context3.n = 2;
                break;
              }
              throw new errors_1.UnsupportedError('not a video Producer');
            case 2:
              if (!(typeof spatialLayer !== 'number')) {
                _context3.n = 3;
                break;
              }
              throw new TypeError('invalid spatialLayer');
            case 3:
              if (!(spatialLayer === this._maxSpatialLayer)) {
                _context3.n = 4;
                break;
              }
              return _context3.a(2);
            case 4:
              _context3.n = 5;
              return new Promise(function (resolve, reject) {
                _this6.safeEmit('@setmaxspatiallayer', spatialLayer, resolve, reject);
              })["catch"](function () {});
            case 5:
              this._maxSpatialLayer = spatialLayer;
            case 6:
              return _context3.a(2);
          }
        }, _callee3, this);
      }));
      function setMaxSpatialLayer(_x2) {
        return _setMaxSpatialLayer.apply(this, arguments);
      }
      return setMaxSpatialLayer;
    }())
  }, {
    key: "setRtpEncodingParameters",
    value: function () {
      var _setRtpEncodingParameters = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(params) {
        var _this7 = this;
        return _regenerator().w(function (_context4) {
          while (1) switch (_context4.n) {
            case 0:
              if (!this._closed) {
                _context4.n = 1;
                break;
              }
              throw new errors_1.InvalidStateError('closed');
            case 1:
              if (!(_typeof(params) !== 'object')) {
                _context4.n = 2;
                break;
              }
              throw new TypeError('invalid params');
            case 2:
              _context4.n = 3;
              return new Promise(function (resolve, reject) {
                _this7.safeEmit('@setrtpencodingparameters', params, resolve, reject);
              });
            case 3:
              return _context4.a(2);
          }
        }, _callee4, this);
      }));
      function setRtpEncodingParameters(_x3) {
        return _setRtpEncodingParameters.apply(this, arguments);
      }
      return setRtpEncodingParameters;
    }()
  }, {
    key: "onTrackEnded",
    value: function onTrackEnded() {
      logger.debug('track "ended" event');
      this.safeEmit('trackended');
      // Emit observer event.
      this._observer.safeEmit('trackended');
    }
  }, {
    key: "handleTrack",
    value: function handleTrack() {
      if (!this._track) {
        return;
      }
      this._track.addEventListener('ended', this.onTrackEnded);
    }
  }, {
    key: "destroyTrack",
    value: function destroyTrack() {
      if (!this._track) {
        return;
      }
      try {
        this._track.removeEventListener('ended', this.onTrackEnded);
        // Just stop the track unless the app set stopTracks: false.
        if (this._stopTracks) {
          this._track.stop();
        }
      } catch (error) {}
    }
  }]);
}(enhancedEvents_1.EnhancedEventEmitter);
exports.Producer = Producer;

},{"./Logger":39,"./enhancedEvents":44,"./errors":45}],41:[function(require,module,exports){
"use strict";

/**
 * The RTP capabilities define what mediasoup or an endpoint can receive at
 * media level.
 */
Object.defineProperty(exports, "__esModule", {
  value: true
});

},{}],42:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

},{}],43:[function(require,module,exports){
"use strict";

function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o("next", 0), o("throw", 1), o("return", 2); } }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Transport = void 0;
var awaitqueue_1 = require("awaitqueue");
var Logger_1 = require("./Logger");
var enhancedEvents_1 = require("./enhancedEvents");
var errors_1 = require("./errors");
var utils = require("./utils");
var ortc = require("./ortc");
var Producer_1 = require("./Producer");
var Consumer_1 = require("./Consumer");
var DataProducer_1 = require("./DataProducer");
var DataConsumer_1 = require("./DataConsumer");
var logger = new Logger_1.Logger('Transport');
var ConsumerCreationTask = /*#__PURE__*/_createClass(function ConsumerCreationTask(consumerOptions) {
  var _this = this;
  _classCallCheck(this, ConsumerCreationTask);
  _defineProperty(this, "consumerOptions", void 0);
  _defineProperty(this, "promise", void 0);
  _defineProperty(this, "resolve", void 0);
  _defineProperty(this, "reject", void 0);
  this.consumerOptions = consumerOptions;
  this.promise = new Promise(function (resolve, reject) {
    _this.resolve = resolve;
    _this.reject = reject;
  });
});
var Transport = /*#__PURE__*/function (_enhancedEvents_1$Enh) {
  function Transport(_ref) {
    var _utils$clone;
    var _this2;
    var direction = _ref.direction,
      id = _ref.id,
      iceParameters = _ref.iceParameters,
      iceCandidates = _ref.iceCandidates,
      dtlsParameters = _ref.dtlsParameters,
      sctpParameters = _ref.sctpParameters,
      iceServers = _ref.iceServers,
      iceTransportPolicy = _ref.iceTransportPolicy,
      additionalSettings = _ref.additionalSettings,
      proprietaryConstraints = _ref.proprietaryConstraints,
      appData = _ref.appData,
      handlerFactory = _ref.handlerFactory,
      extendedRtpCapabilities = _ref.extendedRtpCapabilities,
      canProduceByKind = _ref.canProduceByKind;
    _classCallCheck(this, Transport);
    _this2 = _callSuper(this, Transport);
    // Id.
    _defineProperty(_this2, "_id", void 0);
    // Closed flag.
    _defineProperty(_this2, "_closed", false);
    // Direction.
    _defineProperty(_this2, "_direction", void 0);
    // Extended RTP capabilities.
    _defineProperty(_this2, "_extendedRtpCapabilities", void 0);
    // Whether we can produce audio/video based on computed extended RTP
    // capabilities.
    _defineProperty(_this2, "_canProduceByKind", void 0);
    // SCTP max message size if enabled, null otherwise.
    _defineProperty(_this2, "_maxSctpMessageSize", void 0);
    // RTC handler isntance.
    _defineProperty(_this2, "_handler", void 0);
    // Transport ICE gathering state.
    _defineProperty(_this2, "_iceGatheringState", 'new');
    // Transport connection state.
    _defineProperty(_this2, "_connectionState", 'new');
    // App custom data.
    _defineProperty(_this2, "_appData", void 0);
    // Map of Producers indexed by id.
    _defineProperty(_this2, "_producers", new Map());
    // Map of Consumers indexed by id.
    _defineProperty(_this2, "_consumers", new Map());
    // Map of DataProducers indexed by id.
    _defineProperty(_this2, "_dataProducers", new Map());
    // Map of DataConsumers indexed by id.
    _defineProperty(_this2, "_dataConsumers", new Map());
    // Whether the Consumer for RTP probation has been created.
    _defineProperty(_this2, "_probatorConsumerCreated", false);
    // AwaitQueue instance to make async tasks happen sequentially.
    _defineProperty(_this2, "_awaitQueue", new awaitqueue_1.AwaitQueue());
    // Consumer creation tasks awaiting to be processed.
    _defineProperty(_this2, "_pendingConsumerTasks", []);
    // Consumer creation in progress flag.
    _defineProperty(_this2, "_consumerCreationInProgress", false);
    // Consumers pending to be paused.
    _defineProperty(_this2, "_pendingPauseConsumers", new Map());
    // Consumer pause in progress flag.
    _defineProperty(_this2, "_consumerPauseInProgress", false);
    // Consumers pending to be resumed.
    _defineProperty(_this2, "_pendingResumeConsumers", new Map());
    // Consumer resume in progress flag.
    _defineProperty(_this2, "_consumerResumeInProgress", false);
    // Consumers pending to be closed.
    _defineProperty(_this2, "_pendingCloseConsumers", new Map());
    // Consumer close in progress flag.
    _defineProperty(_this2, "_consumerCloseInProgress", false);
    // Observer instance.
    _defineProperty(_this2, "_observer", new enhancedEvents_1.EnhancedEventEmitter());
    logger.debug('constructor() [id:%s, direction:%s]', id, direction);
    _this2._id = id;
    _this2._direction = direction;
    _this2._extendedRtpCapabilities = extendedRtpCapabilities;
    _this2._canProduceByKind = canProduceByKind;
    _this2._maxSctpMessageSize = sctpParameters ? sctpParameters.maxMessageSize : null;
    // Clone and sanitize additionalSettings.
    var clonedAdditionalSettings = (_utils$clone = utils.clone(additionalSettings)) !== null && _utils$clone !== void 0 ? _utils$clone : {};
    delete clonedAdditionalSettings.iceServers;
    delete clonedAdditionalSettings.iceTransportPolicy;
    delete clonedAdditionalSettings.bundlePolicy;
    delete clonedAdditionalSettings.rtcpMuxPolicy;
    delete clonedAdditionalSettings.sdpSemantics;
    _this2._handler = handlerFactory();
    _this2._handler.run({
      direction: direction,
      iceParameters: iceParameters,
      iceCandidates: iceCandidates,
      dtlsParameters: dtlsParameters,
      sctpParameters: sctpParameters,
      iceServers: iceServers,
      iceTransportPolicy: iceTransportPolicy,
      additionalSettings: clonedAdditionalSettings,
      proprietaryConstraints: proprietaryConstraints,
      extendedRtpCapabilities: extendedRtpCapabilities
    });
    _this2._appData = appData !== null && appData !== void 0 ? appData : {};
    _this2.handleHandler();
    return _this2;
  }
  /**
   * Transport id.
   */
  _inherits(Transport, _enhancedEvents_1$Enh);
  return _createClass(Transport, [{
    key: "id",
    get: function get() {
      return this._id;
    }
    /**
     * Whether the Transport is closed.
     */
  }, {
    key: "closed",
    get: function get() {
      return this._closed;
    }
    /**
     * Transport direction.
     */
  }, {
    key: "direction",
    get: function get() {
      return this._direction;
    }
    /**
     * RTC handler instance.
     */
  }, {
    key: "handler",
    get: function get() {
      return this._handler;
    }
    /**
     * ICE gathering state.
     */
  }, {
    key: "iceGatheringState",
    get: function get() {
      return this._iceGatheringState;
    }
    /**
     * Connection state.
     */
  }, {
    key: "connectionState",
    get: function get() {
      return this._connectionState;
    }
    /**
     * App custom data.
     */
  }, {
    key: "appData",
    get: function get() {
      return this._appData;
    }
    /**
     * App custom data setter.
     */,
    set: function set(appData) {
      this._appData = appData;
    }
  }, {
    key: "observer",
    get: function get() {
      return this._observer;
    }
    /**
     * Close the Transport.
     */
  }, {
    key: "close",
    value: function close() {
      if (this._closed) {
        return;
      }
      logger.debug('close()');
      this._closed = true;
      // Stop the AwaitQueue.
      this._awaitQueue.stop();
      // Close the handler.
      this._handler.close();
      // Change connection state to 'closed' since the handler may not emit
      // '@connectionstatechange' event.
      this._connectionState = 'closed';
      // Close all Producers.
      var _iterator = _createForOfIteratorHelper(this._producers.values()),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var producer = _step.value;
          producer.transportClosed();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      this._producers.clear();
      // Close all Consumers.
      var _iterator2 = _createForOfIteratorHelper(this._consumers.values()),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var consumer = _step2.value;
          consumer.transportClosed();
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      this._consumers.clear();
      // Close all DataProducers.
      var _iterator3 = _createForOfIteratorHelper(this._dataProducers.values()),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var dataProducer = _step3.value;
          dataProducer.transportClosed();
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      this._dataProducers.clear();
      // Close all DataConsumers.
      var _iterator4 = _createForOfIteratorHelper(this._dataConsumers.values()),
        _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var dataConsumer = _step4.value;
          dataConsumer.transportClosed();
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
      this._dataConsumers.clear();
      // Emit observer event.
      this._observer.safeEmit('close');
    }
    /**
     * Get associated Transport (RTCPeerConnection) stats.
     *
     * @returns {RTCStatsReport}
     */
  }, {
    key: "getStats",
    value: (function () {
      var _getStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {
        return _regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              if (!this._closed) {
                _context.n = 1;
                break;
              }
              throw new errors_1.InvalidStateError('closed');
            case 1:
              return _context.a(2, this._handler.getTransportStats());
          }
        }, _callee, this);
      }));
      function getStats() {
        return _getStats.apply(this, arguments);
      }
      return getStats;
    }()
    /**
     * Restart ICE connection.
     */
    )
  }, {
    key: "restartIce",
    value: (function () {
      var _restartIce = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(_ref2) {
        var _this3 = this;
        var iceParameters;
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.n) {
            case 0:
              iceParameters = _ref2.iceParameters;
              logger.debug('restartIce()');
              if (!this._closed) {
                _context3.n = 1;
                break;
              }
              throw new errors_1.InvalidStateError('closed');
            case 1:
              if (iceParameters) {
                _context3.n = 2;
                break;
              }
              throw new TypeError('missing iceParameters');
            case 2:
              return _context3.a(2, this._awaitQueue.push(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2() {
                return _regenerator().w(function (_context2) {
                  while (1) switch (_context2.n) {
                    case 0:
                      _context2.n = 1;
                      return _this3._handler.restartIce(iceParameters);
                    case 1:
                      return _context2.a(2, _context2.v);
                  }
                }, _callee2);
              })), 'transport.restartIce()'));
          }
        }, _callee3, this);
      }));
      function restartIce(_x) {
        return _restartIce.apply(this, arguments);
      }
      return restartIce;
    }()
    /**
     * Update ICE servers.
     */
    )
  }, {
    key: "updateIceServers",
    value: (function () {
      var _updateIceServers = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5() {
        var _this4 = this;
        var _ref4,
          iceServers,
          _args5 = arguments;
        return _regenerator().w(function (_context5) {
          while (1) switch (_context5.n) {
            case 0:
              _ref4 = _args5.length > 0 && _args5[0] !== undefined ? _args5[0] : {}, iceServers = _ref4.iceServers;
              logger.debug('updateIceServers()');
              if (!this._closed) {
                _context5.n = 1;
                break;
              }
              throw new errors_1.InvalidStateError('closed');
            case 1:
              if (Array.isArray(iceServers)) {
                _context5.n = 2;
                break;
              }
              throw new TypeError('missing iceServers');
            case 2:
              return _context5.a(2, this._awaitQueue.push(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4() {
                return _regenerator().w(function (_context4) {
                  while (1) switch (_context4.n) {
                    case 0:
                      return _context4.a(2, _this4._handler.updateIceServers(iceServers));
                  }
                }, _callee4);
              })), 'transport.updateIceServers()'));
          }
        }, _callee5, this);
      }));
      function updateIceServers() {
        return _updateIceServers.apply(this, arguments);
      }
      return updateIceServers;
    }()
    /**
     * Create a Producer.
     */
    )
  }, {
    key: "produce",
    value: (function () {
      var _produce = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7() {
        var _this5 = this;
        var _ref6,
          track,
          encodings,
          codecOptions,
          codec,
          _ref6$stopTracks,
          stopTracks,
          _ref6$disableTrackOnP,
          disableTrackOnPause,
          _ref6$zeroRtpOnPause,
          zeroRtpOnPause,
          onRtpSender,
          _ref6$appData,
          appData,
          _args7 = arguments;
        return _regenerator().w(function (_context7) {
          while (1) switch (_context7.n) {
            case 0:
              _ref6 = _args7.length > 0 && _args7[0] !== undefined ? _args7[0] : {}, track = _ref6.track, encodings = _ref6.encodings, codecOptions = _ref6.codecOptions, codec = _ref6.codec, _ref6$stopTracks = _ref6.stopTracks, stopTracks = _ref6$stopTracks === void 0 ? true : _ref6$stopTracks, _ref6$disableTrackOnP = _ref6.disableTrackOnPause, disableTrackOnPause = _ref6$disableTrackOnP === void 0 ? true : _ref6$disableTrackOnP, _ref6$zeroRtpOnPause = _ref6.zeroRtpOnPause, zeroRtpOnPause = _ref6$zeroRtpOnPause === void 0 ? false : _ref6$zeroRtpOnPause, onRtpSender = _ref6.onRtpSender, _ref6$appData = _ref6.appData, appData = _ref6$appData === void 0 ? {} : _ref6$appData;
              logger.debug('produce() [track:%o]', track);
              if (!this._closed) {
                _context7.n = 1;
                break;
              }
              throw new errors_1.InvalidStateError('closed');
            case 1:
              if (track) {
                _context7.n = 2;
                break;
              }
              throw new TypeError('missing track');
            case 2:
              if (!(this._direction !== 'send')) {
                _context7.n = 3;
                break;
              }
              throw new errors_1.UnsupportedError('not a sending Transport');
            case 3:
              if (this._canProduceByKind[track.kind]) {
                _context7.n = 4;
                break;
              }
              throw new errors_1.UnsupportedError("cannot produce ".concat(track.kind));
            case 4:
              if (!(track.readyState === 'ended')) {
                _context7.n = 5;
                break;
              }
              throw new errors_1.InvalidStateError('track ended');
            case 5:
              if (!(this.listenerCount('connect') === 0 && this._connectionState === 'new')) {
                _context7.n = 6;
                break;
              }
              throw new TypeError('no "connect" listener set into this transport');
            case 6:
              if (!(this.listenerCount('produce') === 0)) {
                _context7.n = 7;
                break;
              }
              throw new TypeError('no "produce" listener set into this transport');
            case 7:
              if (!(appData && _typeof(appData) !== 'object')) {
                _context7.n = 8;
                break;
              }
              throw new TypeError('if given, appData must be an object');
            case 8:
              return _context7.a(2, this._awaitQueue.push(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6() {
                var normalizedEncodings, _yield$_this5$_handle, localId, rtpParameters, rtpSender, _yield$Promise, id, producer, _t;
                return _regenerator().w(function (_context6) {
                  while (1) switch (_context6.n) {
                    case 0:
                      if (!(encodings && !Array.isArray(encodings))) {
                        _context6.n = 1;
                        break;
                      }
                      throw TypeError('encodings must be an array');
                    case 1:
                      if (encodings && encodings.length === 0) {
                        normalizedEncodings = undefined;
                      } else if (encodings) {
                        normalizedEncodings = encodings.map(function (encoding) {
                          var normalizedEncoding = {
                            active: true
                          };
                          if (encoding.active === false) {
                            normalizedEncoding.active = false;
                          }
                          if (typeof encoding.dtx === 'boolean') {
                            normalizedEncoding.dtx = encoding.dtx;
                          }
                          if (typeof encoding.scalabilityMode === 'string') {
                            normalizedEncoding.scalabilityMode = encoding.scalabilityMode;
                          }
                          if (typeof encoding.scaleResolutionDownBy === 'number') {
                            normalizedEncoding.scaleResolutionDownBy = encoding.scaleResolutionDownBy;
                          }
                          if (typeof encoding.maxBitrate === 'number') {
                            normalizedEncoding.maxBitrate = encoding.maxBitrate;
                          }
                          if (typeof encoding.maxFramerate === 'number') {
                            normalizedEncoding.maxFramerate = encoding.maxFramerate;
                          }
                          if (typeof encoding.adaptivePtime === 'boolean') {
                            normalizedEncoding.adaptivePtime = encoding.adaptivePtime;
                          }
                          if (typeof encoding.priority === 'string') {
                            normalizedEncoding.priority = encoding.priority;
                          }
                          if (typeof encoding.networkPriority === 'string') {
                            normalizedEncoding.networkPriority = encoding.networkPriority;
                          }
                          return normalizedEncoding;
                        });
                      }
                    case 2:
                      _context6.n = 3;
                      return _this5._handler.send({
                        track: track,
                        encodings: normalizedEncodings,
                        codecOptions: codecOptions,
                        codec: codec,
                        onRtpSender: onRtpSender
                      });
                    case 3:
                      _yield$_this5$_handle = _context6.v;
                      localId = _yield$_this5$_handle.localId;
                      rtpParameters = _yield$_this5$_handle.rtpParameters;
                      rtpSender = _yield$_this5$_handle.rtpSender;
                      _context6.p = 4;
                      // This will fill rtpParameters's missing fields with default values.
                      ortc.validateRtpParameters(rtpParameters);
                      _context6.n = 5;
                      return new Promise(function (resolve, reject) {
                        _this5.safeEmit('produce', {
                          kind: track.kind,
                          rtpParameters: rtpParameters,
                          appData: appData
                        }, resolve, reject);
                      });
                    case 5:
                      _yield$Promise = _context6.v;
                      id = _yield$Promise.id;
                      producer = new Producer_1.Producer({
                        id: id,
                        localId: localId,
                        rtpSender: rtpSender,
                        track: track,
                        rtpParameters: rtpParameters,
                        stopTracks: stopTracks,
                        disableTrackOnPause: disableTrackOnPause,
                        zeroRtpOnPause: zeroRtpOnPause,
                        appData: appData
                      });
                      _this5._producers.set(producer.id, producer);
                      _this5.handleProducer(producer);
                      // Emit observer event.
                      _this5._observer.safeEmit('newproducer', producer);
                      return _context6.a(2, producer);
                    case 6:
                      _context6.p = 6;
                      _t = _context6.v;
                      _this5._handler.stopSending(localId)["catch"](function () {});
                      throw _t;
                    case 7:
                      return _context6.a(2);
                  }
                }, _callee6, null, [[4, 6]]);
              })), 'transport.produce()')
              // This catch is needed to stop the given track if the command above
              // failed due to closed Transport.
              ["catch"](function (error) {
                if (stopTracks) {
                  try {
                    track.stop();
                  } catch (error2) {}
                }
                throw error;
              }));
          }
        }, _callee7, this);
      }));
      function produce() {
        return _produce.apply(this, arguments);
      }
      return produce;
    }()
    /**
     * Create a Consumer to consume a remote Producer.
     */
    )
  }, {
    key: "consume",
    value: (function () {
      var _consume = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8(_ref8) {
        var _this6 = this;
        var id, producerId, kind, rtpParameters, streamId, onRtpReceiver, _ref8$appData, appData, clonedRtpParameters, canConsume, consumerCreationTask;
        return _regenerator().w(function (_context8) {
          while (1) switch (_context8.n) {
            case 0:
              id = _ref8.id, producerId = _ref8.producerId, kind = _ref8.kind, rtpParameters = _ref8.rtpParameters, streamId = _ref8.streamId, onRtpReceiver = _ref8.onRtpReceiver, _ref8$appData = _ref8.appData, appData = _ref8$appData === void 0 ? {} : _ref8$appData;
              logger.debug('consume()');
              if (!this._closed) {
                _context8.n = 1;
                break;
              }
              throw new errors_1.InvalidStateError('closed');
            case 1:
              if (!(this._direction !== 'recv')) {
                _context8.n = 2;
                break;
              }
              throw new errors_1.UnsupportedError('not a receiving Transport');
            case 2:
              if (!(typeof id !== 'string')) {
                _context8.n = 3;
                break;
              }
              throw new TypeError('missing id');
            case 3:
              if (!(typeof producerId !== 'string')) {
                _context8.n = 4;
                break;
              }
              throw new TypeError('missing producerId');
            case 4:
              if (!(kind !== 'audio' && kind !== 'video')) {
                _context8.n = 5;
                break;
              }
              throw new TypeError("invalid kind '".concat(kind, "'"));
            case 5:
              if (!(this.listenerCount('connect') === 0 && this._connectionState === 'new')) {
                _context8.n = 6;
                break;
              }
              throw new TypeError('no "connect" listener set into this transport');
            case 6:
              if (!(appData && _typeof(appData) !== 'object')) {
                _context8.n = 7;
                break;
              }
              throw new TypeError('if given, appData must be an object');
            case 7:
              // Clone given RTP parameters to not modify input data.
              clonedRtpParameters = utils.clone(rtpParameters); // Ensure the device can consume it.
              canConsume = ortc.canReceive(clonedRtpParameters, this._extendedRtpCapabilities);
              if (canConsume) {
                _context8.n = 8;
                break;
              }
              throw new errors_1.UnsupportedError('cannot consume this Producer');
            case 8:
              consumerCreationTask = new ConsumerCreationTask({
                id: id,
                producerId: producerId,
                kind: kind,
                rtpParameters: clonedRtpParameters,
                streamId: streamId,
                onRtpReceiver: onRtpReceiver,
                appData: appData
              }); // Store the Consumer creation task.
              this._pendingConsumerTasks.push(consumerCreationTask);
              // There is no Consumer creation in progress, create it now.
              queueMicrotask(function () {
                if (_this6._closed) {
                  return;
                }
                if (_this6._consumerCreationInProgress === false) {
                  _this6.createPendingConsumers();
                }
              });
              return _context8.a(2, consumerCreationTask.promise);
          }
        }, _callee8, this);
      }));
      function consume(_x2) {
        return _consume.apply(this, arguments);
      }
      return consume;
    }()
    /**
     * Create a DataProducer
     */
    )
  }, {
    key: "produceData",
    value: (function () {
      var _produceData = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee0() {
        var _this7 = this;
        var _ref9,
          _ref9$ordered,
          ordered,
          maxPacketLifeTime,
          maxRetransmits,
          _ref9$label,
          label,
          _ref9$protocol,
          protocol,
          _ref9$appData,
          appData,
          _args0 = arguments;
        return _regenerator().w(function (_context0) {
          while (1) switch (_context0.n) {
            case 0:
              _ref9 = _args0.length > 0 && _args0[0] !== undefined ? _args0[0] : {}, _ref9$ordered = _ref9.ordered, ordered = _ref9$ordered === void 0 ? true : _ref9$ordered, maxPacketLifeTime = _ref9.maxPacketLifeTime, maxRetransmits = _ref9.maxRetransmits, _ref9$label = _ref9.label, label = _ref9$label === void 0 ? '' : _ref9$label, _ref9$protocol = _ref9.protocol, protocol = _ref9$protocol === void 0 ? '' : _ref9$protocol, _ref9$appData = _ref9.appData, appData = _ref9$appData === void 0 ? {} : _ref9$appData;
              logger.debug('produceData()');
              if (!this._closed) {
                _context0.n = 1;
                break;
              }
              throw new errors_1.InvalidStateError('closed');
            case 1:
              if (!(this._direction !== 'send')) {
                _context0.n = 2;
                break;
              }
              throw new errors_1.UnsupportedError('not a sending Transport');
            case 2:
              if (this._maxSctpMessageSize) {
                _context0.n = 3;
                break;
              }
              throw new errors_1.UnsupportedError('SCTP not enabled by remote Transport');
            case 3:
              if (!(this.listenerCount('connect') === 0 && this._connectionState === 'new')) {
                _context0.n = 4;
                break;
              }
              throw new TypeError('no "connect" listener set into this transport');
            case 4:
              if (!(this.listenerCount('producedata') === 0)) {
                _context0.n = 5;
                break;
              }
              throw new TypeError('no "producedata" listener set into this transport');
            case 5:
              if (!(appData && _typeof(appData) !== 'object')) {
                _context0.n = 6;
                break;
              }
              throw new TypeError('if given, appData must be an object');
            case 6:
              if (maxPacketLifeTime || maxRetransmits) {
                ordered = false;
              }
              // Enqueue command.
              return _context0.a(2, this._awaitQueue.push(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee9() {
                var _yield$_this7$_handle, dataChannel, sctpStreamParameters, _yield$Promise2, id, dataProducer;
                return _regenerator().w(function (_context9) {
                  while (1) switch (_context9.n) {
                    case 0:
                      _context9.n = 1;
                      return _this7._handler.sendDataChannel({
                        ordered: ordered,
                        maxPacketLifeTime: maxPacketLifeTime,
                        maxRetransmits: maxRetransmits,
                        label: label,
                        protocol: protocol
                      });
                    case 1:
                      _yield$_this7$_handle = _context9.v;
                      dataChannel = _yield$_this7$_handle.dataChannel;
                      sctpStreamParameters = _yield$_this7$_handle.sctpStreamParameters;
                      // This will fill sctpStreamParameters's missing fields with default values.
                      ortc.validateSctpStreamParameters(sctpStreamParameters);
                      _context9.n = 2;
                      return new Promise(function (resolve, reject) {
                        _this7.safeEmit('producedata', {
                          sctpStreamParameters: sctpStreamParameters,
                          label: label,
                          protocol: protocol,
                          appData: appData
                        }, resolve, reject);
                      });
                    case 2:
                      _yield$Promise2 = _context9.v;
                      id = _yield$Promise2.id;
                      dataProducer = new DataProducer_1.DataProducer({
                        id: id,
                        dataChannel: dataChannel,
                        sctpStreamParameters: sctpStreamParameters,
                        appData: appData
                      });
                      _this7._dataProducers.set(dataProducer.id, dataProducer);
                      _this7.handleDataProducer(dataProducer);
                      // Emit observer event.
                      _this7._observer.safeEmit('newdataproducer', dataProducer);
                      return _context9.a(2, dataProducer);
                  }
                }, _callee9);
              })), 'transport.produceData()'));
          }
        }, _callee0, this);
      }));
      function produceData() {
        return _produceData.apply(this, arguments);
      }
      return produceData;
    }()
    /**
     * Create a DataConsumer
     */
    )
  }, {
    key: "consumeData",
    value: (function () {
      var _consumeData = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee10(_ref1) {
        var _this8 = this;
        var id, dataProducerId, sctpStreamParameters, _ref1$label, label, _ref1$protocol, protocol, _ref1$appData, appData, clonedSctpStreamParameters;
        return _regenerator().w(function (_context10) {
          while (1) switch (_context10.n) {
            case 0:
              id = _ref1.id, dataProducerId = _ref1.dataProducerId, sctpStreamParameters = _ref1.sctpStreamParameters, _ref1$label = _ref1.label, label = _ref1$label === void 0 ? '' : _ref1$label, _ref1$protocol = _ref1.protocol, protocol = _ref1$protocol === void 0 ? '' : _ref1$protocol, _ref1$appData = _ref1.appData, appData = _ref1$appData === void 0 ? {} : _ref1$appData;
              logger.debug('consumeData()');
              if (!this._closed) {
                _context10.n = 1;
                break;
              }
              throw new errors_1.InvalidStateError('closed');
            case 1:
              if (!(this._direction !== 'recv')) {
                _context10.n = 2;
                break;
              }
              throw new errors_1.UnsupportedError('not a receiving Transport');
            case 2:
              if (this._maxSctpMessageSize) {
                _context10.n = 3;
                break;
              }
              throw new errors_1.UnsupportedError('SCTP not enabled by remote Transport');
            case 3:
              if (!(typeof id !== 'string')) {
                _context10.n = 4;
                break;
              }
              throw new TypeError('missing id');
            case 4:
              if (!(typeof dataProducerId !== 'string')) {
                _context10.n = 5;
                break;
              }
              throw new TypeError('missing dataProducerId');
            case 5:
              if (!(this.listenerCount('connect') === 0 && this._connectionState === 'new')) {
                _context10.n = 6;
                break;
              }
              throw new TypeError('no "connect" listener set into this transport');
            case 6:
              if (!(appData && _typeof(appData) !== 'object')) {
                _context10.n = 7;
                break;
              }
              throw new TypeError('if given, appData must be an object');
            case 7:
              // Clone given SCTP stream parameters to not modify input data.
              clonedSctpStreamParameters = utils.clone(sctpStreamParameters); // This may throw.
              ortc.validateSctpStreamParameters(clonedSctpStreamParameters);
              // Enqueue command.
              return _context10.a(2, this._awaitQueue.push(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee1() {
                var _yield$_this8$_handle, dataChannel, dataConsumer;
                return _regenerator().w(function (_context1) {
                  while (1) switch (_context1.n) {
                    case 0:
                      _context1.n = 1;
                      return _this8._handler.receiveDataChannel({
                        sctpStreamParameters: clonedSctpStreamParameters,
                        label: label,
                        protocol: protocol
                      });
                    case 1:
                      _yield$_this8$_handle = _context1.v;
                      dataChannel = _yield$_this8$_handle.dataChannel;
                      dataConsumer = new DataConsumer_1.DataConsumer({
                        id: id,
                        dataProducerId: dataProducerId,
                        dataChannel: dataChannel,
                        sctpStreamParameters: clonedSctpStreamParameters,
                        appData: appData
                      });
                      _this8._dataConsumers.set(dataConsumer.id, dataConsumer);
                      _this8.handleDataConsumer(dataConsumer);
                      // Emit observer event.
                      _this8._observer.safeEmit('newdataconsumer', dataConsumer);
                      return _context1.a(2, dataConsumer);
                  }
                }, _callee1);
              })), 'transport.consumeData()'));
          }
        }, _callee10, this);
      }));
      function consumeData(_x3) {
        return _consumeData.apply(this, arguments);
      }
      return consumeData;
    }() // This method is guaranteed to never throw.
    )
  }, {
    key: "createPendingConsumers",
    value: function createPendingConsumers() {
      var _this9 = this;
      this._consumerCreationInProgress = true;
      this._awaitQueue.push(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee11() {
        var pendingConsumerTasks, videoConsumerForProbator, optionsList, _iterator5, _step5, _task2, _task2$consumerOption, _id, _kind, _rtpParameters, streamId, onRtpReceiver, results, idx, task, result, _task$consumerOptions, id, producerId, kind, rtpParameters, appData, localId, rtpReceiver, track, consumer, _iterator6, _step6, _task, probatorRtpParameters, _t2, _t3;
        return _regenerator().w(function (_context11) {
          while (1) switch (_context11.n) {
            case 0:
              if (!(_this9._pendingConsumerTasks.length === 0)) {
                _context11.n = 1;
                break;
              }
              logger.debug('createPendingConsumers() | there is no Consumer to be created');
              return _context11.a(2);
            case 1:
              pendingConsumerTasks = _toConsumableArray(_this9._pendingConsumerTasks); // Clear pending Consumer tasks.
              _this9._pendingConsumerTasks = [];
              // Video Consumer in order to create the probator.
              videoConsumerForProbator = undefined; // Fill options list.
              optionsList = [];
              _iterator5 = _createForOfIteratorHelper(pendingConsumerTasks);
              try {
                for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                  _task2 = _step5.value;
                  _task2$consumerOption = _task2.consumerOptions, _id = _task2$consumerOption.id, _kind = _task2$consumerOption.kind, _rtpParameters = _task2$consumerOption.rtpParameters, streamId = _task2$consumerOption.streamId, onRtpReceiver = _task2$consumerOption.onRtpReceiver;
                  optionsList.push({
                    trackId: _id,
                    kind: _kind,
                    rtpParameters: _rtpParameters,
                    streamId: streamId,
                    onRtpReceiver: onRtpReceiver
                  });
                }
              } catch (err) {
                _iterator5.e(err);
              } finally {
                _iterator5.f();
              }
              _context11.p = 2;
              _context11.n = 3;
              return _this9._handler.receive(optionsList);
            case 3:
              results = _context11.v;
              for (idx = 0; idx < results.length; ++idx) {
                task = pendingConsumerTasks[idx];
                result = results[idx];
                _task$consumerOptions = task.consumerOptions, id = _task$consumerOptions.id, producerId = _task$consumerOptions.producerId, kind = _task$consumerOptions.kind, rtpParameters = _task$consumerOptions.rtpParameters, appData = _task$consumerOptions.appData;
                localId = result.localId, rtpReceiver = result.rtpReceiver, track = result.track;
                consumer = new Consumer_1.Consumer({
                  id: id,
                  localId: localId,
                  producerId: producerId,
                  rtpReceiver: rtpReceiver,
                  track: track,
                  rtpParameters: rtpParameters,
                  appData: appData
                });
                _this9._consumers.set(consumer.id, consumer);
                _this9.handleConsumer(consumer);
                // If this is the first video Consumer and the Consumer for RTP probation
                // has not yet been created, it's time to create it.
                if (!_this9._probatorConsumerCreated && !videoConsumerForProbator && kind === 'video') {
                  videoConsumerForProbator = consumer;
                }
                // Emit observer event.
                _this9._observer.safeEmit('newconsumer', consumer);
                task.resolve(consumer);
              }
              _context11.n = 5;
              break;
            case 4:
              _context11.p = 4;
              _t2 = _context11.v;
              _iterator6 = _createForOfIteratorHelper(pendingConsumerTasks);
              try {
                for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                  _task = _step6.value;
                  _task.reject(_t2);
                }
              } catch (err) {
                _iterator6.e(err);
              } finally {
                _iterator6.f();
              }
            case 5:
              if (!videoConsumerForProbator) {
                _context11.n = 9;
                break;
              }
              _context11.p = 6;
              probatorRtpParameters = ortc.generateProbatorRtpParameters(videoConsumerForProbator.rtpParameters);
              _context11.n = 7;
              return _this9._handler.receive([{
                trackId: 'probator',
                kind: 'video',
                rtpParameters: probatorRtpParameters
              }]);
            case 7:
              logger.debug('createPendingConsumers() | Consumer for RTP probation created');
              _this9._probatorConsumerCreated = true;
              _context11.n = 9;
              break;
            case 8:
              _context11.p = 8;
              _t3 = _context11.v;
              logger.error('createPendingConsumers() | failed to create Consumer for RTP probation:%o', _t3);
            case 9:
              return _context11.a(2);
          }
        }, _callee11, null, [[6, 8], [2, 4]]);
      })), 'transport.createPendingConsumers()').then(function () {
        _this9._consumerCreationInProgress = false;
        // There are pending Consumer tasks, enqueue their creation.
        if (_this9._pendingConsumerTasks.length > 0) {
          _this9.createPendingConsumers();
        }
      })
      // NOTE: We only get here when the await queue is closed.
      ["catch"](function () {});
    }
  }, {
    key: "pausePendingConsumers",
    value: function pausePendingConsumers() {
      var _this0 = this;
      this._consumerPauseInProgress = true;
      this._awaitQueue.push(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee12() {
        var pendingPauseConsumers, localIds, _t4;
        return _regenerator().w(function (_context12) {
          while (1) switch (_context12.n) {
            case 0:
              if (!(_this0._pendingPauseConsumers.size === 0)) {
                _context12.n = 1;
                break;
              }
              logger.debug('pausePendingConsumers() | there is no Consumer to be paused');
              return _context12.a(2);
            case 1:
              pendingPauseConsumers = Array.from(_this0._pendingPauseConsumers.values()); // Clear pending pause Consumer map.
              _this0._pendingPauseConsumers.clear();
              _context12.p = 2;
              localIds = pendingPauseConsumers.map(function (consumer) {
                return consumer.localId;
              });
              _context12.n = 3;
              return _this0._handler.pauseReceiving(localIds);
            case 3:
              _context12.n = 5;
              break;
            case 4:
              _context12.p = 4;
              _t4 = _context12.v;
              logger.error('pausePendingConsumers() | failed to pause Consumers:', _t4);
            case 5:
              return _context12.a(2);
          }
        }, _callee12, null, [[2, 4]]);
      })), 'transport.pausePendingConsumers').then(function () {
        _this0._consumerPauseInProgress = false;
        // There are pending Consumers to be paused, do it.
        if (_this0._pendingPauseConsumers.size > 0) {
          _this0.pausePendingConsumers();
        }
      })
      // NOTE: We only get here when the await queue is closed.
      ["catch"](function () {});
    }
  }, {
    key: "resumePendingConsumers",
    value: function resumePendingConsumers() {
      var _this1 = this;
      this._consumerResumeInProgress = true;
      this._awaitQueue.push(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee13() {
        var pendingResumeConsumers, localIds, _t5;
        return _regenerator().w(function (_context13) {
          while (1) switch (_context13.n) {
            case 0:
              if (!(_this1._pendingResumeConsumers.size === 0)) {
                _context13.n = 1;
                break;
              }
              logger.debug('resumePendingConsumers() | there is no Consumer to be resumed');
              return _context13.a(2);
            case 1:
              pendingResumeConsumers = Array.from(_this1._pendingResumeConsumers.values()); // Clear pending resume Consumer map.
              _this1._pendingResumeConsumers.clear();
              _context13.p = 2;
              localIds = pendingResumeConsumers.map(function (consumer) {
                return consumer.localId;
              });
              _context13.n = 3;
              return _this1._handler.resumeReceiving(localIds);
            case 3:
              _context13.n = 5;
              break;
            case 4:
              _context13.p = 4;
              _t5 = _context13.v;
              logger.error('resumePendingConsumers() | failed to resume Consumers:', _t5);
            case 5:
              return _context13.a(2);
          }
        }, _callee13, null, [[2, 4]]);
      })), 'transport.resumePendingConsumers').then(function () {
        _this1._consumerResumeInProgress = false;
        // There are pending Consumer to be resumed, do it.
        if (_this1._pendingResumeConsumers.size > 0) {
          _this1.resumePendingConsumers();
        }
      })
      // NOTE: We only get here when the await queue is closed.
      ["catch"](function () {});
    }
  }, {
    key: "closePendingConsumers",
    value: function closePendingConsumers() {
      var _this10 = this;
      this._consumerCloseInProgress = true;
      this._awaitQueue.push(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee14() {
        var pendingCloseConsumers, _t6;
        return _regenerator().w(function (_context14) {
          while (1) switch (_context14.n) {
            case 0:
              if (!(_this10._pendingCloseConsumers.size === 0)) {
                _context14.n = 1;
                break;
              }
              logger.debug('closePendingConsumers() | there is no Consumer to be closed');
              return _context14.a(2);
            case 1:
              pendingCloseConsumers = Array.from(_this10._pendingCloseConsumers.values()); // Clear pending close Consumer map.
              _this10._pendingCloseConsumers.clear();
              _context14.p = 2;
              _context14.n = 3;
              return _this10._handler.stopReceiving(pendingCloseConsumers.map(function (consumer) {
                return consumer.localId;
              }));
            case 3:
              _context14.n = 5;
              break;
            case 4:
              _context14.p = 4;
              _t6 = _context14.v;
              logger.error('closePendingConsumers() | failed to close Consumers:', _t6);
            case 5:
              return _context14.a(2);
          }
        }, _callee14, null, [[2, 4]]);
      })), 'transport.closePendingConsumers').then(function () {
        _this10._consumerCloseInProgress = false;
        // There are pending Consumer to be resumed, do it.
        if (_this10._pendingCloseConsumers.size > 0) {
          _this10.closePendingConsumers();
        }
      })
      // NOTE: We only get here when the await queue is closed.
      ["catch"](function () {});
    }
  }, {
    key: "handleHandler",
    value: function handleHandler() {
      var _this11 = this;
      var handler = this._handler;
      handler.on('@connect', function (_ref15, callback, errback) {
        var dtlsParameters = _ref15.dtlsParameters;
        if (_this11._closed) {
          errback(new errors_1.InvalidStateError('closed'));
          return;
        }
        _this11.safeEmit('connect', {
          dtlsParameters: dtlsParameters
        }, callback, errback);
      });
      handler.on('@icegatheringstatechange', function (iceGatheringState) {
        if (iceGatheringState === _this11._iceGatheringState) {
          return;
        }
        logger.debug('ICE gathering state changed to %s', iceGatheringState);
        _this11._iceGatheringState = iceGatheringState;
        if (!_this11._closed) {
          _this11.safeEmit('icegatheringstatechange', iceGatheringState);
        }
      });
      handler.on('@icecandidateerror', function (event) {
        logger.warn("ICE candidate error [url:".concat(event.url, ", localAddress:").concat(event.address, ", localPort:").concat(event.port, "]: ").concat(event.errorCode, " \"").concat(event.errorText, "\""));
        _this11.safeEmit('icecandidateerror', event);
      });
      handler.on('@connectionstatechange', function (connectionState) {
        if (connectionState === _this11._connectionState) {
          return;
        }
        logger.debug('connection state changed to %s', connectionState);
        _this11._connectionState = connectionState;
        if (!_this11._closed) {
          _this11.safeEmit('connectionstatechange', connectionState);
        }
      });
    }
  }, {
    key: "handleProducer",
    value: function handleProducer(producer) {
      var _this12 = this;
      producer.on('@close', function () {
        _this12._producers["delete"](producer.id);
        if (_this12._closed) {
          return;
        }
        _this12._awaitQueue.push(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee15() {
          return _regenerator().w(function (_context15) {
            while (1) switch (_context15.n) {
              case 0:
                _context15.n = 1;
                return _this12._handler.stopSending(producer.localId);
              case 1:
                return _context15.a(2, _context15.v);
            }
          }, _callee15);
        })), 'producer @close event')["catch"](function (error) {
          return logger.warn('producer.close() failed:%o', error);
        });
      });
      producer.on('@pause', function (callback, errback) {
        _this12._awaitQueue.push(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee16() {
          return _regenerator().w(function (_context16) {
            while (1) switch (_context16.n) {
              case 0:
                _context16.n = 1;
                return _this12._handler.pauseSending(producer.localId);
              case 1:
                return _context16.a(2, _context16.v);
            }
          }, _callee16);
        })), 'producer @pause event').then(callback)["catch"](errback);
      });
      producer.on('@resume', function (callback, errback) {
        _this12._awaitQueue.push(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee17() {
          return _regenerator().w(function (_context17) {
            while (1) switch (_context17.n) {
              case 0:
                _context17.n = 1;
                return _this12._handler.resumeSending(producer.localId);
              case 1:
                return _context17.a(2, _context17.v);
            }
          }, _callee17);
        })), 'producer @resume event').then(callback)["catch"](errback);
      });
      producer.on('@replacetrack', function (track, callback, errback) {
        _this12._awaitQueue.push(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee18() {
          return _regenerator().w(function (_context18) {
            while (1) switch (_context18.n) {
              case 0:
                _context18.n = 1;
                return _this12._handler.replaceTrack(producer.localId, track);
              case 1:
                return _context18.a(2, _context18.v);
            }
          }, _callee18);
        })), 'producer @replacetrack event').then(callback)["catch"](errback);
      });
      producer.on('@setmaxspatiallayer', function (spatialLayer, callback, errback) {
        _this12._awaitQueue.push(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee19() {
          return _regenerator().w(function (_context19) {
            while (1) switch (_context19.n) {
              case 0:
                _context19.n = 1;
                return _this12._handler.setMaxSpatialLayer(producer.localId, spatialLayer);
              case 1:
                return _context19.a(2, _context19.v);
            }
          }, _callee19);
        })), 'producer @setmaxspatiallayer event').then(callback)["catch"](errback);
      });
      producer.on('@setrtpencodingparameters', function (params, callback, errback) {
        _this12._awaitQueue.push(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee20() {
          return _regenerator().w(function (_context20) {
            while (1) switch (_context20.n) {
              case 0:
                _context20.n = 1;
                return _this12._handler.setRtpEncodingParameters(producer.localId, params);
              case 1:
                return _context20.a(2, _context20.v);
            }
          }, _callee20);
        })), 'producer @setrtpencodingparameters event').then(callback)["catch"](errback);
      });
      producer.on('@getstats', function (callback, errback) {
        if (_this12._closed) {
          return errback(new errors_1.InvalidStateError('closed'));
        }
        _this12._handler.getSenderStats(producer.localId).then(callback)["catch"](errback);
      });
    }
  }, {
    key: "handleConsumer",
    value: function handleConsumer(consumer) {
      var _this13 = this;
      consumer.on('@close', function () {
        _this13._consumers["delete"](consumer.id);
        _this13._pendingPauseConsumers["delete"](consumer.id);
        _this13._pendingResumeConsumers["delete"](consumer.id);
        if (_this13._closed) {
          return;
        }
        // Store the Consumer into the close list.
        _this13._pendingCloseConsumers.set(consumer.id, consumer);
        // There is no Consumer close in progress, do it now.
        if (_this13._consumerCloseInProgress === false) {
          _this13.closePendingConsumers();
        }
      });
      consumer.on('@pause', function () {
        // If Consumer is pending to be resumed, remove from pending resume list.
        if (_this13._pendingResumeConsumers.has(consumer.id)) {
          _this13._pendingResumeConsumers["delete"](consumer.id);
        }
        // Store the Consumer into the pending list.
        _this13._pendingPauseConsumers.set(consumer.id, consumer);
        // There is no Consumer pause in progress, do it now.
        queueMicrotask(function () {
          if (_this13._closed) {
            return;
          }
          if (_this13._consumerPauseInProgress === false) {
            _this13.pausePendingConsumers();
          }
        });
      });
      consumer.on('@resume', function () {
        // If Consumer is pending to be paused, remove from pending pause list.
        if (_this13._pendingPauseConsumers.has(consumer.id)) {
          _this13._pendingPauseConsumers["delete"](consumer.id);
        }
        // Store the Consumer into the pending list.
        _this13._pendingResumeConsumers.set(consumer.id, consumer);
        // There is no Consumer resume in progress, do it now.
        queueMicrotask(function () {
          if (_this13._closed) {
            return;
          }
          if (_this13._consumerResumeInProgress === false) {
            _this13.resumePendingConsumers();
          }
        });
      });
      consumer.on('@getstats', function (callback, errback) {
        if (_this13._closed) {
          return errback(new errors_1.InvalidStateError('closed'));
        }
        _this13._handler.getReceiverStats(consumer.localId).then(callback)["catch"](errback);
      });
    }
  }, {
    key: "handleDataProducer",
    value: function handleDataProducer(dataProducer) {
      var _this14 = this;
      dataProducer.on('@close', function () {
        _this14._dataProducers["delete"](dataProducer.id);
      });
    }
  }, {
    key: "handleDataConsumer",
    value: function handleDataConsumer(dataConsumer) {
      var _this15 = this;
      dataConsumer.on('@close', function () {
        _this15._dataConsumers["delete"](dataConsumer.id);
      });
    }
  }]);
}(enhancedEvents_1.EnhancedEventEmitter);
exports.Transport = Transport;

},{"./Consumer":35,"./DataConsumer":36,"./DataProducer":37,"./Logger":39,"./Producer":40,"./enhancedEvents":44,"./errors":45,"./ortc":68,"./utils":72,"awaitqueue":5}],44:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EnhancedEventEmitter = void 0;
var events_alias_1 = require("events-alias");
var Logger_1 = require("./Logger");
var enhancedEventEmitterLogger = new Logger_1.Logger('EnhancedEventEmitter');
var EnhancedEventEmitter = /*#__PURE__*/function (_events_alias_1$Event) {
  function EnhancedEventEmitter() {
    var _this;
    _classCallCheck(this, EnhancedEventEmitter);
    _this = _callSuper(this, EnhancedEventEmitter);
    _this.setMaxListeners(Infinity);
    return _this;
  }
  _inherits(EnhancedEventEmitter, _events_alias_1$Event);
  return _createClass(EnhancedEventEmitter, [{
    key: "emit",
    value: function emit(eventName) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      return _superPropGet(EnhancedEventEmitter, "emit", this, 3)([eventName].concat(args));
    }
    /**
     * Special addition to the EventEmitter API.
     */
  }, {
    key: "safeEmit",
    value: function safeEmit(eventName) {
      try {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }
        return _superPropGet(EnhancedEventEmitter, "emit", this, 3)([eventName].concat(args));
      } catch (error) {
        enhancedEventEmitterLogger.error('safeEmit() | event listener threw an error [eventName:%s]:%o', eventName, error);
        try {
          _superPropGet(EnhancedEventEmitter, "emit", this, 3)(['listenererror', eventName, error]);
        } catch (error2) {
          // Ignore it.
        }
        return Boolean(_superPropGet(EnhancedEventEmitter, "listenerCount", this, 3)([eventName]));
      }
    }
  }, {
    key: "on",
    value: function on(eventName, listener) {
      _superPropGet(EnhancedEventEmitter, "on", this, 3)([eventName, listener]);
      return this;
    }
  }, {
    key: "off",
    value: function off(eventName, listener) {
      _superPropGet(EnhancedEventEmitter, "off", this, 3)([eventName, listener]);
      return this;
    }
  }, {
    key: "addListener",
    value: function addListener(eventName, listener) {
      _superPropGet(EnhancedEventEmitter, "on", this, 3)([eventName, listener]);
      return this;
    }
  }, {
    key: "prependListener",
    value: function prependListener(eventName, listener) {
      _superPropGet(EnhancedEventEmitter, "prependListener", this, 3)([eventName, listener]);
      return this;
    }
  }, {
    key: "once",
    value: function once(eventName, listener) {
      _superPropGet(EnhancedEventEmitter, "once", this, 3)([eventName, listener]);
      return this;
    }
  }, {
    key: "prependOnceListener",
    value: function prependOnceListener(eventName, listener) {
      _superPropGet(EnhancedEventEmitter, "prependOnceListener", this, 3)([eventName, listener]);
      return this;
    }
  }, {
    key: "removeListener",
    value: function removeListener(eventName, listener) {
      _superPropGet(EnhancedEventEmitter, "off", this, 3)([eventName, listener]);
      return this;
    }
  }, {
    key: "removeAllListeners",
    value: function removeAllListeners(eventName) {
      _superPropGet(EnhancedEventEmitter, "removeAllListeners", this, 3)([eventName]);
      return this;
    }
  }, {
    key: "listenerCount",
    value: function listenerCount(eventName) {
      return _superPropGet(EnhancedEventEmitter, "listenerCount", this, 3)([eventName]);
    }
  }, {
    key: "listeners",
    value: function listeners(eventName) {
      return _superPropGet(EnhancedEventEmitter, "listeners", this, 3)([eventName]);
    }
  }, {
    key: "rawListeners",
    value: function rawListeners(eventName) {
      return _superPropGet(EnhancedEventEmitter, "rawListeners", this, 3)([eventName]);
    }
  }]);
}(events_alias_1.EventEmitter);
exports.EnhancedEventEmitter = EnhancedEventEmitter;

},{"./Logger":39,"events-alias":29}],45:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _wrapNativeSuper(t) { var r = "function" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf("[native code]"); } catch (n) { return "function" == typeof t; } }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InvalidStateError = exports.UnsupportedError = void 0;
/**
 * Error indicating not support for something.
 */
var UnsupportedError = /*#__PURE__*/function (_Error) {
  function UnsupportedError(message) {
    var _this;
    _classCallCheck(this, UnsupportedError);
    _this = _callSuper(this, UnsupportedError, [message]);
    _this.name = 'UnsupportedError';
    if (Error.hasOwnProperty('captureStackTrace')) {
      Error.captureStackTrace(_this, UnsupportedError);
    } else {
      _this.stack = new Error(message).stack;
    }
    return _this;
  }
  _inherits(UnsupportedError, _Error);
  return _createClass(UnsupportedError);
}(/*#__PURE__*/_wrapNativeSuper(Error));
exports.UnsupportedError = UnsupportedError;
/**
 * Error produced when calling a method in an invalid state.
 */
var InvalidStateError = /*#__PURE__*/function (_Error2) {
  function InvalidStateError(message) {
    var _this2;
    _classCallCheck(this, InvalidStateError);
    _this2 = _callSuper(this, InvalidStateError, [message]);
    _this2.name = 'InvalidStateError';
    if (Error.hasOwnProperty('captureStackTrace')) {
      // Just in V8.
      Error.captureStackTrace(_this2, InvalidStateError);
    } else {
      _this2.stack = new Error(message).stack;
    }
    return _this2;
  }
  _inherits(InvalidStateError, _Error2);
  return _createClass(InvalidStateError);
}(/*#__PURE__*/_wrapNativeSuper(Error));
exports.InvalidStateError = InvalidStateError;

},{}],46:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorValues(e) { if (null != e) { var t = e["function" == typeof Symbol && Symbol.iterator || "@@iterator"], r = 0; if (t) return t.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) return { next: function next() { return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e }; } }; } throw new TypeError(_typeof(e) + " is not iterable"); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o("next", 0), o("throw", 1), o("return", 2); } }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Chrome111 = void 0;
var sdpTransform = require("sdp-transform");
var Logger_1 = require("../Logger");
var utils = require("../utils");
var ortc = require("../ortc");
var sdpCommonUtils = require("./sdp/commonUtils");
var sdpUnifiedPlanUtils = require("./sdp/unifiedPlanUtils");
var ortcUtils = require("./ortc/utils");
var errors_1 = require("../errors");
var HandlerInterface_1 = require("./HandlerInterface");
var RemoteSdp_1 = require("./sdp/RemoteSdp");
var scalabilityModes_1 = require("../scalabilityModes");
var logger = new Logger_1.Logger('Chrome111');
var NAME = 'Chrome111';
var SCTP_NUM_STREAMS = {
  OS: 1024,
  MIS: 1024
};
var Chrome111 = /*#__PURE__*/function (_HandlerInterface_1$H) {
  function Chrome111() {
    var _this;
    _classCallCheck(this, Chrome111);
    _this = _callSuper(this, Chrome111);
    // Closed flag.
    _defineProperty(_this, "_closed", false);
    // Handler direction.
    _defineProperty(_this, "_direction", void 0);
    // Remote SDP handler.
    _defineProperty(_this, "_remoteSdp", void 0);
    // Generic sending RTP parameters for audio and video.
    _defineProperty(_this, "_sendingRtpParametersByKind", void 0);
    // Generic sending RTP parameters for audio and video suitable for the SDP
    // remote answer.
    _defineProperty(_this, "_sendingRemoteRtpParametersByKind", void 0);
    // Initial server side DTLS role. If not 'auto', it will force the opposite
    // value in client side.
    _defineProperty(_this, "_forcedLocalDtlsRole", void 0);
    // RTCPeerConnection instance.
    _defineProperty(_this, "_pc", void 0);
    // Map of RTCTransceivers indexed by MID.
    _defineProperty(_this, "_mapMidTransceiver", new Map());
    // Local stream for sending.
    _defineProperty(_this, "_sendStream", new MediaStream());
    // Whether a DataChannel m=application section has been created.
    _defineProperty(_this, "_hasDataChannelMediaSection", false);
    // Sending DataChannel id value counter. Incremented for each new DataChannel.
    _defineProperty(_this, "_nextSendSctpStreamId", 0);
    // Got transport local and remote parameters.
    _defineProperty(_this, "_transportReady", false);
    return _this;
  }
  _inherits(Chrome111, _HandlerInterface_1$H);
  return _createClass(Chrome111, [{
    key: "name",
    get: function get() {
      return NAME;
    }
  }, {
    key: "close",
    value: function close() {
      logger.debug('close()');
      if (this._closed) {
        return;
      }
      this._closed = true;
      // Close RTCPeerConnection.
      if (this._pc) {
        try {
          this._pc.close();
        } catch (error) {}
      }
      this.emit('@close');
    }
  }, {
    key: "getNativeRtpCapabilities",
    value: function () {
      var _getNativeRtpCapabilities = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {
        var pc, offer, sdpObject, nativeRtpCapabilities, _t;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              logger.debug('getNativeRtpCapabilities()');
              pc = new RTCPeerConnection({
                iceServers: [],
                iceTransportPolicy: 'all',
                bundlePolicy: 'max-bundle',
                rtcpMuxPolicy: 'require',
                sdpSemantics: 'unified-plan'
              });
              _context.p = 1;
              pc.addTransceiver('audio');
              // Create video transceiver with scalability mode in order to retrieve
              // Dependency Descriptor header extension.
              pc.addTransceiver('video', {
                sendEncodings: [{
                  scalabilityMode: 'L3T3'
                }]
              });
              _context.n = 2;
              return pc.createOffer();
            case 2:
              offer = _context.v;
              try {
                pc.close();
              } catch (error) {}
              sdpObject = sdpTransform.parse(offer.sdp);
              nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject: sdpObject
              }); // libwebrtc supports NACK for OPUS but doesn't announce it.
              ortcUtils.addNackSupportForOpus(nativeRtpCapabilities);
              return _context.a(2, nativeRtpCapabilities);
            case 3:
              _context.p = 3;
              _t = _context.v;
              try {
                pc.close();
              } catch (error2) {}
              throw _t;
            case 4:
              return _context.a(2);
          }
        }, _callee, null, [[1, 3]]);
      }));
      function getNativeRtpCapabilities() {
        return _getNativeRtpCapabilities.apply(this, arguments);
      }
      return getNativeRtpCapabilities;
    }()
  }, {
    key: "getNativeSctpCapabilities",
    value: function () {
      var _getNativeSctpCapabilities = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2() {
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.n) {
            case 0:
              logger.debug('getNativeSctpCapabilities()');
              return _context2.a(2, {
                numStreams: SCTP_NUM_STREAMS
              });
          }
        }, _callee2);
      }));
      function getNativeSctpCapabilities() {
        return _getNativeSctpCapabilities.apply(this, arguments);
      }
      return getNativeSctpCapabilities;
    }()
  }, {
    key: "run",
    value: function run(_ref) {
      var _this2 = this;
      var direction = _ref.direction,
        iceParameters = _ref.iceParameters,
        iceCandidates = _ref.iceCandidates,
        dtlsParameters = _ref.dtlsParameters,
        sctpParameters = _ref.sctpParameters,
        iceServers = _ref.iceServers,
        iceTransportPolicy = _ref.iceTransportPolicy,
        additionalSettings = _ref.additionalSettings,
        proprietaryConstraints = _ref.proprietaryConstraints,
        extendedRtpCapabilities = _ref.extendedRtpCapabilities;
      this.assertNotClosed();
      logger.debug('run()');
      this._direction = direction;
      this._remoteSdp = new RemoteSdp_1.RemoteSdp({
        iceParameters: iceParameters,
        iceCandidates: iceCandidates,
        dtlsParameters: dtlsParameters,
        sctpParameters: sctpParameters
      });
      this._sendingRtpParametersByKind = {
        audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
        video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
      };
      this._sendingRemoteRtpParametersByKind = {
        audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
        video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)
      };
      if (dtlsParameters.role && dtlsParameters.role !== 'auto') {
        this._forcedLocalDtlsRole = dtlsParameters.role === 'server' ? 'client' : 'server';
      }
      this._pc = new RTCPeerConnection(_objectSpread({
        iceServers: iceServers !== null && iceServers !== void 0 ? iceServers : [],
        iceTransportPolicy: iceTransportPolicy !== null && iceTransportPolicy !== void 0 ? iceTransportPolicy : 'all',
        bundlePolicy: 'max-bundle',
        rtcpMuxPolicy: 'require',
        sdpSemantics: 'unified-plan'
      }, additionalSettings), proprietaryConstraints);
      this._pc.addEventListener('icegatheringstatechange', function () {
        _this2.emit('@icegatheringstatechange', _this2._pc.iceGatheringState);
      });
      this._pc.addEventListener('icecandidateerror', function (event) {
        _this2.emit('@icecandidateerror', event);
      });
      if (this._pc.connectionState) {
        this._pc.addEventListener('connectionstatechange', function () {
          _this2.emit('@connectionstatechange', _this2._pc.connectionState);
        });
      } else {
        logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
        this._pc.addEventListener('iceconnectionstatechange', function () {
          switch (_this2._pc.iceConnectionState) {
            case 'checking':
              {
                _this2.emit('@connectionstatechange', 'connecting');
                break;
              }
            case 'connected':
            case 'completed':
              {
                _this2.emit('@connectionstatechange', 'connected');
                break;
              }
            case 'failed':
              {
                _this2.emit('@connectionstatechange', 'failed');
                break;
              }
            case 'disconnected':
              {
                _this2.emit('@connectionstatechange', 'disconnected');
                break;
              }
            case 'closed':
              {
                _this2.emit('@connectionstatechange', 'closed');
                break;
              }
          }
        });
      }
    }
  }, {
    key: "updateIceServers",
    value: function () {
      var _updateIceServers = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(iceServers) {
        var configuration;
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.n) {
            case 0:
              this.assertNotClosed();
              logger.debug('updateIceServers()');
              configuration = this._pc.getConfiguration();
              configuration.iceServers = iceServers;
              this._pc.setConfiguration(configuration);
            case 1:
              return _context3.a(2);
          }
        }, _callee3, this);
      }));
      function updateIceServers(_x) {
        return _updateIceServers.apply(this, arguments);
      }
      return updateIceServers;
    }()
  }, {
    key: "restartIce",
    value: function () {
      var _restartIce = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(iceParameters) {
        var offer, answer, _offer, _answer;
        return _regenerator().w(function (_context4) {
          while (1) switch (_context4.n) {
            case 0:
              this.assertNotClosed();
              logger.debug('restartIce()');
              // Provide the remote SDP handler with new remote ICE parameters.
              this._remoteSdp.updateIceParameters(iceParameters);
              if (this._transportReady) {
                _context4.n = 1;
                break;
              }
              return _context4.a(2);
            case 1:
              if (!(this._direction === 'send')) {
                _context4.n = 5;
                break;
              }
              _context4.n = 2;
              return this._pc.createOffer({
                iceRestart: true
              });
            case 2:
              offer = _context4.v;
              logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context4.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context4.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              _context4.n = 8;
              break;
            case 5:
              _offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', _offer);
              _context4.n = 6;
              return this._pc.setRemoteDescription(_offer);
            case 6:
              _context4.n = 7;
              return this._pc.createAnswer();
            case 7:
              _answer = _context4.v;
              logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', _answer);
              _context4.n = 8;
              return this._pc.setLocalDescription(_answer);
            case 8:
              return _context4.a(2);
          }
        }, _callee4, this);
      }));
      function restartIce(_x2) {
        return _restartIce.apply(this, arguments);
      }
      return restartIce;
    }()
  }, {
    key: "getTransportStats",
    value: function () {
      var _getTransportStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5() {
        return _regenerator().w(function (_context5) {
          while (1) switch (_context5.n) {
            case 0:
              this.assertNotClosed();
              return _context5.a(2, this._pc.getStats());
          }
        }, _callee5, this);
      }));
      function getTransportStats() {
        return _getTransportStats.apply(this, arguments);
      }
      return getTransportStats;
    }()
  }, {
    key: "send",
    value: function () {
      var _send = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6(_ref2) {
        var track, encodings, codecOptions, codec, onRtpSender, maxTemporalLayers, _iterator, _step, encoding, temporalLayers, sendingRtpParameters, sendingRemoteRtpParameters, mediaSectionIdx, transceiver, offer, localSdpObject, _this$_forcedLocalDtl, localId, offerMediaObject, newEncodings, answer;
        return _regenerator().w(function (_context6) {
          while (1) switch (_context6.n) {
            case 0:
              track = _ref2.track, encodings = _ref2.encodings, codecOptions = _ref2.codecOptions, codec = _ref2.codec, onRtpSender = _ref2.onRtpSender;
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
              if (encodings && encodings.length > 1) {
                // Set rid and verify scalabilityMode in each encoding.
                // NOTE: Even if WebRTC allows different scalabilityMode (different number
                // of temporal layers) per simulcast stream, we need that those are the
                // same in all them, so let's pick up the highest value.
                // NOTE: If scalabilityMode is not given, Chrome will use L1T3.
                maxTemporalLayers = 1;
                _iterator = _createForOfIteratorHelper(encodings);
                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    encoding = _step.value;
                    temporalLayers = encoding.scalabilityMode ? (0, scalabilityModes_1.parse)(encoding.scalabilityMode).temporalLayers : 3;
                    if (temporalLayers > maxTemporalLayers) {
                      maxTemporalLayers = temporalLayers;
                    }
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
                encodings.forEach(function (encoding, idx) {
                  encoding.rid = "r".concat(idx);
                  encoding.scalabilityMode = "L1T".concat(maxTemporalLayers);
                });
              }
              sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]); // This may throw.
              sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
              sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]); // This may throw.
              sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
              mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
              transceiver = this._pc.addTransceiver(track, {
                direction: 'sendonly',
                streams: [this._sendStream],
                sendEncodings: encodings
              });
              if (onRtpSender) {
                onRtpSender(transceiver.sender);
              }
              _context6.n = 1;
              return this._pc.createOffer();
            case 1:
              offer = _context6.v;
              localSdpObject = sdpTransform.parse(offer.sdp); // @ts-expect-error --- sdpTransform.SessionDescription type doesn't
              // define extmapAllowMixed field.
              if (localSdpObject.extmapAllowMixed) {
                this._remoteSdp.setSessionExtmapAllowMixed();
              }
              if (this._transportReady) {
                _context6.n = 2;
                break;
              }
              _context6.n = 2;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl !== void 0 ? _this$_forcedLocalDtl : 'client',
                localSdpObject: localSdpObject
              });
            case 2:
              logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context6.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              // We can now get the transceiver.mid.
              localId = transceiver.mid; // Set MID.
              sendingRtpParameters.mid = localId;
              localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
              offerMediaObject = localSdpObject.media[mediaSectionIdx.idx]; // Set RTCP CNAME.
              sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
                offerMediaObject: offerMediaObject
              });
              // Set RTP encodings by parsing the SDP offer if no encodings are given.
              if (!encodings) {
                sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
                  offerMediaObject: offerMediaObject
                });
              }
              // Set RTP encodings by parsing the SDP offer and complete them with given
              // one if just a single encoding has been given.
              else if (encodings.length === 1) {
                newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
                  offerMediaObject: offerMediaObject
                });
                Object.assign(newEncodings[0], encodings[0]);
                sendingRtpParameters.encodings = newEncodings;
              }
              // Otherwise if more than 1 encoding are given use them verbatim.
              else {
                sendingRtpParameters.encodings = encodings;
              }
              this._remoteSdp.send({
                offerMediaObject: offerMediaObject,
                reuseMid: mediaSectionIdx.reuseMid,
                offerRtpParameters: sendingRtpParameters,
                answerRtpParameters: sendingRemoteRtpParameters,
                codecOptions: codecOptions
              });
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context6.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              // Store in the map.
              this._mapMidTransceiver.set(localId, transceiver);
              return _context6.a(2, {
                localId: localId,
                rtpParameters: sendingRtpParameters,
                rtpSender: transceiver.sender
              });
          }
        }, _callee6, this);
      }));
      function send(_x3) {
        return _send.apply(this, arguments);
      }
      return send;
    }()
  }, {
    key: "stopSending",
    value: function () {
      var _stopSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7(localId) {
        var transceiver, mediaSectionClosed, offer, answer;
        return _regenerator().w(function (_context7) {
          while (1) switch (_context7.n) {
            case 0:
              this.assertSendDirection();
              logger.debug('stopSending() [localId:%s]', localId);
              if (!this._closed) {
                _context7.n = 1;
                break;
              }
              return _context7.a(2);
            case 1:
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context7.n = 2;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 2:
              void transceiver.sender.replaceTrack(null);
              this._pc.removeTrack(transceiver.sender);
              mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
              if (mediaSectionClosed) {
                try {
                  transceiver.stop();
                } catch (error) {}
              }
              _context7.n = 3;
              return this._pc.createOffer();
            case 3:
              offer = _context7.v;
              logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context7.n = 4;
              return this._pc.setLocalDescription(offer);
            case 4:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context7.n = 5;
              return this._pc.setRemoteDescription(answer);
            case 5:
              this._mapMidTransceiver["delete"](localId);
            case 6:
              return _context7.a(2);
          }
        }, _callee7, this);
      }));
      function stopSending(_x4) {
        return _stopSending.apply(this, arguments);
      }
      return stopSending;
    }()
  }, {
    key: "pauseSending",
    value: function () {
      var _pauseSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8(localId) {
        var transceiver, offer, answer;
        return _regenerator().w(function (_context8) {
          while (1) switch (_context8.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('pauseSending() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context8.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              transceiver.direction = 'inactive';
              this._remoteSdp.pauseMediaSection(localId);
              _context8.n = 2;
              return this._pc.createOffer();
            case 2:
              offer = _context8.v;
              logger.debug('pauseSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context8.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('pauseSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context8.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              return _context8.a(2);
          }
        }, _callee8, this);
      }));
      function pauseSending(_x5) {
        return _pauseSending.apply(this, arguments);
      }
      return pauseSending;
    }()
  }, {
    key: "resumeSending",
    value: function () {
      var _resumeSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee9(localId) {
        var transceiver, offer, answer;
        return _regenerator().w(function (_context9) {
          while (1) switch (_context9.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('resumeSending() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              this._remoteSdp.resumeSendingMediaSection(localId);
              if (transceiver) {
                _context9.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              transceiver.direction = 'sendonly';
              _context9.n = 2;
              return this._pc.createOffer();
            case 2:
              offer = _context9.v;
              logger.debug('resumeSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context9.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('resumeSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context9.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              return _context9.a(2);
          }
        }, _callee9, this);
      }));
      function resumeSending(_x6) {
        return _resumeSending.apply(this, arguments);
      }
      return resumeSending;
    }()
  }, {
    key: "replaceTrack",
    value: function () {
      var _replaceTrack = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee0(localId, track) {
        var transceiver;
        return _regenerator().w(function (_context0) {
          while (1) switch (_context0.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              if (track) {
                logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
              } else {
                logger.debug('replaceTrack() [localId:%s, no track]', localId);
              }
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context0.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              _context0.n = 2;
              return transceiver.sender.replaceTrack(track);
            case 2:
              return _context0.a(2);
          }
        }, _callee0, this);
      }));
      function replaceTrack(_x7, _x8) {
        return _replaceTrack.apply(this, arguments);
      }
      return replaceTrack;
    }()
  }, {
    key: "setMaxSpatialLayer",
    value: function () {
      var _setMaxSpatialLayer = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee1(localId, spatialLayer) {
        var transceiver, parameters, offer, answer;
        return _regenerator().w(function (_context1) {
          while (1) switch (_context1.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context1.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              parameters = transceiver.sender.getParameters();
              parameters.encodings.forEach(function (encoding, idx) {
                if (idx <= spatialLayer) {
                  encoding.active = true;
                } else {
                  encoding.active = false;
                }
              });
              _context1.n = 2;
              return transceiver.sender.setParameters(parameters);
            case 2:
              this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
              _context1.n = 3;
              return this._pc.createOffer();
            case 3:
              offer = _context1.v;
              logger.debug('setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context1.n = 4;
              return this._pc.setLocalDescription(offer);
            case 4:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context1.n = 5;
              return this._pc.setRemoteDescription(answer);
            case 5:
              return _context1.a(2);
          }
        }, _callee1, this);
      }));
      function setMaxSpatialLayer(_x9, _x0) {
        return _setMaxSpatialLayer.apply(this, arguments);
      }
      return setMaxSpatialLayer;
    }()
  }, {
    key: "setRtpEncodingParameters",
    value: function () {
      var _setRtpEncodingParameters = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee10(localId, params) {
        var transceiver, parameters, offer, answer;
        return _regenerator().w(function (_context10) {
          while (1) switch (_context10.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context10.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              parameters = transceiver.sender.getParameters();
              parameters.encodings.forEach(function (encoding, idx) {
                parameters.encodings[idx] = _objectSpread(_objectSpread({}, encoding), params);
              });
              _context10.n = 2;
              return transceiver.sender.setParameters(parameters);
            case 2:
              this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
              _context10.n = 3;
              return this._pc.createOffer();
            case 3:
              offer = _context10.v;
              logger.debug('setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context10.n = 4;
              return this._pc.setLocalDescription(offer);
            case 4:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context10.n = 5;
              return this._pc.setRemoteDescription(answer);
            case 5:
              return _context10.a(2);
          }
        }, _callee10, this);
      }));
      function setRtpEncodingParameters(_x1, _x10) {
        return _setRtpEncodingParameters.apply(this, arguments);
      }
      return setRtpEncodingParameters;
    }()
  }, {
    key: "getSenderStats",
    value: function () {
      var _getSenderStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee11(localId) {
        var transceiver;
        return _regenerator().w(function (_context11) {
          while (1) switch (_context11.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context11.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              return _context11.a(2, transceiver.sender.getStats());
          }
        }, _callee11, this);
      }));
      function getSenderStats(_x11) {
        return _getSenderStats.apply(this, arguments);
      }
      return getSenderStats;
    }()
  }, {
    key: "sendDataChannel",
    value: function () {
      var _sendDataChannel = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee12(_ref3) {
        var ordered, maxPacketLifeTime, maxRetransmits, label, protocol, options, dataChannel, offer, localSdpObject, offerMediaObject, _this$_forcedLocalDtl2, answer, sctpStreamParameters;
        return _regenerator().w(function (_context12) {
          while (1) switch (_context12.n) {
            case 0:
              ordered = _ref3.ordered, maxPacketLifeTime = _ref3.maxPacketLifeTime, maxRetransmits = _ref3.maxRetransmits, label = _ref3.label, protocol = _ref3.protocol;
              this.assertNotClosed();
              this.assertSendDirection();
              options = {
                negotiated: true,
                id: this._nextSendSctpStreamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmits: maxRetransmits,
                protocol: protocol
              };
              logger.debug('sendDataChannel() [options:%o]', options);
              dataChannel = this._pc.createDataChannel(label, options); // Increase next id.
              this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
              // If this is the first DataChannel we need to create the SDP answer with
              // m=application section.
              if (this._hasDataChannelMediaSection) {
                _context12.n = 5;
                break;
              }
              _context12.n = 1;
              return this._pc.createOffer();
            case 1:
              offer = _context12.v;
              localSdpObject = sdpTransform.parse(offer.sdp);
              offerMediaObject = localSdpObject.media.find(function (m) {
                return m.type === 'application';
              });
              if (this._transportReady) {
                _context12.n = 2;
                break;
              }
              _context12.n = 2;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl2 = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl2 !== void 0 ? _this$_forcedLocalDtl2 : 'client',
                localSdpObject: localSdpObject
              });
            case 2:
              logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context12.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              this._remoteSdp.sendSctpAssociation({
                offerMediaObject: offerMediaObject
              });
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context12.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              this._hasDataChannelMediaSection = true;
            case 5:
              sctpStreamParameters = {
                streamId: options.id,
                ordered: options.ordered,
                maxPacketLifeTime: options.maxPacketLifeTime,
                maxRetransmits: options.maxRetransmits
              };
              return _context12.a(2, {
                dataChannel: dataChannel,
                sctpStreamParameters: sctpStreamParameters
              });
          }
        }, _callee12, this);
      }));
      function sendDataChannel(_x12) {
        return _sendDataChannel.apply(this, arguments);
      }
      return sendDataChannel;
    }()
  }, {
    key: "receive",
    value: function () {
      var _receive = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee13(optionsList) {
        var _this3 = this;
        var results, mapLocalId, _iterator2, _step2, _rtpParameters$mid, options, trackId, kind, rtpParameters, streamId, localId, offer, _iterator3, _step3, _loop, answer, localSdpObject, _iterator4, _step4, _loop2, _this$_forcedLocalDtl3, _iterator5, _step5, _loop3, _t2, _t3, _t4;
        return _regenerator().w(function (_context16) {
          while (1) switch (_context16.n) {
            case 0:
              this.assertNotClosed();
              this.assertRecvDirection();
              results = [];
              mapLocalId = new Map();
              _iterator2 = _createForOfIteratorHelper(optionsList);
              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  options = _step2.value;
                  trackId = options.trackId, kind = options.kind, rtpParameters = options.rtpParameters, streamId = options.streamId;
                  logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
                  localId = (_rtpParameters$mid = rtpParameters.mid) !== null && _rtpParameters$mid !== void 0 ? _rtpParameters$mid : String(this._mapMidTransceiver.size);
                  mapLocalId.set(trackId, localId);
                  this._remoteSdp.receive({
                    mid: localId,
                    kind: kind,
                    offerRtpParameters: rtpParameters,
                    streamId: streamId !== null && streamId !== void 0 ? streamId : rtpParameters.rtcp.cname,
                    trackId: trackId
                  });
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context16.n = 1;
              return this._pc.setRemoteDescription(offer);
            case 1:
              _iterator3 = _createForOfIteratorHelper(optionsList);
              _context16.p = 2;
              _loop = /*#__PURE__*/_regenerator().m(function _loop() {
                var options, trackId, onRtpReceiver, _localId, transceiver;
                return _regenerator().w(function (_context13) {
                  while (1) switch (_context13.n) {
                    case 0:
                      options = _step3.value;
                      trackId = options.trackId, onRtpReceiver = options.onRtpReceiver;
                      if (!onRtpReceiver) {
                        _context13.n = 2;
                        break;
                      }
                      _localId = mapLocalId.get(trackId);
                      transceiver = _this3._pc.getTransceivers().find(function (t) {
                        return t.mid === _localId;
                      });
                      if (transceiver) {
                        _context13.n = 1;
                        break;
                      }
                      throw new Error('transceiver not found');
                    case 1:
                      onRtpReceiver(transceiver.receiver);
                    case 2:
                      return _context13.a(2);
                  }
                }, _loop);
              });
              _iterator3.s();
            case 3:
              if ((_step3 = _iterator3.n()).done) {
                _context16.n = 5;
                break;
              }
              return _context16.d(_regeneratorValues(_loop()), 4);
            case 4:
              _context16.n = 3;
              break;
            case 5:
              _context16.n = 7;
              break;
            case 6:
              _context16.p = 6;
              _t2 = _context16.v;
              _iterator3.e(_t2);
            case 7:
              _context16.p = 7;
              _iterator3.f();
              return _context16.f(7);
            case 8:
              _context16.n = 9;
              return this._pc.createAnswer();
            case 9:
              answer = _context16.v;
              localSdpObject = sdpTransform.parse(answer.sdp);
              _iterator4 = _createForOfIteratorHelper(optionsList);
              _context16.p = 10;
              _loop2 = /*#__PURE__*/_regenerator().m(function _loop2() {
                var options, trackId, rtpParameters, localId, answerMediaObject;
                return _regenerator().w(function (_context14) {
                  while (1) switch (_context14.n) {
                    case 0:
                      options = _step4.value;
                      trackId = options.trackId, rtpParameters = options.rtpParameters;
                      localId = mapLocalId.get(trackId);
                      answerMediaObject = localSdpObject.media.find(function (m) {
                        return String(m.mid) === localId;
                      }); // May need to modify codec parameters in the answer based on codec
                      // parameters in the offer.
                      sdpCommonUtils.applyCodecParameters({
                        offerRtpParameters: rtpParameters,
                        answerMediaObject: answerMediaObject
                      });
                    case 1:
                      return _context14.a(2);
                  }
                }, _loop2);
              });
              _iterator4.s();
            case 11:
              if ((_step4 = _iterator4.n()).done) {
                _context16.n = 13;
                break;
              }
              return _context16.d(_regeneratorValues(_loop2()), 12);
            case 12:
              _context16.n = 11;
              break;
            case 13:
              _context16.n = 15;
              break;
            case 14:
              _context16.p = 14;
              _t3 = _context16.v;
              _iterator4.e(_t3);
            case 15:
              _context16.p = 15;
              _iterator4.f();
              return _context16.f(15);
            case 16:
              answer = {
                type: 'answer',
                sdp: sdpTransform.write(localSdpObject)
              };
              if (this._transportReady) {
                _context16.n = 17;
                break;
              }
              _context16.n = 17;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl3 = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl3 !== void 0 ? _this$_forcedLocalDtl3 : 'client',
                localSdpObject: localSdpObject
              });
            case 17:
              logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context16.n = 18;
              return this._pc.setLocalDescription(answer);
            case 18:
              _iterator5 = _createForOfIteratorHelper(optionsList);
              _context16.p = 19;
              _loop3 = /*#__PURE__*/_regenerator().m(function _loop3() {
                var options, trackId, localId, transceiver;
                return _regenerator().w(function (_context15) {
                  while (1) switch (_context15.n) {
                    case 0:
                      options = _step5.value;
                      trackId = options.trackId;
                      localId = mapLocalId.get(trackId);
                      transceiver = _this3._pc.getTransceivers().find(function (t) {
                        return t.mid === localId;
                      });
                      if (transceiver) {
                        _context15.n = 1;
                        break;
                      }
                      throw new Error('new RTCRtpTransceiver not found');
                    case 1:
                      // Store in the map.
                      _this3._mapMidTransceiver.set(localId, transceiver);
                      results.push({
                        localId: localId,
                        track: transceiver.receiver.track,
                        rtpReceiver: transceiver.receiver
                      });
                    case 2:
                      return _context15.a(2);
                  }
                }, _loop3);
              });
              _iterator5.s();
            case 20:
              if ((_step5 = _iterator5.n()).done) {
                _context16.n = 22;
                break;
              }
              return _context16.d(_regeneratorValues(_loop3()), 21);
            case 21:
              _context16.n = 20;
              break;
            case 22:
              _context16.n = 24;
              break;
            case 23:
              _context16.p = 23;
              _t4 = _context16.v;
              _iterator5.e(_t4);
            case 24:
              _context16.p = 24;
              _iterator5.f();
              return _context16.f(24);
            case 25:
              return _context16.a(2, results);
          }
        }, _callee13, this, [[19, 23, 24, 25], [10, 14, 15, 16], [2, 6, 7, 8]]);
      }));
      function receive(_x13) {
        return _receive.apply(this, arguments);
      }
      return receive;
    }()
  }, {
    key: "stopReceiving",
    value: function () {
      var _stopReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee14(localIds) {
        var _iterator6, _step6, localId, transceiver, offer, answer, _iterator7, _step7, _localId2, _t5;
        return _regenerator().w(function (_context17) {
          while (1) switch (_context17.n) {
            case 0:
              this.assertRecvDirection();
              if (!this._closed) {
                _context17.n = 1;
                break;
              }
              return _context17.a(2);
            case 1:
              _iterator6 = _createForOfIteratorHelper(localIds);
              _context17.p = 2;
              _iterator6.s();
            case 3:
              if ((_step6 = _iterator6.n()).done) {
                _context17.n = 6;
                break;
              }
              localId = _step6.value;
              logger.debug('stopReceiving() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context17.n = 4;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 4:
              this._remoteSdp.closeMediaSection(transceiver.mid);
            case 5:
              _context17.n = 3;
              break;
            case 6:
              _context17.n = 8;
              break;
            case 7:
              _context17.p = 7;
              _t5 = _context17.v;
              _iterator6.e(_t5);
            case 8:
              _context17.p = 8;
              _iterator6.f();
              return _context17.f(8);
            case 9:
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context17.n = 10;
              return this._pc.setRemoteDescription(offer);
            case 10:
              _context17.n = 11;
              return this._pc.createAnswer();
            case 11:
              answer = _context17.v;
              logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context17.n = 12;
              return this._pc.setLocalDescription(answer);
            case 12:
              _iterator7 = _createForOfIteratorHelper(localIds);
              try {
                for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                  _localId2 = _step7.value;
                  this._mapMidTransceiver["delete"](_localId2);
                }
              } catch (err) {
                _iterator7.e(err);
              } finally {
                _iterator7.f();
              }
            case 13:
              return _context17.a(2);
          }
        }, _callee14, this, [[2, 7, 8, 9]]);
      }));
      function stopReceiving(_x14) {
        return _stopReceiving.apply(this, arguments);
      }
      return stopReceiving;
    }()
  }, {
    key: "pauseReceiving",
    value: function () {
      var _pauseReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee15(localIds) {
        var _iterator8, _step8, localId, transceiver, offer, answer, _t6;
        return _regenerator().w(function (_context18) {
          while (1) switch (_context18.n) {
            case 0:
              this.assertNotClosed();
              this.assertRecvDirection();
              _iterator8 = _createForOfIteratorHelper(localIds);
              _context18.p = 1;
              _iterator8.s();
            case 2:
              if ((_step8 = _iterator8.n()).done) {
                _context18.n = 5;
                break;
              }
              localId = _step8.value;
              logger.debug('pauseReceiving() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context18.n = 3;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 3:
              transceiver.direction = 'inactive';
              this._remoteSdp.pauseMediaSection(localId);
            case 4:
              _context18.n = 2;
              break;
            case 5:
              _context18.n = 7;
              break;
            case 6:
              _context18.p = 6;
              _t6 = _context18.v;
              _iterator8.e(_t6);
            case 7:
              _context18.p = 7;
              _iterator8.f();
              return _context18.f(7);
            case 8:
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context18.n = 9;
              return this._pc.setRemoteDescription(offer);
            case 9:
              _context18.n = 10;
              return this._pc.createAnswer();
            case 10:
              answer = _context18.v;
              logger.debug('pauseReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context18.n = 11;
              return this._pc.setLocalDescription(answer);
            case 11:
              return _context18.a(2);
          }
        }, _callee15, this, [[1, 6, 7, 8]]);
      }));
      function pauseReceiving(_x15) {
        return _pauseReceiving.apply(this, arguments);
      }
      return pauseReceiving;
    }()
  }, {
    key: "resumeReceiving",
    value: function () {
      var _resumeReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee16(localIds) {
        var _iterator9, _step9, localId, transceiver, offer, answer, _t7;
        return _regenerator().w(function (_context19) {
          while (1) switch (_context19.n) {
            case 0:
              this.assertNotClosed();
              this.assertRecvDirection();
              _iterator9 = _createForOfIteratorHelper(localIds);
              _context19.p = 1;
              _iterator9.s();
            case 2:
              if ((_step9 = _iterator9.n()).done) {
                _context19.n = 5;
                break;
              }
              localId = _step9.value;
              logger.debug('resumeReceiving() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context19.n = 3;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 3:
              transceiver.direction = 'recvonly';
              this._remoteSdp.resumeReceivingMediaSection(localId);
            case 4:
              _context19.n = 2;
              break;
            case 5:
              _context19.n = 7;
              break;
            case 6:
              _context19.p = 6;
              _t7 = _context19.v;
              _iterator9.e(_t7);
            case 7:
              _context19.p = 7;
              _iterator9.f();
              return _context19.f(7);
            case 8:
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context19.n = 9;
              return this._pc.setRemoteDescription(offer);
            case 9:
              _context19.n = 10;
              return this._pc.createAnswer();
            case 10:
              answer = _context19.v;
              logger.debug('resumeReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context19.n = 11;
              return this._pc.setLocalDescription(answer);
            case 11:
              return _context19.a(2);
          }
        }, _callee16, this, [[1, 6, 7, 8]]);
      }));
      function resumeReceiving(_x16) {
        return _resumeReceiving.apply(this, arguments);
      }
      return resumeReceiving;
    }()
  }, {
    key: "getReceiverStats",
    value: function () {
      var _getReceiverStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee17(localId) {
        var transceiver;
        return _regenerator().w(function (_context20) {
          while (1) switch (_context20.n) {
            case 0:
              this.assertNotClosed();
              this.assertRecvDirection();
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context20.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              return _context20.a(2, transceiver.receiver.getStats());
          }
        }, _callee17, this);
      }));
      function getReceiverStats(_x17) {
        return _getReceiverStats.apply(this, arguments);
      }
      return getReceiverStats;
    }()
  }, {
    key: "receiveDataChannel",
    value: function () {
      var _receiveDataChannel = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee18(_ref4) {
        var sctpStreamParameters, label, protocol, streamId, ordered, maxPacketLifeTime, maxRetransmits, options, dataChannel, offer, answer, _this$_forcedLocalDtl4, localSdpObject;
        return _regenerator().w(function (_context21) {
          while (1) switch (_context21.n) {
            case 0:
              sctpStreamParameters = _ref4.sctpStreamParameters, label = _ref4.label, protocol = _ref4.protocol;
              this.assertNotClosed();
              this.assertRecvDirection();
              streamId = sctpStreamParameters.streamId, ordered = sctpStreamParameters.ordered, maxPacketLifeTime = sctpStreamParameters.maxPacketLifeTime, maxRetransmits = sctpStreamParameters.maxRetransmits;
              options = {
                negotiated: true,
                id: streamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmits: maxRetransmits,
                protocol: protocol
              };
              logger.debug('receiveDataChannel() [options:%o]', options);
              dataChannel = this._pc.createDataChannel(label, options); // If this is the first DataChannel we need to create the SDP offer with
              // m=application section.
              if (this._hasDataChannelMediaSection) {
                _context21.n = 5;
                break;
              }
              this._remoteSdp.receiveSctpAssociation();
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context21.n = 1;
              return this._pc.setRemoteDescription(offer);
            case 1:
              _context21.n = 2;
              return this._pc.createAnswer();
            case 2:
              answer = _context21.v;
              if (this._transportReady) {
                _context21.n = 3;
                break;
              }
              localSdpObject = sdpTransform.parse(answer.sdp);
              _context21.n = 3;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl4 = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl4 !== void 0 ? _this$_forcedLocalDtl4 : 'client',
                localSdpObject: localSdpObject
              });
            case 3:
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context21.n = 4;
              return this._pc.setLocalDescription(answer);
            case 4:
              this._hasDataChannelMediaSection = true;
            case 5:
              return _context21.a(2, {
                dataChannel: dataChannel
              });
          }
        }, _callee18, this);
      }));
      function receiveDataChannel(_x18) {
        return _receiveDataChannel.apply(this, arguments);
      }
      return receiveDataChannel;
    }()
  }, {
    key: "setupTransport",
    value: function () {
      var _setupTransport = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee19(_ref5) {
        var _this4 = this;
        var localDtlsRole, localSdpObject, dtlsParameters;
        return _regenerator().w(function (_context22) {
          while (1) switch (_context22.n) {
            case 0:
              localDtlsRole = _ref5.localDtlsRole, localSdpObject = _ref5.localSdpObject;
              if (!localSdpObject) {
                localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
              }
              // Get our local DTLS parameters.
              dtlsParameters = sdpCommonUtils.extractDtlsParameters({
                sdpObject: localSdpObject
              }); // Set our DTLS role.
              dtlsParameters.role = localDtlsRole;
              // Update the remote DTLS role in the SDP.
              this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
              // Need to tell the remote transport about our parameters.
              _context22.n = 1;
              return new Promise(function (resolve, reject) {
                _this4.safeEmit('@connect', {
                  dtlsParameters: dtlsParameters
                }, resolve, reject);
              });
            case 1:
              this._transportReady = true;
            case 2:
              return _context22.a(2);
          }
        }, _callee19, this);
      }));
      function setupTransport(_x19) {
        return _setupTransport.apply(this, arguments);
      }
      return setupTransport;
    }()
  }, {
    key: "assertNotClosed",
    value: function assertNotClosed() {
      if (this._closed) {
        throw new errors_1.InvalidStateError('method called in a closed handler');
      }
    }
  }, {
    key: "assertSendDirection",
    value: function assertSendDirection() {
      if (this._direction !== 'send') {
        throw new Error('method can just be called for handlers with "send" direction');
      }
    }
  }, {
    key: "assertRecvDirection",
    value: function assertRecvDirection() {
      if (this._direction !== 'recv') {
        throw new Error('method can just be called for handlers with "recv" direction');
      }
    }
  }], [{
    key: "createFactory",
    value:
    /**
     * Creates a factory function.
     */
    function createFactory() {
      return function () {
        return new Chrome111();
      };
    }
  }]);
}(HandlerInterface_1.HandlerInterface);
exports.Chrome111 = Chrome111;

},{"../Logger":39,"../errors":45,"../ortc":68,"../scalabilityModes":69,"../utils":72,"./HandlerInterface":55,"./ortc/utils":61,"./sdp/RemoteSdp":63,"./sdp/commonUtils":64,"./sdp/unifiedPlanUtils":66,"sdp-transform":76}],47:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorValues(e) { if (null != e) { var t = e["function" == typeof Symbol && Symbol.iterator || "@@iterator"], r = 0; if (t) return t.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) return { next: function next() { return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e }; } }; } throw new TypeError(_typeof(e) + " is not iterable"); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o("next", 0), o("throw", 1), o("return", 2); } }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Chrome55 = void 0;
var sdpTransform = require("sdp-transform");
var Logger_1 = require("../Logger");
var errors_1 = require("../errors");
var utils = require("../utils");
var ortc = require("../ortc");
var sdpCommonUtils = require("./sdp/commonUtils");
var sdpPlanBUtils = require("./sdp/planBUtils");
var HandlerInterface_1 = require("./HandlerInterface");
var RemoteSdp_1 = require("./sdp/RemoteSdp");
var logger = new Logger_1.Logger('Chrome55');
var NAME = 'Chrome55';
var SCTP_NUM_STREAMS = {
  OS: 1024,
  MIS: 1024
};
var Chrome55 = /*#__PURE__*/function (_HandlerInterface_1$H) {
  function Chrome55() {
    var _this;
    _classCallCheck(this, Chrome55);
    _this = _callSuper(this, Chrome55);
    // Handler direction.
    _defineProperty(_this, "_direction", void 0);
    // Remote SDP handler.
    _defineProperty(_this, "_remoteSdp", void 0);
    // Generic sending RTP parameters for audio and video.
    _defineProperty(_this, "_sendingRtpParametersByKind", void 0);
    // Generic sending RTP parameters for audio and video suitable for the SDP
    // remote answer.
    _defineProperty(_this, "_sendingRemoteRtpParametersByKind", void 0);
    // Initial server side DTLS role. If not 'auto', it will force the opposite
    // value in client side.
    _defineProperty(_this, "_forcedLocalDtlsRole", void 0);
    // RTCPeerConnection instance.
    _defineProperty(_this, "_pc", void 0);
    // Local stream for sending.
    _defineProperty(_this, "_sendStream", new MediaStream());
    // Map of sending MediaStreamTracks indexed by localId.
    _defineProperty(_this, "_mapSendLocalIdTrack", new Map());
    // Next sending localId.
    _defineProperty(_this, "_nextSendLocalId", 0);
    // Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.
    // Value is an Object with mid, rtpParameters and rtpReceiver.
    _defineProperty(_this, "_mapRecvLocalIdInfo", new Map());
    // Whether a DataChannel m=application section has been created.
    _defineProperty(_this, "_hasDataChannelMediaSection", false);
    // Sending DataChannel id value counter. Incremented for each new DataChannel.
    _defineProperty(_this, "_nextSendSctpStreamId", 0);
    // Got transport local and remote parameters.
    _defineProperty(_this, "_transportReady", false);
    return _this;
  }
  _inherits(Chrome55, _HandlerInterface_1$H);
  return _createClass(Chrome55, [{
    key: "name",
    get: function get() {
      return NAME;
    }
  }, {
    key: "close",
    value: function close() {
      logger.debug('close()');
      // Close RTCPeerConnection.
      if (this._pc) {
        try {
          this._pc.close();
        } catch (error) {}
      }
      this.emit('@close');
    }
  }, {
    key: "getNativeRtpCapabilities",
    value: function () {
      var _getNativeRtpCapabilities = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {
        var pc, offer, sdpObject, nativeRtpCapabilities, _t;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              logger.debug('getNativeRtpCapabilities()');
              pc = new RTCPeerConnection({
                iceServers: [],
                iceTransportPolicy: 'all',
                bundlePolicy: 'max-bundle',
                rtcpMuxPolicy: 'require',
                sdpSemantics: 'plan-b'
              });
              _context.p = 1;
              _context.n = 2;
              return pc.createOffer({
                offerToReceiveAudio: true,
                offerToReceiveVideo: true
              });
            case 2:
              offer = _context.v;
              try {
                pc.close();
              } catch (error) {}
              sdpObject = sdpTransform.parse(offer.sdp);
              nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject: sdpObject
              });
              return _context.a(2, nativeRtpCapabilities);
            case 3:
              _context.p = 3;
              _t = _context.v;
              try {
                pc.close();
              } catch (error2) {}
              throw _t;
            case 4:
              return _context.a(2);
          }
        }, _callee, null, [[1, 3]]);
      }));
      function getNativeRtpCapabilities() {
        return _getNativeRtpCapabilities.apply(this, arguments);
      }
      return getNativeRtpCapabilities;
    }()
  }, {
    key: "getNativeSctpCapabilities",
    value: function () {
      var _getNativeSctpCapabilities = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2() {
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.n) {
            case 0:
              logger.debug('getNativeSctpCapabilities()');
              return _context2.a(2, {
                numStreams: SCTP_NUM_STREAMS
              });
          }
        }, _callee2);
      }));
      function getNativeSctpCapabilities() {
        return _getNativeSctpCapabilities.apply(this, arguments);
      }
      return getNativeSctpCapabilities;
    }()
  }, {
    key: "run",
    value: function run(_ref) {
      var _this2 = this;
      var direction = _ref.direction,
        iceParameters = _ref.iceParameters,
        iceCandidates = _ref.iceCandidates,
        dtlsParameters = _ref.dtlsParameters,
        sctpParameters = _ref.sctpParameters,
        iceServers = _ref.iceServers,
        iceTransportPolicy = _ref.iceTransportPolicy,
        additionalSettings = _ref.additionalSettings,
        proprietaryConstraints = _ref.proprietaryConstraints,
        extendedRtpCapabilities = _ref.extendedRtpCapabilities;
      logger.debug('run()');
      this._direction = direction;
      this._remoteSdp = new RemoteSdp_1.RemoteSdp({
        iceParameters: iceParameters,
        iceCandidates: iceCandidates,
        dtlsParameters: dtlsParameters,
        sctpParameters: sctpParameters,
        planB: true
      });
      this._sendingRtpParametersByKind = {
        audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
        video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
      };
      this._sendingRemoteRtpParametersByKind = {
        audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
        video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)
      };
      if (dtlsParameters.role && dtlsParameters.role !== 'auto') {
        this._forcedLocalDtlsRole = dtlsParameters.role === 'server' ? 'client' : 'server';
      }
      this._pc = new RTCPeerConnection(_objectSpread({
        iceServers: iceServers !== null && iceServers !== void 0 ? iceServers : [],
        iceTransportPolicy: iceTransportPolicy !== null && iceTransportPolicy !== void 0 ? iceTransportPolicy : 'all',
        bundlePolicy: 'max-bundle',
        rtcpMuxPolicy: 'require',
        sdpSemantics: 'plan-b'
      }, additionalSettings), proprietaryConstraints);
      this._pc.addEventListener('icegatheringstatechange', function () {
        _this2.emit('@icegatheringstatechange', _this2._pc.iceGatheringState);
      });
      this._pc.addEventListener('icecandidateerror', function (event) {
        _this2.emit('@icecandidateerror', event);
      });
      if (this._pc.connectionState) {
        this._pc.addEventListener('connectionstatechange', function () {
          _this2.emit('@connectionstatechange', _this2._pc.connectionState);
        });
      } else {
        this._pc.addEventListener('iceconnectionstatechange', function () {
          logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
          switch (_this2._pc.iceConnectionState) {
            case 'checking':
              {
                _this2.emit('@connectionstatechange', 'connecting');
                break;
              }
            case 'connected':
            case 'completed':
              {
                _this2.emit('@connectionstatechange', 'connected');
                break;
              }
            case 'failed':
              {
                _this2.emit('@connectionstatechange', 'failed');
                break;
              }
            case 'disconnected':
              {
                _this2.emit('@connectionstatechange', 'disconnected');
                break;
              }
            case 'closed':
              {
                _this2.emit('@connectionstatechange', 'closed');
                break;
              }
          }
        });
      }
    }
  }, {
    key: "updateIceServers",
    value: function () {
      var _updateIceServers = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(iceServers) {
        var configuration;
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.n) {
            case 0:
              logger.debug('updateIceServers()');
              configuration = this._pc.getConfiguration();
              configuration.iceServers = iceServers;
              this._pc.setConfiguration(configuration);
            case 1:
              return _context3.a(2);
          }
        }, _callee3, this);
      }));
      function updateIceServers(_x) {
        return _updateIceServers.apply(this, arguments);
      }
      return updateIceServers;
    }()
  }, {
    key: "restartIce",
    value: function () {
      var _restartIce = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(iceParameters) {
        var offer, answer, _offer, _answer;
        return _regenerator().w(function (_context4) {
          while (1) switch (_context4.n) {
            case 0:
              logger.debug('restartIce()');
              // Provide the remote SDP handler with new remote ICE parameters.
              this._remoteSdp.updateIceParameters(iceParameters);
              if (this._transportReady) {
                _context4.n = 1;
                break;
              }
              return _context4.a(2);
            case 1:
              if (!(this._direction === 'send')) {
                _context4.n = 5;
                break;
              }
              _context4.n = 2;
              return this._pc.createOffer({
                iceRestart: true
              });
            case 2:
              offer = _context4.v;
              logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context4.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context4.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              _context4.n = 8;
              break;
            case 5:
              _offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', _offer);
              _context4.n = 6;
              return this._pc.setRemoteDescription(_offer);
            case 6:
              _context4.n = 7;
              return this._pc.createAnswer();
            case 7:
              _answer = _context4.v;
              logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', _answer);
              _context4.n = 8;
              return this._pc.setLocalDescription(_answer);
            case 8:
              return _context4.a(2);
          }
        }, _callee4, this);
      }));
      function restartIce(_x2) {
        return _restartIce.apply(this, arguments);
      }
      return restartIce;
    }()
  }, {
    key: "getTransportStats",
    value: function () {
      var _getTransportStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5() {
        return _regenerator().w(function (_context5) {
          while (1) switch (_context5.n) {
            case 0:
              return _context5.a(2, this._pc.getStats());
          }
        }, _callee5, this);
      }));
      function getTransportStats() {
        return _getTransportStats.apply(this, arguments);
      }
      return getTransportStats;
    }()
  }, {
    key: "send",
    value: function () {
      var _send = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6(_ref2) {
        var track, encodings, codecOptions, codec, offer, localSdpObject, offerMediaObject, sendingRtpParameters, sendingRemoteRtpParameters, _this$_forcedLocalDtl, idx, _iterator, _step, encoding, answer, localId;
        return _regenerator().w(function (_context6) {
          while (1) switch (_context6.n) {
            case 0:
              track = _ref2.track, encodings = _ref2.encodings, codecOptions = _ref2.codecOptions, codec = _ref2.codec;
              this.assertSendDirection();
              logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
              if (codec) {
                logger.warn('send() | codec selection is not available in %s handler', this.name);
              }
              this._sendStream.addTrack(track);
              this._pc.addStream(this._sendStream);
              _context6.n = 1;
              return this._pc.createOffer();
            case 1:
              offer = _context6.v;
              localSdpObject = sdpTransform.parse(offer.sdp); // @ts-expect-error --- sdpTransform.SessionDescription type doesn't
              // define extmapAllowMixed field.
              if (localSdpObject.extmapAllowMixed) {
                this._remoteSdp.setSessionExtmapAllowMixed();
              }
              sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
              sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs);
              sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
              sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);
              if (this._transportReady) {
                _context6.n = 2;
                break;
              }
              _context6.n = 2;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl !== void 0 ? _this$_forcedLocalDtl : 'client',
                localSdpObject: localSdpObject
              });
            case 2:
              if (track.kind === 'video' && encodings && encodings.length > 1) {
                logger.debug('send() | enabling simulcast');
                localSdpObject = sdpTransform.parse(offer.sdp);
                offerMediaObject = localSdpObject.media.find(function (m) {
                  return m.type === 'video';
                });
                sdpPlanBUtils.addLegacySimulcast({
                  offerMediaObject: offerMediaObject,
                  track: track,
                  numStreams: encodings.length
                });
                offer = {
                  type: 'offer',
                  sdp: sdpTransform.write(localSdpObject)
                };
              }
              logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context6.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
              offerMediaObject = localSdpObject.media.find(function (m) {
                return m.type === track.kind;
              });
              // Set RTCP CNAME.
              sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
                offerMediaObject: offerMediaObject
              });
              // Set RTP encodings.
              sendingRtpParameters.encodings = sdpPlanBUtils.getRtpEncodings({
                offerMediaObject: offerMediaObject,
                track: track
              });
              // Complete encodings with given values.
              if (encodings) {
                for (idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
                  if (encodings[idx]) {
                    Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
                  }
                }
              }
              // If VP8 and there is effective simulcast, add scalabilityMode to each
              // encoding.
              if (sendingRtpParameters.encodings.length > 1 && sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8') {
                _iterator = _createForOfIteratorHelper(sendingRtpParameters.encodings);
                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    encoding = _step.value;
                    encoding.scalabilityMode = 'L1T3';
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
              }
              this._remoteSdp.send({
                offerMediaObject: offerMediaObject,
                offerRtpParameters: sendingRtpParameters,
                answerRtpParameters: sendingRemoteRtpParameters,
                codecOptions: codecOptions
              });
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context6.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              localId = String(this._nextSendLocalId);
              this._nextSendLocalId++;
              // Insert into the map.
              this._mapSendLocalIdTrack.set(localId, track);
              return _context6.a(2, {
                localId: localId,
                rtpParameters: sendingRtpParameters
              });
          }
        }, _callee6, this);
      }));
      function send(_x3) {
        return _send.apply(this, arguments);
      }
      return send;
    }()
  }, {
    key: "stopSending",
    value: function () {
      var _stopSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7(localId) {
        var track, offer, answer, _t2;
        return _regenerator().w(function (_context7) {
          while (1) switch (_context7.n) {
            case 0:
              this.assertSendDirection();
              logger.debug('stopSending() [localId:%s]', localId);
              track = this._mapSendLocalIdTrack.get(localId);
              if (track) {
                _context7.n = 1;
                break;
              }
              throw new Error('track not found');
            case 1:
              this._mapSendLocalIdTrack["delete"](localId);
              this._sendStream.removeTrack(track);
              this._pc.addStream(this._sendStream);
              _context7.n = 2;
              return this._pc.createOffer();
            case 2:
              offer = _context7.v;
              logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context7.p = 3;
              _context7.n = 4;
              return this._pc.setLocalDescription(offer);
            case 4:
              _context7.n = 7;
              break;
            case 5:
              _context7.p = 5;
              _t2 = _context7.v;
              if (!(this._sendStream.getTracks().length === 0)) {
                _context7.n = 6;
                break;
              }
              logger.warn('stopSending() | ignoring expected error due no sending tracks: %s', _t2.toString());
              return _context7.a(2);
            case 6:
              throw _t2;
            case 7:
              if (!(this._pc.signalingState === 'stable')) {
                _context7.n = 8;
                break;
              }
              return _context7.a(2);
            case 8:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context7.n = 9;
              return this._pc.setRemoteDescription(answer);
            case 9:
              return _context7.a(2);
          }
        }, _callee7, this, [[3, 5]]);
      }));
      function stopSending(_x4) {
        return _stopSending.apply(this, arguments);
      }
      return stopSending;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "pauseSending",
    value: function () {
      var _pauseSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8(localId) {
        return _regenerator().w(function (_context8) {
          while (1) switch (_context8.n) {
            case 0:
              return _context8.a(2);
          }
        }, _callee8);
      }));
      function pauseSending(_x5) {
        return _pauseSending.apply(this, arguments);
      }
      return pauseSending;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "resumeSending",
    value: function () {
      var _resumeSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee9(localId) {
        return _regenerator().w(function (_context9) {
          while (1) switch (_context9.n) {
            case 0:
              return _context9.a(2);
          }
        }, _callee9);
      }));
      function resumeSending(_x6) {
        return _resumeSending.apply(this, arguments);
      }
      return resumeSending;
    }()
  }, {
    key: "replaceTrack",
    value: function () {
      var _replaceTrack = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee0(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      localId,
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      track) {
        return _regenerator().w(function (_context0) {
          while (1) switch (_context0.n) {
            case 0:
              throw new errors_1.UnsupportedError('not implemented');
            case 1:
              return _context0.a(2);
          }
        }, _callee0);
      }));
      function replaceTrack(_x7, _x8) {
        return _replaceTrack.apply(this, arguments);
      }
      return replaceTrack;
    }()
  }, {
    key: "setMaxSpatialLayer",
    value: function () {
      var _setMaxSpatialLayer = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee1(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      localId,
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      spatialLayer) {
        return _regenerator().w(function (_context1) {
          while (1) switch (_context1.n) {
            case 0:
              throw new errors_1.UnsupportedError(' not implemented');
            case 1:
              return _context1.a(2);
          }
        }, _callee1);
      }));
      function setMaxSpatialLayer(_x9, _x0) {
        return _setMaxSpatialLayer.apply(this, arguments);
      }
      return setMaxSpatialLayer;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "setRtpEncodingParameters",
    value: function () {
      var _setRtpEncodingParameters = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee10(localId, params) {
        return _regenerator().w(function (_context10) {
          while (1) switch (_context10.n) {
            case 0:
              throw new errors_1.UnsupportedError('not supported');
            case 1:
              return _context10.a(2);
          }
        }, _callee10);
      }));
      function setRtpEncodingParameters(_x1, _x10) {
        return _setRtpEncodingParameters.apply(this, arguments);
      }
      return setRtpEncodingParameters;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "getSenderStats",
    value: function () {
      var _getSenderStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee11(localId) {
        return _regenerator().w(function (_context11) {
          while (1) switch (_context11.n) {
            case 0:
              throw new errors_1.UnsupportedError('not implemented');
            case 1:
              return _context11.a(2);
          }
        }, _callee11);
      }));
      function getSenderStats(_x11) {
        return _getSenderStats.apply(this, arguments);
      }
      return getSenderStats;
    }()
  }, {
    key: "sendDataChannel",
    value: function () {
      var _sendDataChannel = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee12(_ref3) {
        var ordered, maxPacketLifeTime, maxRetransmits, label, protocol, options, dataChannel, offer, localSdpObject, offerMediaObject, _this$_forcedLocalDtl2, answer, sctpStreamParameters;
        return _regenerator().w(function (_context12) {
          while (1) switch (_context12.n) {
            case 0:
              ordered = _ref3.ordered, maxPacketLifeTime = _ref3.maxPacketLifeTime, maxRetransmits = _ref3.maxRetransmits, label = _ref3.label, protocol = _ref3.protocol;
              this.assertSendDirection();
              options = {
                negotiated: true,
                id: this._nextSendSctpStreamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmitTime: maxPacketLifeTime,
                // NOTE: Old spec.
                maxRetransmits: maxRetransmits,
                protocol: protocol
              };
              logger.debug('sendDataChannel() [options:%o]', options);
              dataChannel = this._pc.createDataChannel(label, options); // Increase next id.
              this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
              // If this is the first DataChannel we need to create the SDP answer with
              // m=application section.
              if (this._hasDataChannelMediaSection) {
                _context12.n = 5;
                break;
              }
              _context12.n = 1;
              return this._pc.createOffer();
            case 1:
              offer = _context12.v;
              localSdpObject = sdpTransform.parse(offer.sdp);
              offerMediaObject = localSdpObject.media.find(function (m) {
                return m.type === 'application';
              });
              if (this._transportReady) {
                _context12.n = 2;
                break;
              }
              _context12.n = 2;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl2 = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl2 !== void 0 ? _this$_forcedLocalDtl2 : 'client',
                localSdpObject: localSdpObject
              });
            case 2:
              logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context12.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              this._remoteSdp.sendSctpAssociation({
                offerMediaObject: offerMediaObject
              });
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context12.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              this._hasDataChannelMediaSection = true;
            case 5:
              sctpStreamParameters = {
                streamId: options.id,
                ordered: options.ordered,
                maxPacketLifeTime: options.maxPacketLifeTime,
                maxRetransmits: options.maxRetransmits
              };
              return _context12.a(2, {
                dataChannel: dataChannel,
                sctpStreamParameters: sctpStreamParameters
              });
          }
        }, _callee12, this);
      }));
      function sendDataChannel(_x12) {
        return _sendDataChannel.apply(this, arguments);
      }
      return sendDataChannel;
    }()
  }, {
    key: "receive",
    value: function () {
      var _receive = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee13(optionsList) {
        var _this3 = this;
        var results, _iterator2, _step2, options, trackId, kind, rtpParameters, streamId, mid, offer, answer, localSdpObject, _iterator3, _step3, _loop, _this$_forcedLocalDtl3, _iterator4, _step4, _loop2, _t3, _t4;
        return _regenerator().w(function (_context15) {
          while (1) switch (_context15.n) {
            case 0:
              this.assertRecvDirection();
              results = [];
              _iterator2 = _createForOfIteratorHelper(optionsList);
              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  options = _step2.value;
                  trackId = options.trackId, kind = options.kind, rtpParameters = options.rtpParameters, streamId = options.streamId;
                  logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
                  mid = kind;
                  this._remoteSdp.receive({
                    mid: mid,
                    kind: kind,
                    offerRtpParameters: rtpParameters,
                    streamId: streamId !== null && streamId !== void 0 ? streamId : rtpParameters.rtcp.cname,
                    trackId: trackId
                  });
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context15.n = 1;
              return this._pc.setRemoteDescription(offer);
            case 1:
              _context15.n = 2;
              return this._pc.createAnswer();
            case 2:
              answer = _context15.v;
              localSdpObject = sdpTransform.parse(answer.sdp);
              _iterator3 = _createForOfIteratorHelper(optionsList);
              _context15.p = 3;
              _loop = /*#__PURE__*/_regenerator().m(function _loop() {
                var options, kind, rtpParameters, mid, answerMediaObject;
                return _regenerator().w(function (_context13) {
                  while (1) switch (_context13.n) {
                    case 0:
                      options = _step3.value;
                      kind = options.kind, rtpParameters = options.rtpParameters;
                      mid = kind;
                      answerMediaObject = localSdpObject.media.find(function (m) {
                        return String(m.mid) === mid;
                      }); // May need to modify codec parameters in the answer based on codec
                      // parameters in the offer.
                      sdpCommonUtils.applyCodecParameters({
                        offerRtpParameters: rtpParameters,
                        answerMediaObject: answerMediaObject
                      });
                    case 1:
                      return _context13.a(2);
                  }
                }, _loop);
              });
              _iterator3.s();
            case 4:
              if ((_step3 = _iterator3.n()).done) {
                _context15.n = 6;
                break;
              }
              return _context15.d(_regeneratorValues(_loop()), 5);
            case 5:
              _context15.n = 4;
              break;
            case 6:
              _context15.n = 8;
              break;
            case 7:
              _context15.p = 7;
              _t3 = _context15.v;
              _iterator3.e(_t3);
            case 8:
              _context15.p = 8;
              _iterator3.f();
              return _context15.f(8);
            case 9:
              answer = {
                type: 'answer',
                sdp: sdpTransform.write(localSdpObject)
              };
              if (this._transportReady) {
                _context15.n = 10;
                break;
              }
              _context15.n = 10;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl3 = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl3 !== void 0 ? _this$_forcedLocalDtl3 : 'client',
                localSdpObject: localSdpObject
              });
            case 10:
              logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context15.n = 11;
              return this._pc.setLocalDescription(answer);
            case 11:
              _iterator4 = _createForOfIteratorHelper(optionsList);
              _context15.p = 12;
              _loop2 = /*#__PURE__*/_regenerator().m(function _loop2() {
                var _options$streamId;
                var options, kind, trackId, rtpParameters, mid, localId, streamId, stream, track;
                return _regenerator().w(function (_context14) {
                  while (1) switch (_context14.n) {
                    case 0:
                      options = _step4.value;
                      kind = options.kind, trackId = options.trackId, rtpParameters = options.rtpParameters;
                      mid = kind;
                      localId = trackId;
                      streamId = (_options$streamId = options.streamId) !== null && _options$streamId !== void 0 ? _options$streamId : rtpParameters.rtcp.cname;
                      stream = _this3._pc.getRemoteStreams().find(function (s) {
                        return s.id === streamId;
                      });
                      track = stream.getTrackById(localId);
                      if (track) {
                        _context14.n = 1;
                        break;
                      }
                      throw new Error('remote track not found');
                    case 1:
                      // Insert into the map.
                      _this3._mapRecvLocalIdInfo.set(localId, {
                        mid: mid,
                        rtpParameters: rtpParameters
                      });
                      results.push({
                        localId: localId,
                        track: track
                      });
                    case 2:
                      return _context14.a(2);
                  }
                }, _loop2);
              });
              _iterator4.s();
            case 13:
              if ((_step4 = _iterator4.n()).done) {
                _context15.n = 15;
                break;
              }
              return _context15.d(_regeneratorValues(_loop2()), 14);
            case 14:
              _context15.n = 13;
              break;
            case 15:
              _context15.n = 17;
              break;
            case 16:
              _context15.p = 16;
              _t4 = _context15.v;
              _iterator4.e(_t4);
            case 17:
              _context15.p = 17;
              _iterator4.f();
              return _context15.f(17);
            case 18:
              return _context15.a(2, results);
          }
        }, _callee13, this, [[12, 16, 17, 18], [3, 7, 8, 9]]);
      }));
      function receive(_x13) {
        return _receive.apply(this, arguments);
      }
      return receive;
    }()
  }, {
    key: "stopReceiving",
    value: function () {
      var _stopReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee14(localIds) {
        var _iterator5, _step5, _this$_mapRecvLocalId, localId, _ref4, mid, rtpParameters, offer, answer;
        return _regenerator().w(function (_context16) {
          while (1) switch (_context16.n) {
            case 0:
              this.assertRecvDirection();
              _iterator5 = _createForOfIteratorHelper(localIds);
              try {
                for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                  localId = _step5.value;
                  logger.debug('stopReceiving() [localId:%s]', localId);
                  _ref4 = (_this$_mapRecvLocalId = this._mapRecvLocalIdInfo.get(localId)) !== null && _this$_mapRecvLocalId !== void 0 ? _this$_mapRecvLocalId : {}, mid = _ref4.mid, rtpParameters = _ref4.rtpParameters; // Remove from the map.
                  this._mapRecvLocalIdInfo["delete"](localId);
                  this._remoteSdp.planBStopReceiving({
                    mid: mid,
                    offerRtpParameters: rtpParameters
                  });
                }
              } catch (err) {
                _iterator5.e(err);
              } finally {
                _iterator5.f();
              }
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context16.n = 1;
              return this._pc.setRemoteDescription(offer);
            case 1:
              _context16.n = 2;
              return this._pc.createAnswer();
            case 2:
              answer = _context16.v;
              logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context16.n = 3;
              return this._pc.setLocalDescription(answer);
            case 3:
              return _context16.a(2);
          }
        }, _callee14, this);
      }));
      function stopReceiving(_x14) {
        return _stopReceiving.apply(this, arguments);
      }
      return stopReceiving;
    }()
  }, {
    key: "pauseReceiving",
    value: function () {
      var _pauseReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee15(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      localIds) {
        return _regenerator().w(function (_context17) {
          while (1) switch (_context17.n) {
            case 0:
              return _context17.a(2);
          }
        }, _callee15);
      }));
      function pauseReceiving(_x15) {
        return _pauseReceiving.apply(this, arguments);
      }
      return pauseReceiving;
    }()
  }, {
    key: "resumeReceiving",
    value: function () {
      var _resumeReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee16(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      localIds) {
        return _regenerator().w(function (_context18) {
          while (1) switch (_context18.n) {
            case 0:
              return _context18.a(2);
          }
        }, _callee16);
      }));
      function resumeReceiving(_x16) {
        return _resumeReceiving.apply(this, arguments);
      }
      return resumeReceiving;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "getReceiverStats",
    value: function () {
      var _getReceiverStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee17(localId) {
        return _regenerator().w(function (_context19) {
          while (1) switch (_context19.n) {
            case 0:
              throw new errors_1.UnsupportedError('not implemented');
            case 1:
              return _context19.a(2);
          }
        }, _callee17);
      }));
      function getReceiverStats(_x17) {
        return _getReceiverStats.apply(this, arguments);
      }
      return getReceiverStats;
    }()
  }, {
    key: "receiveDataChannel",
    value: function () {
      var _receiveDataChannel = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee18(_ref5) {
        var sctpStreamParameters, label, protocol, streamId, ordered, maxPacketLifeTime, maxRetransmits, options, dataChannel, offer, answer, _this$_forcedLocalDtl4, localSdpObject;
        return _regenerator().w(function (_context20) {
          while (1) switch (_context20.n) {
            case 0:
              sctpStreamParameters = _ref5.sctpStreamParameters, label = _ref5.label, protocol = _ref5.protocol;
              this.assertRecvDirection();
              streamId = sctpStreamParameters.streamId, ordered = sctpStreamParameters.ordered, maxPacketLifeTime = sctpStreamParameters.maxPacketLifeTime, maxRetransmits = sctpStreamParameters.maxRetransmits;
              options = {
                negotiated: true,
                id: streamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmitTime: maxPacketLifeTime,
                // NOTE: Old spec.
                maxRetransmits: maxRetransmits,
                protocol: protocol
              };
              logger.debug('receiveDataChannel() [options:%o]', options);
              dataChannel = this._pc.createDataChannel(label, options); // If this is the first DataChannel we need to create the SDP offer with
              // m=application section.
              if (this._hasDataChannelMediaSection) {
                _context20.n = 5;
                break;
              }
              this._remoteSdp.receiveSctpAssociation({
                oldDataChannelSpec: true
              });
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context20.n = 1;
              return this._pc.setRemoteDescription(offer);
            case 1:
              _context20.n = 2;
              return this._pc.createAnswer();
            case 2:
              answer = _context20.v;
              if (this._transportReady) {
                _context20.n = 3;
                break;
              }
              localSdpObject = sdpTransform.parse(answer.sdp);
              _context20.n = 3;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl4 = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl4 !== void 0 ? _this$_forcedLocalDtl4 : 'client',
                localSdpObject: localSdpObject
              });
            case 3:
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context20.n = 4;
              return this._pc.setLocalDescription(answer);
            case 4:
              this._hasDataChannelMediaSection = true;
            case 5:
              return _context20.a(2, {
                dataChannel: dataChannel
              });
          }
        }, _callee18, this);
      }));
      function receiveDataChannel(_x18) {
        return _receiveDataChannel.apply(this, arguments);
      }
      return receiveDataChannel;
    }()
  }, {
    key: "setupTransport",
    value: function () {
      var _setupTransport = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee19(_ref6) {
        var _this4 = this;
        var localDtlsRole, localSdpObject, dtlsParameters;
        return _regenerator().w(function (_context21) {
          while (1) switch (_context21.n) {
            case 0:
              localDtlsRole = _ref6.localDtlsRole, localSdpObject = _ref6.localSdpObject;
              if (!localSdpObject) {
                localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
              }
              // Get our local DTLS parameters.
              dtlsParameters = sdpCommonUtils.extractDtlsParameters({
                sdpObject: localSdpObject
              }); // Set our DTLS role.
              dtlsParameters.role = localDtlsRole;
              // Update the remote DTLS role in the SDP.
              this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
              // Need to tell the remote transport about our parameters.
              _context21.n = 1;
              return new Promise(function (resolve, reject) {
                _this4.safeEmit('@connect', {
                  dtlsParameters: dtlsParameters
                }, resolve, reject);
              });
            case 1:
              this._transportReady = true;
            case 2:
              return _context21.a(2);
          }
        }, _callee19, this);
      }));
      function setupTransport(_x19) {
        return _setupTransport.apply(this, arguments);
      }
      return setupTransport;
    }()
  }, {
    key: "assertSendDirection",
    value: function assertSendDirection() {
      if (this._direction !== 'send') {
        throw new Error('method can just be called for handlers with "send" direction');
      }
    }
  }, {
    key: "assertRecvDirection",
    value: function assertRecvDirection() {
      if (this._direction !== 'recv') {
        throw new Error('method can just be called for handlers with "recv" direction');
      }
    }
  }], [{
    key: "createFactory",
    value:
    /**
     * Creates a factory function.
     */
    function createFactory() {
      return function () {
        return new Chrome55();
      };
    }
  }]);
}(HandlerInterface_1.HandlerInterface);
exports.Chrome55 = Chrome55;

},{"../Logger":39,"../errors":45,"../ortc":68,"../utils":72,"./HandlerInterface":55,"./sdp/RemoteSdp":63,"./sdp/commonUtils":64,"./sdp/planBUtils":65,"sdp-transform":76}],48:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorValues(e) { if (null != e) { var t = e["function" == typeof Symbol && Symbol.iterator || "@@iterator"], r = 0; if (t) return t.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) return { next: function next() { return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e }; } }; } throw new TypeError(_typeof(e) + " is not iterable"); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o("next", 0), o("throw", 1), o("return", 2); } }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Chrome67 = void 0;
var sdpTransform = require("sdp-transform");
var Logger_1 = require("../Logger");
var utils = require("../utils");
var ortc = require("../ortc");
var sdpCommonUtils = require("./sdp/commonUtils");
var sdpPlanBUtils = require("./sdp/planBUtils");
var HandlerInterface_1 = require("./HandlerInterface");
var RemoteSdp_1 = require("./sdp/RemoteSdp");
var logger = new Logger_1.Logger('Chrome67');
var NAME = 'Chrome67';
var SCTP_NUM_STREAMS = {
  OS: 1024,
  MIS: 1024
};
var Chrome67 = /*#__PURE__*/function (_HandlerInterface_1$H) {
  function Chrome67() {
    var _this;
    _classCallCheck(this, Chrome67);
    _this = _callSuper(this, Chrome67);
    // Handler direction.
    _defineProperty(_this, "_direction", void 0);
    // Remote SDP handler.
    _defineProperty(_this, "_remoteSdp", void 0);
    // Generic sending RTP parameters for audio and video.
    _defineProperty(_this, "_sendingRtpParametersByKind", void 0);
    // Generic sending RTP parameters for audio and video suitable for the SDP
    // remote answer.
    _defineProperty(_this, "_sendingRemoteRtpParametersByKind", void 0);
    // Initial server side DTLS role. If not 'auto', it will force the opposite
    // value in client side.
    _defineProperty(_this, "_forcedLocalDtlsRole", void 0);
    // RTCPeerConnection instance.
    _defineProperty(_this, "_pc", void 0);
    // Local stream for sending.
    _defineProperty(_this, "_sendStream", new MediaStream());
    // Map of RTCRtpSender indexed by localId.
    _defineProperty(_this, "_mapSendLocalIdRtpSender", new Map());
    // Next sending localId.
    _defineProperty(_this, "_nextSendLocalId", 0);
    // Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.
    // Value is an Object with mid, rtpParameters and rtpReceiver.
    _defineProperty(_this, "_mapRecvLocalIdInfo", new Map());
    // Whether a DataChannel m=application section has been created.
    _defineProperty(_this, "_hasDataChannelMediaSection", false);
    // Sending DataChannel id value counter. Incremented for each new DataChannel.
    _defineProperty(_this, "_nextSendSctpStreamId", 0);
    // Got transport local and remote parameters.
    _defineProperty(_this, "_transportReady", false);
    return _this;
  }
  _inherits(Chrome67, _HandlerInterface_1$H);
  return _createClass(Chrome67, [{
    key: "name",
    get: function get() {
      return NAME;
    }
  }, {
    key: "close",
    value: function close() {
      logger.debug('close()');
      // Close RTCPeerConnection.
      if (this._pc) {
        try {
          this._pc.close();
        } catch (error) {}
      }
      this.emit('@close');
    }
  }, {
    key: "getNativeRtpCapabilities",
    value: function () {
      var _getNativeRtpCapabilities = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {
        var pc, offer, sdpObject, nativeRtpCapabilities, _t;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              logger.debug('getNativeRtpCapabilities()');
              pc = new RTCPeerConnection({
                iceServers: [],
                iceTransportPolicy: 'all',
                bundlePolicy: 'max-bundle',
                rtcpMuxPolicy: 'require',
                sdpSemantics: 'plan-b'
              });
              _context.p = 1;
              _context.n = 2;
              return pc.createOffer({
                offerToReceiveAudio: true,
                offerToReceiveVideo: true
              });
            case 2:
              offer = _context.v;
              try {
                pc.close();
              } catch (error) {}
              sdpObject = sdpTransform.parse(offer.sdp);
              nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject: sdpObject
              });
              return _context.a(2, nativeRtpCapabilities);
            case 3:
              _context.p = 3;
              _t = _context.v;
              try {
                pc.close();
              } catch (error2) {}
              throw _t;
            case 4:
              return _context.a(2);
          }
        }, _callee, null, [[1, 3]]);
      }));
      function getNativeRtpCapabilities() {
        return _getNativeRtpCapabilities.apply(this, arguments);
      }
      return getNativeRtpCapabilities;
    }()
  }, {
    key: "getNativeSctpCapabilities",
    value: function () {
      var _getNativeSctpCapabilities = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2() {
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.n) {
            case 0:
              logger.debug('getNativeSctpCapabilities()');
              return _context2.a(2, {
                numStreams: SCTP_NUM_STREAMS
              });
          }
        }, _callee2);
      }));
      function getNativeSctpCapabilities() {
        return _getNativeSctpCapabilities.apply(this, arguments);
      }
      return getNativeSctpCapabilities;
    }()
  }, {
    key: "run",
    value: function run(_ref) {
      var _this2 = this;
      var direction = _ref.direction,
        iceParameters = _ref.iceParameters,
        iceCandidates = _ref.iceCandidates,
        dtlsParameters = _ref.dtlsParameters,
        sctpParameters = _ref.sctpParameters,
        iceServers = _ref.iceServers,
        iceTransportPolicy = _ref.iceTransportPolicy,
        additionalSettings = _ref.additionalSettings,
        proprietaryConstraints = _ref.proprietaryConstraints,
        extendedRtpCapabilities = _ref.extendedRtpCapabilities;
      logger.debug('run()');
      this._direction = direction;
      this._remoteSdp = new RemoteSdp_1.RemoteSdp({
        iceParameters: iceParameters,
        iceCandidates: iceCandidates,
        dtlsParameters: dtlsParameters,
        sctpParameters: sctpParameters,
        planB: true
      });
      this._sendingRtpParametersByKind = {
        audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
        video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
      };
      this._sendingRemoteRtpParametersByKind = {
        audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
        video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)
      };
      if (dtlsParameters.role && dtlsParameters.role !== 'auto') {
        this._forcedLocalDtlsRole = dtlsParameters.role === 'server' ? 'client' : 'server';
      }
      this._pc = new RTCPeerConnection(_objectSpread({
        iceServers: iceServers !== null && iceServers !== void 0 ? iceServers : [],
        iceTransportPolicy: iceTransportPolicy !== null && iceTransportPolicy !== void 0 ? iceTransportPolicy : 'all',
        bundlePolicy: 'max-bundle',
        rtcpMuxPolicy: 'require',
        sdpSemantics: 'plan-b'
      }, additionalSettings), proprietaryConstraints);
      this._pc.addEventListener('icegatheringstatechange', function () {
        _this2.emit('@icegatheringstatechange', _this2._pc.iceGatheringState);
      });
      this._pc.addEventListener('icecandidateerror', function (event) {
        _this2.emit('@icecandidateerror', event);
      });
      if (this._pc.connectionState) {
        this._pc.addEventListener('connectionstatechange', function () {
          _this2.emit('@connectionstatechange', _this2._pc.connectionState);
        });
      } else {
        this._pc.addEventListener('iceconnectionstatechange', function () {
          logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
          switch (_this2._pc.iceConnectionState) {
            case 'checking':
              {
                _this2.emit('@connectionstatechange', 'connecting');
                break;
              }
            case 'connected':
            case 'completed':
              {
                _this2.emit('@connectionstatechange', 'connected');
                break;
              }
            case 'failed':
              {
                _this2.emit('@connectionstatechange', 'failed');
                break;
              }
            case 'disconnected':
              {
                _this2.emit('@connectionstatechange', 'disconnected');
                break;
              }
            case 'closed':
              {
                _this2.emit('@connectionstatechange', 'closed');
                break;
              }
          }
        });
      }
    }
  }, {
    key: "updateIceServers",
    value: function () {
      var _updateIceServers = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(iceServers) {
        var configuration;
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.n) {
            case 0:
              logger.debug('updateIceServers()');
              configuration = this._pc.getConfiguration();
              configuration.iceServers = iceServers;
              this._pc.setConfiguration(configuration);
            case 1:
              return _context3.a(2);
          }
        }, _callee3, this);
      }));
      function updateIceServers(_x) {
        return _updateIceServers.apply(this, arguments);
      }
      return updateIceServers;
    }()
  }, {
    key: "restartIce",
    value: function () {
      var _restartIce = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(iceParameters) {
        var offer, answer, _offer, _answer;
        return _regenerator().w(function (_context4) {
          while (1) switch (_context4.n) {
            case 0:
              logger.debug('restartIce()');
              // Provide the remote SDP handler with new remote ICE parameters.
              this._remoteSdp.updateIceParameters(iceParameters);
              if (this._transportReady) {
                _context4.n = 1;
                break;
              }
              return _context4.a(2);
            case 1:
              if (!(this._direction === 'send')) {
                _context4.n = 5;
                break;
              }
              _context4.n = 2;
              return this._pc.createOffer({
                iceRestart: true
              });
            case 2:
              offer = _context4.v;
              logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context4.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context4.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              _context4.n = 8;
              break;
            case 5:
              _offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', _offer);
              _context4.n = 6;
              return this._pc.setRemoteDescription(_offer);
            case 6:
              _context4.n = 7;
              return this._pc.createAnswer();
            case 7:
              _answer = _context4.v;
              logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', _answer);
              _context4.n = 8;
              return this._pc.setLocalDescription(_answer);
            case 8:
              return _context4.a(2);
          }
        }, _callee4, this);
      }));
      function restartIce(_x2) {
        return _restartIce.apply(this, arguments);
      }
      return restartIce;
    }()
  }, {
    key: "getTransportStats",
    value: function () {
      var _getTransportStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5() {
        return _regenerator().w(function (_context5) {
          while (1) switch (_context5.n) {
            case 0:
              return _context5.a(2, this._pc.getStats());
          }
        }, _callee5, this);
      }));
      function getTransportStats() {
        return _getTransportStats.apply(this, arguments);
      }
      return getTransportStats;
    }()
  }, {
    key: "send",
    value: function () {
      var _send = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6(_ref2) {
        var track, encodings, codecOptions, codec, offer, localSdpObject, offerMediaObject, sendingRtpParameters, sendingRemoteRtpParameters, _this$_forcedLocalDtl, idx, _iterator, _step, encoding, answer, localId, rtpSender;
        return _regenerator().w(function (_context6) {
          while (1) switch (_context6.n) {
            case 0:
              track = _ref2.track, encodings = _ref2.encodings, codecOptions = _ref2.codecOptions, codec = _ref2.codec;
              this.assertSendDirection();
              logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
              if (codec) {
                logger.warn('send() | codec selection is not available in %s handler', this.name);
              }
              this._sendStream.addTrack(track);
              this._pc.addTrack(track, this._sendStream);
              _context6.n = 1;
              return this._pc.createOffer();
            case 1:
              offer = _context6.v;
              localSdpObject = sdpTransform.parse(offer.sdp); // @ts-expect-error --- sdpTransform.SessionDescription type doesn't
              // define extmapAllowMixed field.
              if (localSdpObject.extmapAllowMixed) {
                this._remoteSdp.setSessionExtmapAllowMixed();
              }
              sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
              sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs);
              sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
              sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);
              if (this._transportReady) {
                _context6.n = 2;
                break;
              }
              _context6.n = 2;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl !== void 0 ? _this$_forcedLocalDtl : 'client',
                localSdpObject: localSdpObject
              });
            case 2:
              if (track.kind === 'video' && encodings && encodings.length > 1) {
                logger.debug('send() | enabling simulcast');
                localSdpObject = sdpTransform.parse(offer.sdp);
                offerMediaObject = localSdpObject.media.find(function (m) {
                  return m.type === 'video';
                });
                sdpPlanBUtils.addLegacySimulcast({
                  offerMediaObject: offerMediaObject,
                  track: track,
                  numStreams: encodings.length
                });
                offer = {
                  type: 'offer',
                  sdp: sdpTransform.write(localSdpObject)
                };
              }
              logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context6.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
              offerMediaObject = localSdpObject.media.find(function (m) {
                return m.type === track.kind;
              });
              // Set RTCP CNAME.
              sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
                offerMediaObject: offerMediaObject
              });
              // Set RTP encodings.
              sendingRtpParameters.encodings = sdpPlanBUtils.getRtpEncodings({
                offerMediaObject: offerMediaObject,
                track: track
              });
              // Complete encodings with given values.
              if (encodings) {
                for (idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
                  if (encodings[idx]) {
                    Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
                  }
                }
              }
              // If VP8 and there is effective simulcast, add scalabilityMode to each
              // encoding.
              if (sendingRtpParameters.encodings.length > 1 && sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8') {
                _iterator = _createForOfIteratorHelper(sendingRtpParameters.encodings);
                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    encoding = _step.value;
                    encoding.scalabilityMode = 'L1T3';
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
              }
              this._remoteSdp.send({
                offerMediaObject: offerMediaObject,
                offerRtpParameters: sendingRtpParameters,
                answerRtpParameters: sendingRemoteRtpParameters,
                codecOptions: codecOptions
              });
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context6.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              localId = String(this._nextSendLocalId);
              this._nextSendLocalId++;
              rtpSender = this._pc.getSenders().find(function (s) {
                return s.track === track;
              }); // Insert into the map.
              this._mapSendLocalIdRtpSender.set(localId, rtpSender);
              return _context6.a(2, {
                localId: localId,
                rtpParameters: sendingRtpParameters,
                rtpSender: rtpSender
              });
          }
        }, _callee6, this);
      }));
      function send(_x3) {
        return _send.apply(this, arguments);
      }
      return send;
    }()
  }, {
    key: "stopSending",
    value: function () {
      var _stopSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7(localId) {
        var rtpSender, offer, answer, _t2;
        return _regenerator().w(function (_context7) {
          while (1) switch (_context7.n) {
            case 0:
              this.assertSendDirection();
              logger.debug('stopSending() [localId:%s]', localId);
              rtpSender = this._mapSendLocalIdRtpSender.get(localId);
              if (rtpSender) {
                _context7.n = 1;
                break;
              }
              throw new Error('associated RTCRtpSender not found');
            case 1:
              this._pc.removeTrack(rtpSender);
              if (rtpSender.track) {
                this._sendStream.removeTrack(rtpSender.track);
              }
              this._mapSendLocalIdRtpSender["delete"](localId);
              _context7.n = 2;
              return this._pc.createOffer();
            case 2:
              offer = _context7.v;
              logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context7.p = 3;
              _context7.n = 4;
              return this._pc.setLocalDescription(offer);
            case 4:
              _context7.n = 7;
              break;
            case 5:
              _context7.p = 5;
              _t2 = _context7.v;
              if (!(this._sendStream.getTracks().length === 0)) {
                _context7.n = 6;
                break;
              }
              logger.warn('stopSending() | ignoring expected error due no sending tracks: %s', _t2.toString());
              return _context7.a(2);
            case 6:
              throw _t2;
            case 7:
              if (!(this._pc.signalingState === 'stable')) {
                _context7.n = 8;
                break;
              }
              return _context7.a(2);
            case 8:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context7.n = 9;
              return this._pc.setRemoteDescription(answer);
            case 9:
              return _context7.a(2);
          }
        }, _callee7, this, [[3, 5]]);
      }));
      function stopSending(_x4) {
        return _stopSending.apply(this, arguments);
      }
      return stopSending;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "pauseSending",
    value: function () {
      var _pauseSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8(localId) {
        return _regenerator().w(function (_context8) {
          while (1) switch (_context8.n) {
            case 0:
              return _context8.a(2);
          }
        }, _callee8);
      }));
      function pauseSending(_x5) {
        return _pauseSending.apply(this, arguments);
      }
      return pauseSending;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "resumeSending",
    value: function () {
      var _resumeSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee9(localId) {
        return _regenerator().w(function (_context9) {
          while (1) switch (_context9.n) {
            case 0:
              return _context9.a(2);
          }
        }, _callee9);
      }));
      function resumeSending(_x6) {
        return _resumeSending.apply(this, arguments);
      }
      return resumeSending;
    }()
  }, {
    key: "replaceTrack",
    value: function () {
      var _replaceTrack = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee0(localId, track) {
        var rtpSender, oldTrack;
        return _regenerator().w(function (_context0) {
          while (1) switch (_context0.n) {
            case 0:
              this.assertSendDirection();
              if (track) {
                logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
              } else {
                logger.debug('replaceTrack() [localId:%s, no track]', localId);
              }
              rtpSender = this._mapSendLocalIdRtpSender.get(localId);
              if (rtpSender) {
                _context0.n = 1;
                break;
              }
              throw new Error('associated RTCRtpSender not found');
            case 1:
              oldTrack = rtpSender.track;
              _context0.n = 2;
              return rtpSender.replaceTrack(track);
            case 2:
              // Remove the old track from the local stream.
              if (oldTrack) {
                this._sendStream.removeTrack(oldTrack);
              }
              // Add the new track to the local stream.
              if (track) {
                this._sendStream.addTrack(track);
              }
            case 3:
              return _context0.a(2);
          }
        }, _callee0, this);
      }));
      function replaceTrack(_x7, _x8) {
        return _replaceTrack.apply(this, arguments);
      }
      return replaceTrack;
    }()
  }, {
    key: "setMaxSpatialLayer",
    value: function () {
      var _setMaxSpatialLayer = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee1(localId, spatialLayer) {
        var rtpSender, parameters;
        return _regenerator().w(function (_context1) {
          while (1) switch (_context1.n) {
            case 0:
              this.assertSendDirection();
              logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
              rtpSender = this._mapSendLocalIdRtpSender.get(localId);
              if (rtpSender) {
                _context1.n = 1;
                break;
              }
              throw new Error('associated RTCRtpSender not found');
            case 1:
              parameters = rtpSender.getParameters();
              parameters.encodings.forEach(function (encoding, idx) {
                if (idx <= spatialLayer) {
                  encoding.active = true;
                } else {
                  encoding.active = false;
                }
              });
              _context1.n = 2;
              return rtpSender.setParameters(parameters);
            case 2:
              return _context1.a(2);
          }
        }, _callee1, this);
      }));
      function setMaxSpatialLayer(_x9, _x0) {
        return _setMaxSpatialLayer.apply(this, arguments);
      }
      return setMaxSpatialLayer;
    }()
  }, {
    key: "setRtpEncodingParameters",
    value: function () {
      var _setRtpEncodingParameters = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee10(localId, params) {
        var rtpSender, parameters;
        return _regenerator().w(function (_context10) {
          while (1) switch (_context10.n) {
            case 0:
              this.assertSendDirection();
              logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
              rtpSender = this._mapSendLocalIdRtpSender.get(localId);
              if (rtpSender) {
                _context10.n = 1;
                break;
              }
              throw new Error('associated RTCRtpSender not found');
            case 1:
              parameters = rtpSender.getParameters();
              parameters.encodings.forEach(function (encoding, idx) {
                parameters.encodings[idx] = _objectSpread(_objectSpread({}, encoding), params);
              });
              _context10.n = 2;
              return rtpSender.setParameters(parameters);
            case 2:
              return _context10.a(2);
          }
        }, _callee10, this);
      }));
      function setRtpEncodingParameters(_x1, _x10) {
        return _setRtpEncodingParameters.apply(this, arguments);
      }
      return setRtpEncodingParameters;
    }()
  }, {
    key: "getSenderStats",
    value: function () {
      var _getSenderStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee11(localId) {
        var rtpSender;
        return _regenerator().w(function (_context11) {
          while (1) switch (_context11.n) {
            case 0:
              this.assertSendDirection();
              rtpSender = this._mapSendLocalIdRtpSender.get(localId);
              if (rtpSender) {
                _context11.n = 1;
                break;
              }
              throw new Error('associated RTCRtpSender not found');
            case 1:
              return _context11.a(2, rtpSender.getStats());
          }
        }, _callee11, this);
      }));
      function getSenderStats(_x11) {
        return _getSenderStats.apply(this, arguments);
      }
      return getSenderStats;
    }()
  }, {
    key: "sendDataChannel",
    value: function () {
      var _sendDataChannel = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee12(_ref3) {
        var ordered, maxPacketLifeTime, maxRetransmits, label, protocol, options, dataChannel, offer, localSdpObject, offerMediaObject, _this$_forcedLocalDtl2, answer, sctpStreamParameters;
        return _regenerator().w(function (_context12) {
          while (1) switch (_context12.n) {
            case 0:
              ordered = _ref3.ordered, maxPacketLifeTime = _ref3.maxPacketLifeTime, maxRetransmits = _ref3.maxRetransmits, label = _ref3.label, protocol = _ref3.protocol;
              this.assertSendDirection();
              options = {
                negotiated: true,
                id: this._nextSendSctpStreamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmitTime: maxPacketLifeTime,
                // NOTE: Old spec.
                maxRetransmits: maxRetransmits,
                protocol: protocol
              };
              logger.debug('sendDataChannel() [options:%o]', options);
              dataChannel = this._pc.createDataChannel(label, options); // Increase next id.
              this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
              // If this is the first DataChannel we need to create the SDP answer with
              // m=application section.
              if (this._hasDataChannelMediaSection) {
                _context12.n = 5;
                break;
              }
              _context12.n = 1;
              return this._pc.createOffer();
            case 1:
              offer = _context12.v;
              localSdpObject = sdpTransform.parse(offer.sdp);
              offerMediaObject = localSdpObject.media.find(function (m) {
                return m.type === 'application';
              });
              if (this._transportReady) {
                _context12.n = 2;
                break;
              }
              _context12.n = 2;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl2 = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl2 !== void 0 ? _this$_forcedLocalDtl2 : 'client',
                localSdpObject: localSdpObject
              });
            case 2:
              logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context12.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              this._remoteSdp.sendSctpAssociation({
                offerMediaObject: offerMediaObject
              });
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context12.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              this._hasDataChannelMediaSection = true;
            case 5:
              sctpStreamParameters = {
                streamId: options.id,
                ordered: options.ordered,
                maxPacketLifeTime: options.maxPacketLifeTime,
                maxRetransmits: options.maxRetransmits
              };
              return _context12.a(2, {
                dataChannel: dataChannel,
                sctpStreamParameters: sctpStreamParameters
              });
          }
        }, _callee12, this);
      }));
      function sendDataChannel(_x12) {
        return _sendDataChannel.apply(this, arguments);
      }
      return sendDataChannel;
    }()
  }, {
    key: "receive",
    value: function () {
      var _receive = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee13(optionsList) {
        var _this3 = this;
        var results, _iterator2, _step2, options, trackId, kind, rtpParameters, streamId, mid, offer, answer, localSdpObject, _iterator3, _step3, _loop, _this$_forcedLocalDtl3, _iterator4, _step4, _loop2, _t3, _t4;
        return _regenerator().w(function (_context15) {
          while (1) switch (_context15.n) {
            case 0:
              this.assertRecvDirection();
              results = [];
              _iterator2 = _createForOfIteratorHelper(optionsList);
              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  options = _step2.value;
                  trackId = options.trackId, kind = options.kind, rtpParameters = options.rtpParameters, streamId = options.streamId;
                  logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
                  mid = kind;
                  this._remoteSdp.receive({
                    mid: mid,
                    kind: kind,
                    offerRtpParameters: rtpParameters,
                    streamId: streamId !== null && streamId !== void 0 ? streamId : rtpParameters.rtcp.cname,
                    trackId: trackId
                  });
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context15.n = 1;
              return this._pc.setRemoteDescription(offer);
            case 1:
              _context15.n = 2;
              return this._pc.createAnswer();
            case 2:
              answer = _context15.v;
              localSdpObject = sdpTransform.parse(answer.sdp);
              _iterator3 = _createForOfIteratorHelper(optionsList);
              _context15.p = 3;
              _loop = /*#__PURE__*/_regenerator().m(function _loop() {
                var options, kind, rtpParameters, mid, answerMediaObject;
                return _regenerator().w(function (_context13) {
                  while (1) switch (_context13.n) {
                    case 0:
                      options = _step3.value;
                      kind = options.kind, rtpParameters = options.rtpParameters;
                      mid = kind;
                      answerMediaObject = localSdpObject.media.find(function (m) {
                        return String(m.mid) === mid;
                      }); // May need to modify codec parameters in the answer based on codec
                      // parameters in the offer.
                      sdpCommonUtils.applyCodecParameters({
                        offerRtpParameters: rtpParameters,
                        answerMediaObject: answerMediaObject
                      });
                    case 1:
                      return _context13.a(2);
                  }
                }, _loop);
              });
              _iterator3.s();
            case 4:
              if ((_step3 = _iterator3.n()).done) {
                _context15.n = 6;
                break;
              }
              return _context15.d(_regeneratorValues(_loop()), 5);
            case 5:
              _context15.n = 4;
              break;
            case 6:
              _context15.n = 8;
              break;
            case 7:
              _context15.p = 7;
              _t3 = _context15.v;
              _iterator3.e(_t3);
            case 8:
              _context15.p = 8;
              _iterator3.f();
              return _context15.f(8);
            case 9:
              answer = {
                type: 'answer',
                sdp: sdpTransform.write(localSdpObject)
              };
              if (this._transportReady) {
                _context15.n = 10;
                break;
              }
              _context15.n = 10;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl3 = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl3 !== void 0 ? _this$_forcedLocalDtl3 : 'client',
                localSdpObject: localSdpObject
              });
            case 10:
              logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context15.n = 11;
              return this._pc.setLocalDescription(answer);
            case 11:
              _iterator4 = _createForOfIteratorHelper(optionsList);
              _context15.p = 12;
              _loop2 = /*#__PURE__*/_regenerator().m(function _loop2() {
                var options, kind, trackId, rtpParameters, localId, mid, rtpReceiver;
                return _regenerator().w(function (_context14) {
                  while (1) switch (_context14.n) {
                    case 0:
                      options = _step4.value;
                      kind = options.kind, trackId = options.trackId, rtpParameters = options.rtpParameters;
                      localId = trackId;
                      mid = kind;
                      rtpReceiver = _this3._pc.getReceivers().find(function (r) {
                        return r.track && r.track.id === localId;
                      });
                      if (rtpReceiver) {
                        _context14.n = 1;
                        break;
                      }
                      throw new Error('new RTCRtpReceiver not');
                    case 1:
                      // Insert into the map.
                      _this3._mapRecvLocalIdInfo.set(localId, {
                        mid: mid,
                        rtpParameters: rtpParameters,
                        rtpReceiver: rtpReceiver
                      });
                      results.push({
                        localId: localId,
                        track: rtpReceiver.track,
                        rtpReceiver: rtpReceiver
                      });
                    case 2:
                      return _context14.a(2);
                  }
                }, _loop2);
              });
              _iterator4.s();
            case 13:
              if ((_step4 = _iterator4.n()).done) {
                _context15.n = 15;
                break;
              }
              return _context15.d(_regeneratorValues(_loop2()), 14);
            case 14:
              _context15.n = 13;
              break;
            case 15:
              _context15.n = 17;
              break;
            case 16:
              _context15.p = 16;
              _t4 = _context15.v;
              _iterator4.e(_t4);
            case 17:
              _context15.p = 17;
              _iterator4.f();
              return _context15.f(17);
            case 18:
              return _context15.a(2, results);
          }
        }, _callee13, this, [[12, 16, 17, 18], [3, 7, 8, 9]]);
      }));
      function receive(_x13) {
        return _receive.apply(this, arguments);
      }
      return receive;
    }()
  }, {
    key: "stopReceiving",
    value: function () {
      var _stopReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee14(localIds) {
        var _iterator5, _step5, _this$_mapRecvLocalId, localId, _ref4, mid, rtpParameters, offer, answer;
        return _regenerator().w(function (_context16) {
          while (1) switch (_context16.n) {
            case 0:
              this.assertRecvDirection();
              _iterator5 = _createForOfIteratorHelper(localIds);
              try {
                for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                  localId = _step5.value;
                  logger.debug('stopReceiving() [localId:%s]', localId);
                  _ref4 = (_this$_mapRecvLocalId = this._mapRecvLocalIdInfo.get(localId)) !== null && _this$_mapRecvLocalId !== void 0 ? _this$_mapRecvLocalId : {}, mid = _ref4.mid, rtpParameters = _ref4.rtpParameters; // Remove from the map.
                  this._mapRecvLocalIdInfo["delete"](localId);
                  this._remoteSdp.planBStopReceiving({
                    mid: mid,
                    offerRtpParameters: rtpParameters
                  });
                }
              } catch (err) {
                _iterator5.e(err);
              } finally {
                _iterator5.f();
              }
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context16.n = 1;
              return this._pc.setRemoteDescription(offer);
            case 1:
              _context16.n = 2;
              return this._pc.createAnswer();
            case 2:
              answer = _context16.v;
              logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context16.n = 3;
              return this._pc.setLocalDescription(answer);
            case 3:
              return _context16.a(2);
          }
        }, _callee14, this);
      }));
      function stopReceiving(_x14) {
        return _stopReceiving.apply(this, arguments);
      }
      return stopReceiving;
    }()
  }, {
    key: "pauseReceiving",
    value: function () {
      var _pauseReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee15(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      localIds) {
        return _regenerator().w(function (_context17) {
          while (1) switch (_context17.n) {
            case 0:
              return _context17.a(2);
          }
        }, _callee15);
      }));
      function pauseReceiving(_x15) {
        return _pauseReceiving.apply(this, arguments);
      }
      return pauseReceiving;
    }()
  }, {
    key: "resumeReceiving",
    value: function () {
      var _resumeReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee16(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      localIds) {
        return _regenerator().w(function (_context18) {
          while (1) switch (_context18.n) {
            case 0:
              return _context18.a(2);
          }
        }, _callee16);
      }));
      function resumeReceiving(_x16) {
        return _resumeReceiving.apply(this, arguments);
      }
      return resumeReceiving;
    }()
  }, {
    key: "getReceiverStats",
    value: function () {
      var _getReceiverStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee17(localId) {
        var _this$_mapRecvLocalId2;
        var _ref5, rtpReceiver;
        return _regenerator().w(function (_context19) {
          while (1) switch (_context19.n) {
            case 0:
              this.assertRecvDirection();
              _ref5 = (_this$_mapRecvLocalId2 = this._mapRecvLocalIdInfo.get(localId)) !== null && _this$_mapRecvLocalId2 !== void 0 ? _this$_mapRecvLocalId2 : {}, rtpReceiver = _ref5.rtpReceiver;
              if (rtpReceiver) {
                _context19.n = 1;
                break;
              }
              throw new Error('associated RTCRtpReceiver not found');
            case 1:
              return _context19.a(2, rtpReceiver.getStats());
          }
        }, _callee17, this);
      }));
      function getReceiverStats(_x17) {
        return _getReceiverStats.apply(this, arguments);
      }
      return getReceiverStats;
    }()
  }, {
    key: "receiveDataChannel",
    value: function () {
      var _receiveDataChannel = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee18(_ref6) {
        var sctpStreamParameters, label, protocol, streamId, ordered, maxPacketLifeTime, maxRetransmits, options, dataChannel, offer, answer, _this$_forcedLocalDtl4, localSdpObject;
        return _regenerator().w(function (_context20) {
          while (1) switch (_context20.n) {
            case 0:
              sctpStreamParameters = _ref6.sctpStreamParameters, label = _ref6.label, protocol = _ref6.protocol;
              this.assertRecvDirection();
              streamId = sctpStreamParameters.streamId, ordered = sctpStreamParameters.ordered, maxPacketLifeTime = sctpStreamParameters.maxPacketLifeTime, maxRetransmits = sctpStreamParameters.maxRetransmits;
              options = {
                negotiated: true,
                id: streamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmitTime: maxPacketLifeTime,
                // NOTE: Old spec.
                maxRetransmits: maxRetransmits,
                protocol: protocol
              };
              logger.debug('receiveDataChannel() [options:%o]', options);
              dataChannel = this._pc.createDataChannel(label, options); // If this is the first DataChannel we need to create the SDP offer with
              // m=application section.
              if (this._hasDataChannelMediaSection) {
                _context20.n = 5;
                break;
              }
              this._remoteSdp.receiveSctpAssociation({
                oldDataChannelSpec: true
              });
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context20.n = 1;
              return this._pc.setRemoteDescription(offer);
            case 1:
              _context20.n = 2;
              return this._pc.createAnswer();
            case 2:
              answer = _context20.v;
              if (this._transportReady) {
                _context20.n = 3;
                break;
              }
              localSdpObject = sdpTransform.parse(answer.sdp);
              _context20.n = 3;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl4 = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl4 !== void 0 ? _this$_forcedLocalDtl4 : 'client',
                localSdpObject: localSdpObject
              });
            case 3:
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context20.n = 4;
              return this._pc.setLocalDescription(answer);
            case 4:
              this._hasDataChannelMediaSection = true;
            case 5:
              return _context20.a(2, {
                dataChannel: dataChannel
              });
          }
        }, _callee18, this);
      }));
      function receiveDataChannel(_x18) {
        return _receiveDataChannel.apply(this, arguments);
      }
      return receiveDataChannel;
    }()
  }, {
    key: "setupTransport",
    value: function () {
      var _setupTransport = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee19(_ref7) {
        var _this4 = this;
        var localDtlsRole, localSdpObject, dtlsParameters;
        return _regenerator().w(function (_context21) {
          while (1) switch (_context21.n) {
            case 0:
              localDtlsRole = _ref7.localDtlsRole, localSdpObject = _ref7.localSdpObject;
              if (!localSdpObject) {
                localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
              }
              // Get our local DTLS parameters.
              dtlsParameters = sdpCommonUtils.extractDtlsParameters({
                sdpObject: localSdpObject
              }); // Set our DTLS role.
              dtlsParameters.role = localDtlsRole;
              // Update the remote DTLS role in the SDP.
              this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
              // Need to tell the remote transport about our parameters.
              _context21.n = 1;
              return new Promise(function (resolve, reject) {
                _this4.safeEmit('@connect', {
                  dtlsParameters: dtlsParameters
                }, resolve, reject);
              });
            case 1:
              this._transportReady = true;
            case 2:
              return _context21.a(2);
          }
        }, _callee19, this);
      }));
      function setupTransport(_x19) {
        return _setupTransport.apply(this, arguments);
      }
      return setupTransport;
    }()
  }, {
    key: "assertSendDirection",
    value: function assertSendDirection() {
      if (this._direction !== 'send') {
        throw new Error('method can just be called for handlers with "send" direction');
      }
    }
  }, {
    key: "assertRecvDirection",
    value: function assertRecvDirection() {
      if (this._direction !== 'recv') {
        throw new Error('method can just be called for handlers with "recv" direction');
      }
    }
  }], [{
    key: "createFactory",
    value:
    /**
     * Creates a factory function.
     */
    function createFactory() {
      return function () {
        return new Chrome67();
      };
    }
  }]);
}(HandlerInterface_1.HandlerInterface);
exports.Chrome67 = Chrome67;

},{"../Logger":39,"../ortc":68,"../utils":72,"./HandlerInterface":55,"./sdp/RemoteSdp":63,"./sdp/commonUtils":64,"./sdp/planBUtils":65,"sdp-transform":76}],49:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorValues(e) { if (null != e) { var t = e["function" == typeof Symbol && Symbol.iterator || "@@iterator"], r = 0; if (t) return t.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) return { next: function next() { return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e }; } }; } throw new TypeError(_typeof(e) + " is not iterable"); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o("next", 0), o("throw", 1), o("return", 2); } }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Chrome70 = void 0;
var sdpTransform = require("sdp-transform");
var Logger_1 = require("../Logger");
var utils = require("../utils");
var ortc = require("../ortc");
var sdpCommonUtils = require("./sdp/commonUtils");
var sdpUnifiedPlanUtils = require("./sdp/unifiedPlanUtils");
var HandlerInterface_1 = require("./HandlerInterface");
var RemoteSdp_1 = require("./sdp/RemoteSdp");
var scalabilityModes_1 = require("../scalabilityModes");
var logger = new Logger_1.Logger('Chrome70');
var NAME = 'Chrome70';
var SCTP_NUM_STREAMS = {
  OS: 1024,
  MIS: 1024
};
var Chrome70 = /*#__PURE__*/function (_HandlerInterface_1$H) {
  function Chrome70() {
    var _this;
    _classCallCheck(this, Chrome70);
    _this = _callSuper(this, Chrome70);
    // Handler direction.
    _defineProperty(_this, "_direction", void 0);
    // Remote SDP handler.
    _defineProperty(_this, "_remoteSdp", void 0);
    // Generic sending RTP parameters for audio and video.
    _defineProperty(_this, "_sendingRtpParametersByKind", void 0);
    // Generic sending RTP parameters for audio and video suitable for the SDP
    // remote answer.
    _defineProperty(_this, "_sendingRemoteRtpParametersByKind", void 0);
    // Initial server side DTLS role. If not 'auto', it will force the opposite
    // value in client side.
    _defineProperty(_this, "_forcedLocalDtlsRole", void 0);
    // RTCPeerConnection instance.
    _defineProperty(_this, "_pc", void 0);
    // Map of RTCTransceivers indexed by MID.
    _defineProperty(_this, "_mapMidTransceiver", new Map());
    // Local stream for sending.
    _defineProperty(_this, "_sendStream", new MediaStream());
    // Whether a DataChannel m=application section has been created.
    _defineProperty(_this, "_hasDataChannelMediaSection", false);
    // Sending DataChannel id value counter. Incremented for each new DataChannel.
    _defineProperty(_this, "_nextSendSctpStreamId", 0);
    // Got transport local and remote parameters.
    _defineProperty(_this, "_transportReady", false);
    return _this;
  }
  _inherits(Chrome70, _HandlerInterface_1$H);
  return _createClass(Chrome70, [{
    key: "name",
    get: function get() {
      return NAME;
    }
  }, {
    key: "close",
    value: function close() {
      logger.debug('close()');
      // Close RTCPeerConnection.
      if (this._pc) {
        try {
          this._pc.close();
        } catch (error) {}
      }
      this.emit('@close');
    }
  }, {
    key: "getNativeRtpCapabilities",
    value: function () {
      var _getNativeRtpCapabilities = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {
        var pc, offer, sdpObject, nativeRtpCapabilities, _t;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              logger.debug('getNativeRtpCapabilities()');
              pc = new RTCPeerConnection({
                iceServers: [],
                iceTransportPolicy: 'all',
                bundlePolicy: 'max-bundle',
                rtcpMuxPolicy: 'require',
                sdpSemantics: 'unified-plan'
              });
              _context.p = 1;
              pc.addTransceiver('audio');
              pc.addTransceiver('video');
              _context.n = 2;
              return pc.createOffer();
            case 2:
              offer = _context.v;
              try {
                pc.close();
              } catch (error) {}
              sdpObject = sdpTransform.parse(offer.sdp);
              nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject: sdpObject
              });
              return _context.a(2, nativeRtpCapabilities);
            case 3:
              _context.p = 3;
              _t = _context.v;
              try {
                pc.close();
              } catch (error2) {}
              throw _t;
            case 4:
              return _context.a(2);
          }
        }, _callee, null, [[1, 3]]);
      }));
      function getNativeRtpCapabilities() {
        return _getNativeRtpCapabilities.apply(this, arguments);
      }
      return getNativeRtpCapabilities;
    }()
  }, {
    key: "getNativeSctpCapabilities",
    value: function () {
      var _getNativeSctpCapabilities = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2() {
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.n) {
            case 0:
              logger.debug('getNativeSctpCapabilities()');
              return _context2.a(2, {
                numStreams: SCTP_NUM_STREAMS
              });
          }
        }, _callee2);
      }));
      function getNativeSctpCapabilities() {
        return _getNativeSctpCapabilities.apply(this, arguments);
      }
      return getNativeSctpCapabilities;
    }()
  }, {
    key: "run",
    value: function run(_ref) {
      var _this2 = this;
      var direction = _ref.direction,
        iceParameters = _ref.iceParameters,
        iceCandidates = _ref.iceCandidates,
        dtlsParameters = _ref.dtlsParameters,
        sctpParameters = _ref.sctpParameters,
        iceServers = _ref.iceServers,
        iceTransportPolicy = _ref.iceTransportPolicy,
        additionalSettings = _ref.additionalSettings,
        proprietaryConstraints = _ref.proprietaryConstraints,
        extendedRtpCapabilities = _ref.extendedRtpCapabilities;
      logger.debug('run()');
      this._direction = direction;
      this._remoteSdp = new RemoteSdp_1.RemoteSdp({
        iceParameters: iceParameters,
        iceCandidates: iceCandidates,
        dtlsParameters: dtlsParameters,
        sctpParameters: sctpParameters
      });
      this._sendingRtpParametersByKind = {
        audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
        video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
      };
      this._sendingRemoteRtpParametersByKind = {
        audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
        video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)
      };
      if (dtlsParameters.role && dtlsParameters.role !== 'auto') {
        this._forcedLocalDtlsRole = dtlsParameters.role === 'server' ? 'client' : 'server';
      }
      this._pc = new RTCPeerConnection(_objectSpread({
        iceServers: iceServers !== null && iceServers !== void 0 ? iceServers : [],
        iceTransportPolicy: iceTransportPolicy !== null && iceTransportPolicy !== void 0 ? iceTransportPolicy : 'all',
        bundlePolicy: 'max-bundle',
        rtcpMuxPolicy: 'require',
        sdpSemantics: 'unified-plan'
      }, additionalSettings), proprietaryConstraints);
      this._pc.addEventListener('icegatheringstatechange', function () {
        _this2.emit('@icegatheringstatechange', _this2._pc.iceGatheringState);
      });
      this._pc.addEventListener('icecandidateerror', function (event) {
        _this2.emit('@icecandidateerror', event);
      });
      if (this._pc.connectionState) {
        this._pc.addEventListener('connectionstatechange', function () {
          _this2.emit('@connectionstatechange', _this2._pc.connectionState);
        });
      } else {
        this._pc.addEventListener('iceconnectionstatechange', function () {
          logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
          switch (_this2._pc.iceConnectionState) {
            case 'checking':
              {
                _this2.emit('@connectionstatechange', 'connecting');
                break;
              }
            case 'connected':
            case 'completed':
              {
                _this2.emit('@connectionstatechange', 'connected');
                break;
              }
            case 'failed':
              {
                _this2.emit('@connectionstatechange', 'failed');
                break;
              }
            case 'disconnected':
              {
                _this2.emit('@connectionstatechange', 'disconnected');
                break;
              }
            case 'closed':
              {
                _this2.emit('@connectionstatechange', 'closed');
                break;
              }
          }
        });
      }
    }
  }, {
    key: "updateIceServers",
    value: function () {
      var _updateIceServers = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(iceServers) {
        var configuration;
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.n) {
            case 0:
              logger.debug('updateIceServers()');
              configuration = this._pc.getConfiguration();
              configuration.iceServers = iceServers;
              this._pc.setConfiguration(configuration);
            case 1:
              return _context3.a(2);
          }
        }, _callee3, this);
      }));
      function updateIceServers(_x) {
        return _updateIceServers.apply(this, arguments);
      }
      return updateIceServers;
    }()
  }, {
    key: "restartIce",
    value: function () {
      var _restartIce = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(iceParameters) {
        var offer, answer, _offer, _answer;
        return _regenerator().w(function (_context4) {
          while (1) switch (_context4.n) {
            case 0:
              logger.debug('restartIce()');
              // Provide the remote SDP handler with new remote ICE parameters.
              this._remoteSdp.updateIceParameters(iceParameters);
              if (this._transportReady) {
                _context4.n = 1;
                break;
              }
              return _context4.a(2);
            case 1:
              if (!(this._direction === 'send')) {
                _context4.n = 5;
                break;
              }
              _context4.n = 2;
              return this._pc.createOffer({
                iceRestart: true
              });
            case 2:
              offer = _context4.v;
              logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context4.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context4.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              _context4.n = 8;
              break;
            case 5:
              _offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', _offer);
              _context4.n = 6;
              return this._pc.setRemoteDescription(_offer);
            case 6:
              _context4.n = 7;
              return this._pc.createAnswer();
            case 7:
              _answer = _context4.v;
              logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', _answer);
              _context4.n = 8;
              return this._pc.setLocalDescription(_answer);
            case 8:
              return _context4.a(2);
          }
        }, _callee4, this);
      }));
      function restartIce(_x2) {
        return _restartIce.apply(this, arguments);
      }
      return restartIce;
    }()
  }, {
    key: "getTransportStats",
    value: function () {
      var _getTransportStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5() {
        return _regenerator().w(function (_context5) {
          while (1) switch (_context5.n) {
            case 0:
              return _context5.a(2, this._pc.getStats());
          }
        }, _callee5, this);
      }));
      function getTransportStats() {
        return _getTransportStats.apply(this, arguments);
      }
      return getTransportStats;
    }()
  }, {
    key: "send",
    value: function () {
      var _send = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6(_ref2) {
        var track, encodings, codecOptions, codec, sendingRtpParameters, sendingRemoteRtpParameters, mediaSectionIdx, transceiver, offer, localSdpObject, offerMediaObject, _this$_forcedLocalDtl, hackVp9Svc, layers, parameters, idx, _parameters$encodings, encoding, desiredEncoding, localId, _idx, _iterator, _step, _encoding, answer;
        return _regenerator().w(function (_context6) {
          while (1) switch (_context6.n) {
            case 0:
              track = _ref2.track, encodings = _ref2.encodings, codecOptions = _ref2.codecOptions, codec = _ref2.codec;
              this.assertSendDirection();
              logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
              sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]); // This may throw.
              sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
              sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]); // This may throw.
              sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
              mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
              transceiver = this._pc.addTransceiver(track, {
                direction: 'sendonly',
                streams: [this._sendStream]
              });
              _context6.n = 1;
              return this._pc.createOffer();
            case 1:
              offer = _context6.v;
              localSdpObject = sdpTransform.parse(offer.sdp); // @ts-expect-error --- sdpTransform.SessionDescription type doesn't
              // define extmapAllowMixed field.
              if (localSdpObject.extmapAllowMixed) {
                this._remoteSdp.setSessionExtmapAllowMixed();
              }
              if (this._transportReady) {
                _context6.n = 2;
                break;
              }
              _context6.n = 2;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl !== void 0 ? _this$_forcedLocalDtl : 'client',
                localSdpObject: localSdpObject
              });
            case 2:
              if (encodings && encodings.length > 1) {
                logger.debug('send() | enabling legacy simulcast');
                localSdpObject = sdpTransform.parse(offer.sdp);
                offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
                sdpUnifiedPlanUtils.addLegacySimulcast({
                  offerMediaObject: offerMediaObject,
                  numStreams: encodings.length
                });
                offer = {
                  type: 'offer',
                  sdp: sdpTransform.write(localSdpObject)
                };
              }
              // Special case for VP9 with SVC.
              hackVp9Svc = false;
              layers = (0, scalabilityModes_1.parse)((encodings !== null && encodings !== void 0 ? encodings : [{}])[0].scalabilityMode);
              if (encodings && encodings.length === 1 && layers.spatialLayers > 1 && sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp9') {
                logger.debug('send() | enabling legacy simulcast for VP9 SVC');
                hackVp9Svc = true;
                localSdpObject = sdpTransform.parse(offer.sdp);
                offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
                sdpUnifiedPlanUtils.addLegacySimulcast({
                  offerMediaObject: offerMediaObject,
                  numStreams: layers.spatialLayers
                });
                offer = {
                  type: 'offer',
                  sdp: sdpTransform.write(localSdpObject)
                };
              }
              logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context6.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              if (!encodings) {
                _context6.n = 8;
                break;
              }
              logger.debug('send() | applying given encodings');
              parameters = transceiver.sender.getParameters();
              idx = 0;
            case 4:
              if (!(idx < ((_parameters$encodings = parameters.encodings) !== null && _parameters$encodings !== void 0 ? _parameters$encodings : []).length)) {
                _context6.n = 7;
                break;
              }
              encoding = parameters.encodings[idx];
              desiredEncoding = encodings[idx]; // Should not happen but just in case.
              if (desiredEncoding) {
                _context6.n = 5;
                break;
              }
              return _context6.a(3, 7);
            case 5:
              parameters.encodings[idx] = Object.assign(encoding, desiredEncoding);
            case 6:
              ++idx;
              _context6.n = 4;
              break;
            case 7:
              _context6.n = 8;
              return transceiver.sender.setParameters(parameters);
            case 8:
              // We can now get the transceiver.mid.
              localId = transceiver.mid; // Set MID.
              sendingRtpParameters.mid = localId;
              localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
              offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
              // Set RTCP CNAME.
              sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
                offerMediaObject: offerMediaObject
              });
              // Set RTP encodings.
              sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
                offerMediaObject: offerMediaObject
              });
              // Complete encodings with given values.
              if (encodings) {
                for (_idx = 0; _idx < sendingRtpParameters.encodings.length; ++_idx) {
                  if (encodings[_idx]) {
                    Object.assign(sendingRtpParameters.encodings[_idx], encodings[_idx]);
                  }
                }
              }
              // Hack for VP9 SVC.
              if (hackVp9Svc) {
                sendingRtpParameters.encodings = [sendingRtpParameters.encodings[0]];
              }
              // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
              // each encoding.
              if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {
                _iterator = _createForOfIteratorHelper(sendingRtpParameters.encodings);
                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    _encoding = _step.value;
                    _encoding.scalabilityMode = 'L1T3';
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
              }
              this._remoteSdp.send({
                offerMediaObject: offerMediaObject,
                reuseMid: mediaSectionIdx.reuseMid,
                offerRtpParameters: sendingRtpParameters,
                answerRtpParameters: sendingRemoteRtpParameters,
                codecOptions: codecOptions
              });
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context6.n = 9;
              return this._pc.setRemoteDescription(answer);
            case 9:
              // Store in the map.
              this._mapMidTransceiver.set(localId, transceiver);
              return _context6.a(2, {
                localId: localId,
                rtpParameters: sendingRtpParameters,
                rtpSender: transceiver.sender
              });
          }
        }, _callee6, this);
      }));
      function send(_x3) {
        return _send.apply(this, arguments);
      }
      return send;
    }()
  }, {
    key: "stopSending",
    value: function () {
      var _stopSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7(localId) {
        var transceiver, mediaSectionClosed, offer, answer;
        return _regenerator().w(function (_context7) {
          while (1) switch (_context7.n) {
            case 0:
              this.assertSendDirection();
              logger.debug('stopSending() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context7.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              void transceiver.sender.replaceTrack(null);
              this._pc.removeTrack(transceiver.sender);
              mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
              if (mediaSectionClosed) {
                try {
                  transceiver.stop();
                } catch (error) {}
              }
              _context7.n = 2;
              return this._pc.createOffer();
            case 2:
              offer = _context7.v;
              logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context7.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context7.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              this._mapMidTransceiver["delete"](localId);
            case 5:
              return _context7.a(2);
          }
        }, _callee7, this);
      }));
      function stopSending(_x4) {
        return _stopSending.apply(this, arguments);
      }
      return stopSending;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "pauseSending",
    value: function () {
      var _pauseSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8(localId) {
        return _regenerator().w(function (_context8) {
          while (1) switch (_context8.n) {
            case 0:
              return _context8.a(2);
          }
        }, _callee8);
      }));
      function pauseSending(_x5) {
        return _pauseSending.apply(this, arguments);
      }
      return pauseSending;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "resumeSending",
    value: function () {
      var _resumeSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee9(localId) {
        return _regenerator().w(function (_context9) {
          while (1) switch (_context9.n) {
            case 0:
              return _context9.a(2);
          }
        }, _callee9);
      }));
      function resumeSending(_x6) {
        return _resumeSending.apply(this, arguments);
      }
      return resumeSending;
    }()
  }, {
    key: "replaceTrack",
    value: function () {
      var _replaceTrack = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee0(localId, track) {
        var transceiver;
        return _regenerator().w(function (_context0) {
          while (1) switch (_context0.n) {
            case 0:
              this.assertSendDirection();
              if (track) {
                logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
              } else {
                logger.debug('replaceTrack() [localId:%s, no track]', localId);
              }
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context0.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              _context0.n = 2;
              return transceiver.sender.replaceTrack(track);
            case 2:
              return _context0.a(2);
          }
        }, _callee0, this);
      }));
      function replaceTrack(_x7, _x8) {
        return _replaceTrack.apply(this, arguments);
      }
      return replaceTrack;
    }()
  }, {
    key: "setMaxSpatialLayer",
    value: function () {
      var _setMaxSpatialLayer = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee1(localId, spatialLayer) {
        var transceiver, parameters, offer, answer;
        return _regenerator().w(function (_context1) {
          while (1) switch (_context1.n) {
            case 0:
              this.assertSendDirection();
              logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context1.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              parameters = transceiver.sender.getParameters();
              parameters.encodings.forEach(function (encoding, idx) {
                if (idx <= spatialLayer) {
                  encoding.active = true;
                } else {
                  encoding.active = false;
                }
              });
              _context1.n = 2;
              return transceiver.sender.setParameters(parameters);
            case 2:
              this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
              _context1.n = 3;
              return this._pc.createOffer();
            case 3:
              offer = _context1.v;
              logger.debug('setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context1.n = 4;
              return this._pc.setLocalDescription(offer);
            case 4:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context1.n = 5;
              return this._pc.setRemoteDescription(answer);
            case 5:
              return _context1.a(2);
          }
        }, _callee1, this);
      }));
      function setMaxSpatialLayer(_x9, _x0) {
        return _setMaxSpatialLayer.apply(this, arguments);
      }
      return setMaxSpatialLayer;
    }()
  }, {
    key: "setRtpEncodingParameters",
    value: function () {
      var _setRtpEncodingParameters = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee10(localId, params) {
        var transceiver, parameters, offer, answer;
        return _regenerator().w(function (_context10) {
          while (1) switch (_context10.n) {
            case 0:
              this.assertSendDirection();
              logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context10.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              parameters = transceiver.sender.getParameters();
              parameters.encodings.forEach(function (encoding, idx) {
                parameters.encodings[idx] = _objectSpread(_objectSpread({}, encoding), params);
              });
              _context10.n = 2;
              return transceiver.sender.setParameters(parameters);
            case 2:
              this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
              _context10.n = 3;
              return this._pc.createOffer();
            case 3:
              offer = _context10.v;
              logger.debug('setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context10.n = 4;
              return this._pc.setLocalDescription(offer);
            case 4:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context10.n = 5;
              return this._pc.setRemoteDescription(answer);
            case 5:
              return _context10.a(2);
          }
        }, _callee10, this);
      }));
      function setRtpEncodingParameters(_x1, _x10) {
        return _setRtpEncodingParameters.apply(this, arguments);
      }
      return setRtpEncodingParameters;
    }()
  }, {
    key: "getSenderStats",
    value: function () {
      var _getSenderStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee11(localId) {
        var transceiver;
        return _regenerator().w(function (_context11) {
          while (1) switch (_context11.n) {
            case 0:
              this.assertSendDirection();
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context11.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              return _context11.a(2, transceiver.sender.getStats());
          }
        }, _callee11, this);
      }));
      function getSenderStats(_x11) {
        return _getSenderStats.apply(this, arguments);
      }
      return getSenderStats;
    }()
  }, {
    key: "sendDataChannel",
    value: function () {
      var _sendDataChannel = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee12(_ref3) {
        var ordered, maxPacketLifeTime, maxRetransmits, label, protocol, options, dataChannel, offer, localSdpObject, offerMediaObject, _this$_forcedLocalDtl2, answer, sctpStreamParameters;
        return _regenerator().w(function (_context12) {
          while (1) switch (_context12.n) {
            case 0:
              ordered = _ref3.ordered, maxPacketLifeTime = _ref3.maxPacketLifeTime, maxRetransmits = _ref3.maxRetransmits, label = _ref3.label, protocol = _ref3.protocol;
              this.assertSendDirection();
              options = {
                negotiated: true,
                id: this._nextSendSctpStreamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmitTime: maxPacketLifeTime,
                // NOTE: Old spec.
                maxRetransmits: maxRetransmits,
                protocol: protocol
              };
              logger.debug('sendDataChannel() [options:%o]', options);
              dataChannel = this._pc.createDataChannel(label, options); // Increase next id.
              this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
              // If this is the first DataChannel we need to create the SDP answer with
              // m=application section.
              if (this._hasDataChannelMediaSection) {
                _context12.n = 5;
                break;
              }
              _context12.n = 1;
              return this._pc.createOffer();
            case 1:
              offer = _context12.v;
              localSdpObject = sdpTransform.parse(offer.sdp);
              offerMediaObject = localSdpObject.media.find(function (m) {
                return m.type === 'application';
              });
              if (this._transportReady) {
                _context12.n = 2;
                break;
              }
              _context12.n = 2;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl2 = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl2 !== void 0 ? _this$_forcedLocalDtl2 : 'client',
                localSdpObject: localSdpObject
              });
            case 2:
              logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context12.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              this._remoteSdp.sendSctpAssociation({
                offerMediaObject: offerMediaObject
              });
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context12.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              this._hasDataChannelMediaSection = true;
            case 5:
              sctpStreamParameters = {
                streamId: options.id,
                ordered: options.ordered,
                maxPacketLifeTime: options.maxPacketLifeTime,
                maxRetransmits: options.maxRetransmits
              };
              return _context12.a(2, {
                dataChannel: dataChannel,
                sctpStreamParameters: sctpStreamParameters
              });
          }
        }, _callee12, this);
      }));
      function sendDataChannel(_x12) {
        return _sendDataChannel.apply(this, arguments);
      }
      return sendDataChannel;
    }()
  }, {
    key: "receive",
    value: function () {
      var _receive = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee13(optionsList) {
        var _this3 = this;
        var results, mapLocalId, _iterator2, _step2, _rtpParameters$mid, options, trackId, kind, rtpParameters, streamId, localId, offer, answer, localSdpObject, _iterator3, _step3, _loop, _this$_forcedLocalDtl3, _iterator4, _step4, _loop2, _t2, _t3;
        return _regenerator().w(function (_context15) {
          while (1) switch (_context15.n) {
            case 0:
              this.assertRecvDirection();
              results = [];
              mapLocalId = new Map();
              _iterator2 = _createForOfIteratorHelper(optionsList);
              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  options = _step2.value;
                  trackId = options.trackId, kind = options.kind, rtpParameters = options.rtpParameters, streamId = options.streamId;
                  logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
                  localId = (_rtpParameters$mid = rtpParameters.mid) !== null && _rtpParameters$mid !== void 0 ? _rtpParameters$mid : String(this._mapMidTransceiver.size);
                  mapLocalId.set(trackId, localId);
                  this._remoteSdp.receive({
                    mid: localId,
                    kind: kind,
                    offerRtpParameters: rtpParameters,
                    streamId: streamId !== null && streamId !== void 0 ? streamId : rtpParameters.rtcp.cname,
                    trackId: trackId
                  });
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context15.n = 1;
              return this._pc.setRemoteDescription(offer);
            case 1:
              _context15.n = 2;
              return this._pc.createAnswer();
            case 2:
              answer = _context15.v;
              localSdpObject = sdpTransform.parse(answer.sdp);
              _iterator3 = _createForOfIteratorHelper(optionsList);
              _context15.p = 3;
              _loop = /*#__PURE__*/_regenerator().m(function _loop() {
                var options, trackId, rtpParameters, localId, answerMediaObject;
                return _regenerator().w(function (_context13) {
                  while (1) switch (_context13.n) {
                    case 0:
                      options = _step3.value;
                      trackId = options.trackId, rtpParameters = options.rtpParameters;
                      localId = mapLocalId.get(trackId);
                      answerMediaObject = localSdpObject.media.find(function (m) {
                        return String(m.mid) === localId;
                      }); // May need to modify codec parameters in the answer based on codec
                      // parameters in the offer.
                      sdpCommonUtils.applyCodecParameters({
                        offerRtpParameters: rtpParameters,
                        answerMediaObject: answerMediaObject
                      });
                    case 1:
                      return _context13.a(2);
                  }
                }, _loop);
              });
              _iterator3.s();
            case 4:
              if ((_step3 = _iterator3.n()).done) {
                _context15.n = 6;
                break;
              }
              return _context15.d(_regeneratorValues(_loop()), 5);
            case 5:
              _context15.n = 4;
              break;
            case 6:
              _context15.n = 8;
              break;
            case 7:
              _context15.p = 7;
              _t2 = _context15.v;
              _iterator3.e(_t2);
            case 8:
              _context15.p = 8;
              _iterator3.f();
              return _context15.f(8);
            case 9:
              answer = {
                type: 'answer',
                sdp: sdpTransform.write(localSdpObject)
              };
              if (this._transportReady) {
                _context15.n = 10;
                break;
              }
              _context15.n = 10;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl3 = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl3 !== void 0 ? _this$_forcedLocalDtl3 : 'client',
                localSdpObject: localSdpObject
              });
            case 10:
              logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context15.n = 11;
              return this._pc.setLocalDescription(answer);
            case 11:
              _iterator4 = _createForOfIteratorHelper(optionsList);
              _context15.p = 12;
              _loop2 = /*#__PURE__*/_regenerator().m(function _loop2() {
                var options, trackId, localId, transceiver;
                return _regenerator().w(function (_context14) {
                  while (1) switch (_context14.n) {
                    case 0:
                      options = _step4.value;
                      trackId = options.trackId;
                      localId = mapLocalId.get(trackId);
                      transceiver = _this3._pc.getTransceivers().find(function (t) {
                        return t.mid === localId;
                      });
                      if (transceiver) {
                        _context14.n = 1;
                        break;
                      }
                      throw new Error('new RTCRtpTransceiver not found');
                    case 1:
                      // Store in the map.
                      _this3._mapMidTransceiver.set(localId, transceiver);
                      results.push({
                        localId: localId,
                        track: transceiver.receiver.track,
                        rtpReceiver: transceiver.receiver
                      });
                    case 2:
                      return _context14.a(2);
                  }
                }, _loop2);
              });
              _iterator4.s();
            case 13:
              if ((_step4 = _iterator4.n()).done) {
                _context15.n = 15;
                break;
              }
              return _context15.d(_regeneratorValues(_loop2()), 14);
            case 14:
              _context15.n = 13;
              break;
            case 15:
              _context15.n = 17;
              break;
            case 16:
              _context15.p = 16;
              _t3 = _context15.v;
              _iterator4.e(_t3);
            case 17:
              _context15.p = 17;
              _iterator4.f();
              return _context15.f(17);
            case 18:
              return _context15.a(2, results);
          }
        }, _callee13, this, [[12, 16, 17, 18], [3, 7, 8, 9]]);
      }));
      function receive(_x13) {
        return _receive.apply(this, arguments);
      }
      return receive;
    }()
  }, {
    key: "stopReceiving",
    value: function () {
      var _stopReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee14(localIds) {
        var _iterator5, _step5, localId, transceiver, offer, answer, _iterator6, _step6, _localId, _t4;
        return _regenerator().w(function (_context16) {
          while (1) switch (_context16.n) {
            case 0:
              this.assertRecvDirection();
              _iterator5 = _createForOfIteratorHelper(localIds);
              _context16.p = 1;
              _iterator5.s();
            case 2:
              if ((_step5 = _iterator5.n()).done) {
                _context16.n = 5;
                break;
              }
              localId = _step5.value;
              logger.debug('stopReceiving() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context16.n = 3;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 3:
              this._remoteSdp.closeMediaSection(transceiver.mid);
            case 4:
              _context16.n = 2;
              break;
            case 5:
              _context16.n = 7;
              break;
            case 6:
              _context16.p = 6;
              _t4 = _context16.v;
              _iterator5.e(_t4);
            case 7:
              _context16.p = 7;
              _iterator5.f();
              return _context16.f(7);
            case 8:
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context16.n = 9;
              return this._pc.setRemoteDescription(offer);
            case 9:
              _context16.n = 10;
              return this._pc.createAnswer();
            case 10:
              answer = _context16.v;
              logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context16.n = 11;
              return this._pc.setLocalDescription(answer);
            case 11:
              _iterator6 = _createForOfIteratorHelper(localIds);
              try {
                for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                  _localId = _step6.value;
                  this._mapMidTransceiver["delete"](_localId);
                }
              } catch (err) {
                _iterator6.e(err);
              } finally {
                _iterator6.f();
              }
            case 12:
              return _context16.a(2);
          }
        }, _callee14, this, [[1, 6, 7, 8]]);
      }));
      function stopReceiving(_x14) {
        return _stopReceiving.apply(this, arguments);
      }
      return stopReceiving;
    }()
  }, {
    key: "pauseReceiving",
    value: function () {
      var _pauseReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee15(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      localIds) {
        return _regenerator().w(function (_context17) {
          while (1) switch (_context17.n) {
            case 0:
              return _context17.a(2);
          }
        }, _callee15);
      }));
      function pauseReceiving(_x15) {
        return _pauseReceiving.apply(this, arguments);
      }
      return pauseReceiving;
    }()
  }, {
    key: "resumeReceiving",
    value: function () {
      var _resumeReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee16(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      localIds) {
        return _regenerator().w(function (_context18) {
          while (1) switch (_context18.n) {
            case 0:
              return _context18.a(2);
          }
        }, _callee16);
      }));
      function resumeReceiving(_x16) {
        return _resumeReceiving.apply(this, arguments);
      }
      return resumeReceiving;
    }()
  }, {
    key: "getReceiverStats",
    value: function () {
      var _getReceiverStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee17(localId) {
        var transceiver;
        return _regenerator().w(function (_context19) {
          while (1) switch (_context19.n) {
            case 0:
              this.assertRecvDirection();
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context19.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              return _context19.a(2, transceiver.receiver.getStats());
          }
        }, _callee17, this);
      }));
      function getReceiverStats(_x17) {
        return _getReceiverStats.apply(this, arguments);
      }
      return getReceiverStats;
    }()
  }, {
    key: "receiveDataChannel",
    value: function () {
      var _receiveDataChannel = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee18(_ref4) {
        var sctpStreamParameters, label, protocol, streamId, ordered, maxPacketLifeTime, maxRetransmits, options, dataChannel, offer, answer, _this$_forcedLocalDtl4, localSdpObject;
        return _regenerator().w(function (_context20) {
          while (1) switch (_context20.n) {
            case 0:
              sctpStreamParameters = _ref4.sctpStreamParameters, label = _ref4.label, protocol = _ref4.protocol;
              this.assertRecvDirection();
              streamId = sctpStreamParameters.streamId, ordered = sctpStreamParameters.ordered, maxPacketLifeTime = sctpStreamParameters.maxPacketLifeTime, maxRetransmits = sctpStreamParameters.maxRetransmits;
              options = {
                negotiated: true,
                id: streamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmitTime: maxPacketLifeTime,
                // NOTE: Old spec.
                maxRetransmits: maxRetransmits,
                protocol: protocol
              };
              logger.debug('receiveDataChannel() [options:%o]', options);
              dataChannel = this._pc.createDataChannel(label, options); // If this is the first DataChannel we need to create the SDP offer with
              // m=application section.
              if (this._hasDataChannelMediaSection) {
                _context20.n = 5;
                break;
              }
              this._remoteSdp.receiveSctpAssociation();
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context20.n = 1;
              return this._pc.setRemoteDescription(offer);
            case 1:
              _context20.n = 2;
              return this._pc.createAnswer();
            case 2:
              answer = _context20.v;
              if (this._transportReady) {
                _context20.n = 3;
                break;
              }
              localSdpObject = sdpTransform.parse(answer.sdp);
              _context20.n = 3;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl4 = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl4 !== void 0 ? _this$_forcedLocalDtl4 : 'client',
                localSdpObject: localSdpObject
              });
            case 3:
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context20.n = 4;
              return this._pc.setLocalDescription(answer);
            case 4:
              this._hasDataChannelMediaSection = true;
            case 5:
              return _context20.a(2, {
                dataChannel: dataChannel
              });
          }
        }, _callee18, this);
      }));
      function receiveDataChannel(_x18) {
        return _receiveDataChannel.apply(this, arguments);
      }
      return receiveDataChannel;
    }()
  }, {
    key: "setupTransport",
    value: function () {
      var _setupTransport = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee19(_ref5) {
        var _this4 = this;
        var localDtlsRole, localSdpObject, dtlsParameters;
        return _regenerator().w(function (_context21) {
          while (1) switch (_context21.n) {
            case 0:
              localDtlsRole = _ref5.localDtlsRole, localSdpObject = _ref5.localSdpObject;
              if (!localSdpObject) {
                localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
              }
              // Get our local DTLS parameters.
              dtlsParameters = sdpCommonUtils.extractDtlsParameters({
                sdpObject: localSdpObject
              }); // Set our DTLS role.
              dtlsParameters.role = localDtlsRole;
              // Update the remote DTLS role in the SDP.
              this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
              // Need to tell the remote transport about our parameters.
              _context21.n = 1;
              return new Promise(function (resolve, reject) {
                _this4.safeEmit('@connect', {
                  dtlsParameters: dtlsParameters
                }, resolve, reject);
              });
            case 1:
              this._transportReady = true;
            case 2:
              return _context21.a(2);
          }
        }, _callee19, this);
      }));
      function setupTransport(_x19) {
        return _setupTransport.apply(this, arguments);
      }
      return setupTransport;
    }()
  }, {
    key: "assertSendDirection",
    value: function assertSendDirection() {
      if (this._direction !== 'send') {
        throw new Error('method can just be called for handlers with "send" direction');
      }
    }
  }, {
    key: "assertRecvDirection",
    value: function assertRecvDirection() {
      if (this._direction !== 'recv') {
        throw new Error('method can just be called for handlers with "recv" direction');
      }
    }
  }], [{
    key: "createFactory",
    value:
    /**
     * Creates a factory function.
     */
    function createFactory() {
      return function () {
        return new Chrome70();
      };
    }
  }]);
}(HandlerInterface_1.HandlerInterface);
exports.Chrome70 = Chrome70;

},{"../Logger":39,"../ortc":68,"../scalabilityModes":69,"../utils":72,"./HandlerInterface":55,"./sdp/RemoteSdp":63,"./sdp/commonUtils":64,"./sdp/unifiedPlanUtils":66,"sdp-transform":76}],50:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorValues(e) { if (null != e) { var t = e["function" == typeof Symbol && Symbol.iterator || "@@iterator"], r = 0; if (t) return t.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) return { next: function next() { return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e }; } }; } throw new TypeError(_typeof(e) + " is not iterable"); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o("next", 0), o("throw", 1), o("return", 2); } }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Chrome74 = void 0;
var sdpTransform = require("sdp-transform");
var Logger_1 = require("../Logger");
var utils = require("../utils");
var ortc = require("../ortc");
var sdpCommonUtils = require("./sdp/commonUtils");
var sdpUnifiedPlanUtils = require("./sdp/unifiedPlanUtils");
var ortcUtils = require("./ortc/utils");
var errors_1 = require("../errors");
var HandlerInterface_1 = require("./HandlerInterface");
var RemoteSdp_1 = require("./sdp/RemoteSdp");
var scalabilityModes_1 = require("../scalabilityModes");
var logger = new Logger_1.Logger('Chrome74');
var NAME = 'Chrome74';
var SCTP_NUM_STREAMS = {
  OS: 1024,
  MIS: 1024
};
var Chrome74 = /*#__PURE__*/function (_HandlerInterface_1$H) {
  function Chrome74() {
    var _this;
    _classCallCheck(this, Chrome74);
    _this = _callSuper(this, Chrome74);
    // Closed flag.
    _defineProperty(_this, "_closed", false);
    // Handler direction.
    _defineProperty(_this, "_direction", void 0);
    // Remote SDP handler.
    _defineProperty(_this, "_remoteSdp", void 0);
    // Generic sending RTP parameters for audio and video.
    _defineProperty(_this, "_sendingRtpParametersByKind", void 0);
    // Generic sending RTP parameters for audio and video suitable for the SDP
    // remote answer.
    _defineProperty(_this, "_sendingRemoteRtpParametersByKind", void 0);
    // Initial server side DTLS role. If not 'auto', it will force the opposite
    // value in client side.
    _defineProperty(_this, "_forcedLocalDtlsRole", void 0);
    // RTCPeerConnection instance.
    _defineProperty(_this, "_pc", void 0);
    // Map of RTCTransceivers indexed by MID.
    _defineProperty(_this, "_mapMidTransceiver", new Map());
    // Local stream for sending.
    _defineProperty(_this, "_sendStream", new MediaStream());
    // Whether a DataChannel m=application section has been created.
    _defineProperty(_this, "_hasDataChannelMediaSection", false);
    // Sending DataChannel id value counter. Incremented for each new DataChannel.
    _defineProperty(_this, "_nextSendSctpStreamId", 0);
    // Got transport local and remote parameters.
    _defineProperty(_this, "_transportReady", false);
    return _this;
  }
  _inherits(Chrome74, _HandlerInterface_1$H);
  return _createClass(Chrome74, [{
    key: "name",
    get: function get() {
      return NAME;
    }
  }, {
    key: "close",
    value: function close() {
      logger.debug('close()');
      if (this._closed) {
        return;
      }
      this._closed = true;
      // Close RTCPeerConnection.
      if (this._pc) {
        try {
          this._pc.close();
        } catch (error) {}
      }
      this.emit('@close');
    }
  }, {
    key: "getNativeRtpCapabilities",
    value: function () {
      var _getNativeRtpCapabilities = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {
        var pc, offer, sdpObject, nativeRtpCapabilities, _t;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              logger.debug('getNativeRtpCapabilities()');
              pc = new RTCPeerConnection({
                iceServers: [],
                iceTransportPolicy: 'all',
                bundlePolicy: 'max-bundle',
                rtcpMuxPolicy: 'require',
                sdpSemantics: 'unified-plan'
              });
              _context.p = 1;
              pc.addTransceiver('audio');
              pc.addTransceiver('video');
              _context.n = 2;
              return pc.createOffer();
            case 2:
              offer = _context.v;
              try {
                pc.close();
              } catch (error) {}
              sdpObject = sdpTransform.parse(offer.sdp);
              nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject: sdpObject
              }); // libwebrtc supports NACK for OPUS but doesn't announce it.
              ortcUtils.addNackSupportForOpus(nativeRtpCapabilities);
              return _context.a(2, nativeRtpCapabilities);
            case 3:
              _context.p = 3;
              _t = _context.v;
              try {
                pc.close();
              } catch (error2) {}
              throw _t;
            case 4:
              return _context.a(2);
          }
        }, _callee, null, [[1, 3]]);
      }));
      function getNativeRtpCapabilities() {
        return _getNativeRtpCapabilities.apply(this, arguments);
      }
      return getNativeRtpCapabilities;
    }()
  }, {
    key: "getNativeSctpCapabilities",
    value: function () {
      var _getNativeSctpCapabilities = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2() {
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.n) {
            case 0:
              logger.debug('getNativeSctpCapabilities()');
              return _context2.a(2, {
                numStreams: SCTP_NUM_STREAMS
              });
          }
        }, _callee2);
      }));
      function getNativeSctpCapabilities() {
        return _getNativeSctpCapabilities.apply(this, arguments);
      }
      return getNativeSctpCapabilities;
    }()
  }, {
    key: "run",
    value: function run(_ref) {
      var _this2 = this;
      var direction = _ref.direction,
        iceParameters = _ref.iceParameters,
        iceCandidates = _ref.iceCandidates,
        dtlsParameters = _ref.dtlsParameters,
        sctpParameters = _ref.sctpParameters,
        iceServers = _ref.iceServers,
        iceTransportPolicy = _ref.iceTransportPolicy,
        additionalSettings = _ref.additionalSettings,
        proprietaryConstraints = _ref.proprietaryConstraints,
        extendedRtpCapabilities = _ref.extendedRtpCapabilities;
      logger.debug('run()');
      this._direction = direction;
      this._remoteSdp = new RemoteSdp_1.RemoteSdp({
        iceParameters: iceParameters,
        iceCandidates: iceCandidates,
        dtlsParameters: dtlsParameters,
        sctpParameters: sctpParameters
      });
      this._sendingRtpParametersByKind = {
        audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
        video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
      };
      this._sendingRemoteRtpParametersByKind = {
        audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
        video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)
      };
      if (dtlsParameters.role && dtlsParameters.role !== 'auto') {
        this._forcedLocalDtlsRole = dtlsParameters.role === 'server' ? 'client' : 'server';
      }
      this._pc = new RTCPeerConnection(_objectSpread({
        iceServers: iceServers !== null && iceServers !== void 0 ? iceServers : [],
        iceTransportPolicy: iceTransportPolicy !== null && iceTransportPolicy !== void 0 ? iceTransportPolicy : 'all',
        bundlePolicy: 'max-bundle',
        rtcpMuxPolicy: 'require',
        sdpSemantics: 'unified-plan'
      }, additionalSettings), proprietaryConstraints);
      this._pc.addEventListener('icegatheringstatechange', function () {
        _this2.emit('@icegatheringstatechange', _this2._pc.iceGatheringState);
      });
      this._pc.addEventListener('icecandidateerror', function (event) {
        _this2.emit('@icecandidateerror', event);
      });
      if (this._pc.connectionState) {
        this._pc.addEventListener('connectionstatechange', function () {
          _this2.emit('@connectionstatechange', _this2._pc.connectionState);
        });
      } else {
        logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
        this._pc.addEventListener('iceconnectionstatechange', function () {
          switch (_this2._pc.iceConnectionState) {
            case 'checking':
              {
                _this2.emit('@connectionstatechange', 'connecting');
                break;
              }
            case 'connected':
            case 'completed':
              {
                _this2.emit('@connectionstatechange', 'connected');
                break;
              }
            case 'failed':
              {
                _this2.emit('@connectionstatechange', 'failed');
                break;
              }
            case 'disconnected':
              {
                _this2.emit('@connectionstatechange', 'disconnected');
                break;
              }
            case 'closed':
              {
                _this2.emit('@connectionstatechange', 'closed');
                break;
              }
          }
        });
      }
    }
  }, {
    key: "updateIceServers",
    value: function () {
      var _updateIceServers = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(iceServers) {
        var configuration;
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.n) {
            case 0:
              this.assertNotClosed();
              logger.debug('updateIceServers()');
              configuration = this._pc.getConfiguration();
              configuration.iceServers = iceServers;
              this._pc.setConfiguration(configuration);
            case 1:
              return _context3.a(2);
          }
        }, _callee3, this);
      }));
      function updateIceServers(_x) {
        return _updateIceServers.apply(this, arguments);
      }
      return updateIceServers;
    }()
  }, {
    key: "restartIce",
    value: function () {
      var _restartIce = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(iceParameters) {
        var offer, answer, _offer, _answer;
        return _regenerator().w(function (_context4) {
          while (1) switch (_context4.n) {
            case 0:
              this.assertNotClosed();
              logger.debug('restartIce()');
              // Provide the remote SDP handler with new remote ICE parameters.
              this._remoteSdp.updateIceParameters(iceParameters);
              if (this._transportReady) {
                _context4.n = 1;
                break;
              }
              return _context4.a(2);
            case 1:
              if (!(this._direction === 'send')) {
                _context4.n = 5;
                break;
              }
              _context4.n = 2;
              return this._pc.createOffer({
                iceRestart: true
              });
            case 2:
              offer = _context4.v;
              logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context4.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context4.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              _context4.n = 8;
              break;
            case 5:
              _offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', _offer);
              _context4.n = 6;
              return this._pc.setRemoteDescription(_offer);
            case 6:
              _context4.n = 7;
              return this._pc.createAnswer();
            case 7:
              _answer = _context4.v;
              logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', _answer);
              _context4.n = 8;
              return this._pc.setLocalDescription(_answer);
            case 8:
              return _context4.a(2);
          }
        }, _callee4, this);
      }));
      function restartIce(_x2) {
        return _restartIce.apply(this, arguments);
      }
      return restartIce;
    }()
  }, {
    key: "getTransportStats",
    value: function () {
      var _getTransportStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5() {
        return _regenerator().w(function (_context5) {
          while (1) switch (_context5.n) {
            case 0:
              this.assertNotClosed();
              return _context5.a(2, this._pc.getStats());
          }
        }, _callee5, this);
      }));
      function getTransportStats() {
        return _getTransportStats.apply(this, arguments);
      }
      return getTransportStats;
    }()
  }, {
    key: "send",
    value: function () {
      var _send = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6(_ref2) {
        var track, encodings, codecOptions, codec, sendingRtpParameters, sendingRemoteRtpParameters, mediaSectionIdx, transceiver, offer, localSdpObject, offerMediaObject, _this$_forcedLocalDtl, hackVp9Svc, layers, localId, newEncodings, _iterator, _step, encoding, answer;
        return _regenerator().w(function (_context6) {
          while (1) switch (_context6.n) {
            case 0:
              track = _ref2.track, encodings = _ref2.encodings, codecOptions = _ref2.codecOptions, codec = _ref2.codec;
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
              if (encodings && encodings.length > 1) {
                encodings.forEach(function (encoding, idx) {
                  encoding.rid = "r".concat(idx);
                });
              }
              sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]); // This may throw.
              sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
              sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]); // This may throw.
              sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
              mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
              transceiver = this._pc.addTransceiver(track, {
                direction: 'sendonly',
                streams: [this._sendStream],
                sendEncodings: encodings
              });
              _context6.n = 1;
              return this._pc.createOffer();
            case 1:
              offer = _context6.v;
              localSdpObject = sdpTransform.parse(offer.sdp); // @ts-expect-error --- sdpTransform.SessionDescription type doesn't
              // define extmapAllowMixed field.
              if (localSdpObject.extmapAllowMixed) {
                this._remoteSdp.setSessionExtmapAllowMixed();
              }
              if (this._transportReady) {
                _context6.n = 2;
                break;
              }
              _context6.n = 2;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl !== void 0 ? _this$_forcedLocalDtl : 'client',
                localSdpObject: localSdpObject
              });
            case 2:
              // Special case for VP9 with SVC.
              hackVp9Svc = false;
              layers = (0, scalabilityModes_1.parse)((encodings !== null && encodings !== void 0 ? encodings : [{}])[0].scalabilityMode);
              if (encodings && encodings.length === 1 && layers.spatialLayers > 1 && sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp9') {
                logger.debug('send() | enabling legacy simulcast for VP9 SVC');
                hackVp9Svc = true;
                localSdpObject = sdpTransform.parse(offer.sdp);
                offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
                sdpUnifiedPlanUtils.addLegacySimulcast({
                  offerMediaObject: offerMediaObject,
                  numStreams: layers.spatialLayers
                });
                offer = {
                  type: 'offer',
                  sdp: sdpTransform.write(localSdpObject)
                };
              }
              logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context6.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              // We can now get the transceiver.mid.
              localId = transceiver.mid; // Set MID.
              sendingRtpParameters.mid = localId;
              localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
              offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
              // Set RTCP CNAME.
              sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
                offerMediaObject: offerMediaObject
              });
              // Set RTP encodings by parsing the SDP offer if no encodings are given.
              if (!encodings) {
                sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
                  offerMediaObject: offerMediaObject
                });
              }
              // Set RTP encodings by parsing the SDP offer and complete them with given
              // one if just a single encoding has been given.
              else if (encodings.length === 1) {
                newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
                  offerMediaObject: offerMediaObject
                });
                Object.assign(newEncodings[0], encodings[0]);
                // Hack for VP9 SVC.
                if (hackVp9Svc) {
                  newEncodings = [newEncodings[0]];
                }
                sendingRtpParameters.encodings = newEncodings;
              }
              // Otherwise if more than 1 encoding are given use them verbatim.
              else {
                sendingRtpParameters.encodings = encodings;
              }
              // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
              // each encoding.
              if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {
                _iterator = _createForOfIteratorHelper(sendingRtpParameters.encodings);
                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    encoding = _step.value;
                    if (encoding.scalabilityMode) {
                      encoding.scalabilityMode = "L1T".concat(layers.temporalLayers);
                    } else {
                      encoding.scalabilityMode = 'L1T3';
                    }
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
              }
              this._remoteSdp.send({
                offerMediaObject: offerMediaObject,
                reuseMid: mediaSectionIdx.reuseMid,
                offerRtpParameters: sendingRtpParameters,
                answerRtpParameters: sendingRemoteRtpParameters,
                codecOptions: codecOptions
              });
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context6.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              // Store in the map.
              this._mapMidTransceiver.set(localId, transceiver);
              return _context6.a(2, {
                localId: localId,
                rtpParameters: sendingRtpParameters,
                rtpSender: transceiver.sender
              });
          }
        }, _callee6, this);
      }));
      function send(_x3) {
        return _send.apply(this, arguments);
      }
      return send;
    }()
  }, {
    key: "stopSending",
    value: function () {
      var _stopSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7(localId) {
        var transceiver, mediaSectionClosed, offer, answer;
        return _regenerator().w(function (_context7) {
          while (1) switch (_context7.n) {
            case 0:
              this.assertSendDirection();
              logger.debug('stopSending() [localId:%s]', localId);
              if (!this._closed) {
                _context7.n = 1;
                break;
              }
              return _context7.a(2);
            case 1:
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context7.n = 2;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 2:
              void transceiver.sender.replaceTrack(null);
              this._pc.removeTrack(transceiver.sender);
              mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
              if (mediaSectionClosed) {
                try {
                  transceiver.stop();
                } catch (error) {}
              }
              _context7.n = 3;
              return this._pc.createOffer();
            case 3:
              offer = _context7.v;
              logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context7.n = 4;
              return this._pc.setLocalDescription(offer);
            case 4:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context7.n = 5;
              return this._pc.setRemoteDescription(answer);
            case 5:
              this._mapMidTransceiver["delete"](localId);
            case 6:
              return _context7.a(2);
          }
        }, _callee7, this);
      }));
      function stopSending(_x4) {
        return _stopSending.apply(this, arguments);
      }
      return stopSending;
    }()
  }, {
    key: "pauseSending",
    value: function () {
      var _pauseSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8(localId) {
        var transceiver, offer, answer;
        return _regenerator().w(function (_context8) {
          while (1) switch (_context8.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('pauseSending() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context8.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              transceiver.direction = 'inactive';
              this._remoteSdp.pauseMediaSection(localId);
              _context8.n = 2;
              return this._pc.createOffer();
            case 2:
              offer = _context8.v;
              logger.debug('pauseSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context8.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('pauseSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context8.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              return _context8.a(2);
          }
        }, _callee8, this);
      }));
      function pauseSending(_x5) {
        return _pauseSending.apply(this, arguments);
      }
      return pauseSending;
    }()
  }, {
    key: "resumeSending",
    value: function () {
      var _resumeSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee9(localId) {
        var transceiver, offer, answer;
        return _regenerator().w(function (_context9) {
          while (1) switch (_context9.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('resumeSending() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              this._remoteSdp.resumeSendingMediaSection(localId);
              if (transceiver) {
                _context9.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              transceiver.direction = 'sendonly';
              _context9.n = 2;
              return this._pc.createOffer();
            case 2:
              offer = _context9.v;
              logger.debug('resumeSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context9.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('resumeSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context9.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              return _context9.a(2);
          }
        }, _callee9, this);
      }));
      function resumeSending(_x6) {
        return _resumeSending.apply(this, arguments);
      }
      return resumeSending;
    }()
  }, {
    key: "replaceTrack",
    value: function () {
      var _replaceTrack = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee0(localId, track) {
        var transceiver;
        return _regenerator().w(function (_context0) {
          while (1) switch (_context0.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              if (track) {
                logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
              } else {
                logger.debug('replaceTrack() [localId:%s, no track]', localId);
              }
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context0.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              _context0.n = 2;
              return transceiver.sender.replaceTrack(track);
            case 2:
              return _context0.a(2);
          }
        }, _callee0, this);
      }));
      function replaceTrack(_x7, _x8) {
        return _replaceTrack.apply(this, arguments);
      }
      return replaceTrack;
    }()
  }, {
    key: "setMaxSpatialLayer",
    value: function () {
      var _setMaxSpatialLayer = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee1(localId, spatialLayer) {
        var transceiver, parameters, offer, answer;
        return _regenerator().w(function (_context1) {
          while (1) switch (_context1.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context1.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              parameters = transceiver.sender.getParameters();
              parameters.encodings.forEach(function (encoding, idx) {
                if (idx <= spatialLayer) {
                  encoding.active = true;
                } else {
                  encoding.active = false;
                }
              });
              _context1.n = 2;
              return transceiver.sender.setParameters(parameters);
            case 2:
              this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
              _context1.n = 3;
              return this._pc.createOffer();
            case 3:
              offer = _context1.v;
              logger.debug('setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context1.n = 4;
              return this._pc.setLocalDescription(offer);
            case 4:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context1.n = 5;
              return this._pc.setRemoteDescription(answer);
            case 5:
              return _context1.a(2);
          }
        }, _callee1, this);
      }));
      function setMaxSpatialLayer(_x9, _x0) {
        return _setMaxSpatialLayer.apply(this, arguments);
      }
      return setMaxSpatialLayer;
    }()
  }, {
    key: "setRtpEncodingParameters",
    value: function () {
      var _setRtpEncodingParameters = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee10(localId, params) {
        var transceiver, parameters, offer, answer;
        return _regenerator().w(function (_context10) {
          while (1) switch (_context10.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context10.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              parameters = transceiver.sender.getParameters();
              parameters.encodings.forEach(function (encoding, idx) {
                parameters.encodings[idx] = _objectSpread(_objectSpread({}, encoding), params);
              });
              _context10.n = 2;
              return transceiver.sender.setParameters(parameters);
            case 2:
              this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
              _context10.n = 3;
              return this._pc.createOffer();
            case 3:
              offer = _context10.v;
              logger.debug('setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context10.n = 4;
              return this._pc.setLocalDescription(offer);
            case 4:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context10.n = 5;
              return this._pc.setRemoteDescription(answer);
            case 5:
              return _context10.a(2);
          }
        }, _callee10, this);
      }));
      function setRtpEncodingParameters(_x1, _x10) {
        return _setRtpEncodingParameters.apply(this, arguments);
      }
      return setRtpEncodingParameters;
    }()
  }, {
    key: "getSenderStats",
    value: function () {
      var _getSenderStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee11(localId) {
        var transceiver;
        return _regenerator().w(function (_context11) {
          while (1) switch (_context11.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context11.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              return _context11.a(2, transceiver.sender.getStats());
          }
        }, _callee11, this);
      }));
      function getSenderStats(_x11) {
        return _getSenderStats.apply(this, arguments);
      }
      return getSenderStats;
    }()
  }, {
    key: "sendDataChannel",
    value: function () {
      var _sendDataChannel = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee12(_ref3) {
        var ordered, maxPacketLifeTime, maxRetransmits, label, protocol, options, dataChannel, offer, localSdpObject, offerMediaObject, _this$_forcedLocalDtl2, answer, sctpStreamParameters;
        return _regenerator().w(function (_context12) {
          while (1) switch (_context12.n) {
            case 0:
              ordered = _ref3.ordered, maxPacketLifeTime = _ref3.maxPacketLifeTime, maxRetransmits = _ref3.maxRetransmits, label = _ref3.label, protocol = _ref3.protocol;
              this.assertNotClosed();
              this.assertSendDirection();
              options = {
                negotiated: true,
                id: this._nextSendSctpStreamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmits: maxRetransmits,
                protocol: protocol
              };
              logger.debug('sendDataChannel() [options:%o]', options);
              dataChannel = this._pc.createDataChannel(label, options); // Increase next id.
              this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
              // If this is the first DataChannel we need to create the SDP answer with
              // m=application section.
              if (this._hasDataChannelMediaSection) {
                _context12.n = 5;
                break;
              }
              _context12.n = 1;
              return this._pc.createOffer();
            case 1:
              offer = _context12.v;
              localSdpObject = sdpTransform.parse(offer.sdp);
              offerMediaObject = localSdpObject.media.find(function (m) {
                return m.type === 'application';
              });
              if (this._transportReady) {
                _context12.n = 2;
                break;
              }
              _context12.n = 2;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl2 = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl2 !== void 0 ? _this$_forcedLocalDtl2 : 'client',
                localSdpObject: localSdpObject
              });
            case 2:
              logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context12.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              this._remoteSdp.sendSctpAssociation({
                offerMediaObject: offerMediaObject
              });
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context12.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              this._hasDataChannelMediaSection = true;
            case 5:
              sctpStreamParameters = {
                streamId: options.id,
                ordered: options.ordered,
                maxPacketLifeTime: options.maxPacketLifeTime,
                maxRetransmits: options.maxRetransmits
              };
              return _context12.a(2, {
                dataChannel: dataChannel,
                sctpStreamParameters: sctpStreamParameters
              });
          }
        }, _callee12, this);
      }));
      function sendDataChannel(_x12) {
        return _sendDataChannel.apply(this, arguments);
      }
      return sendDataChannel;
    }()
  }, {
    key: "receive",
    value: function () {
      var _receive = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee13(optionsList) {
        var _this3 = this;
        var results, mapLocalId, _iterator2, _step2, _rtpParameters$mid, options, trackId, kind, rtpParameters, streamId, localId, offer, answer, localSdpObject, _iterator3, _step3, _loop, _this$_forcedLocalDtl3, _iterator4, _step4, _loop2, _t2, _t3;
        return _regenerator().w(function (_context15) {
          while (1) switch (_context15.n) {
            case 0:
              this.assertNotClosed();
              this.assertRecvDirection();
              results = [];
              mapLocalId = new Map();
              _iterator2 = _createForOfIteratorHelper(optionsList);
              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  options = _step2.value;
                  trackId = options.trackId, kind = options.kind, rtpParameters = options.rtpParameters, streamId = options.streamId;
                  logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
                  localId = (_rtpParameters$mid = rtpParameters.mid) !== null && _rtpParameters$mid !== void 0 ? _rtpParameters$mid : String(this._mapMidTransceiver.size);
                  mapLocalId.set(trackId, localId);
                  this._remoteSdp.receive({
                    mid: localId,
                    kind: kind,
                    offerRtpParameters: rtpParameters,
                    streamId: streamId !== null && streamId !== void 0 ? streamId : rtpParameters.rtcp.cname,
                    trackId: trackId
                  });
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context15.n = 1;
              return this._pc.setRemoteDescription(offer);
            case 1:
              _context15.n = 2;
              return this._pc.createAnswer();
            case 2:
              answer = _context15.v;
              localSdpObject = sdpTransform.parse(answer.sdp);
              _iterator3 = _createForOfIteratorHelper(optionsList);
              _context15.p = 3;
              _loop = /*#__PURE__*/_regenerator().m(function _loop() {
                var options, trackId, rtpParameters, localId, answerMediaObject;
                return _regenerator().w(function (_context13) {
                  while (1) switch (_context13.n) {
                    case 0:
                      options = _step3.value;
                      trackId = options.trackId, rtpParameters = options.rtpParameters;
                      localId = mapLocalId.get(trackId);
                      answerMediaObject = localSdpObject.media.find(function (m) {
                        return String(m.mid) === localId;
                      }); // May need to modify codec parameters in the answer based on codec
                      // parameters in the offer.
                      sdpCommonUtils.applyCodecParameters({
                        offerRtpParameters: rtpParameters,
                        answerMediaObject: answerMediaObject
                      });
                    case 1:
                      return _context13.a(2);
                  }
                }, _loop);
              });
              _iterator3.s();
            case 4:
              if ((_step3 = _iterator3.n()).done) {
                _context15.n = 6;
                break;
              }
              return _context15.d(_regeneratorValues(_loop()), 5);
            case 5:
              _context15.n = 4;
              break;
            case 6:
              _context15.n = 8;
              break;
            case 7:
              _context15.p = 7;
              _t2 = _context15.v;
              _iterator3.e(_t2);
            case 8:
              _context15.p = 8;
              _iterator3.f();
              return _context15.f(8);
            case 9:
              answer = {
                type: 'answer',
                sdp: sdpTransform.write(localSdpObject)
              };
              if (this._transportReady) {
                _context15.n = 10;
                break;
              }
              _context15.n = 10;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl3 = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl3 !== void 0 ? _this$_forcedLocalDtl3 : 'client',
                localSdpObject: localSdpObject
              });
            case 10:
              logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context15.n = 11;
              return this._pc.setLocalDescription(answer);
            case 11:
              _iterator4 = _createForOfIteratorHelper(optionsList);
              _context15.p = 12;
              _loop2 = /*#__PURE__*/_regenerator().m(function _loop2() {
                var options, trackId, localId, transceiver;
                return _regenerator().w(function (_context14) {
                  while (1) switch (_context14.n) {
                    case 0:
                      options = _step4.value;
                      trackId = options.trackId;
                      localId = mapLocalId.get(trackId);
                      transceiver = _this3._pc.getTransceivers().find(function (t) {
                        return t.mid === localId;
                      });
                      if (transceiver) {
                        _context14.n = 1;
                        break;
                      }
                      throw new Error('new RTCRtpTransceiver not found');
                    case 1:
                      // Store in the map.
                      _this3._mapMidTransceiver.set(localId, transceiver);
                      results.push({
                        localId: localId,
                        track: transceiver.receiver.track,
                        rtpReceiver: transceiver.receiver
                      });
                    case 2:
                      return _context14.a(2);
                  }
                }, _loop2);
              });
              _iterator4.s();
            case 13:
              if ((_step4 = _iterator4.n()).done) {
                _context15.n = 15;
                break;
              }
              return _context15.d(_regeneratorValues(_loop2()), 14);
            case 14:
              _context15.n = 13;
              break;
            case 15:
              _context15.n = 17;
              break;
            case 16:
              _context15.p = 16;
              _t3 = _context15.v;
              _iterator4.e(_t3);
            case 17:
              _context15.p = 17;
              _iterator4.f();
              return _context15.f(17);
            case 18:
              return _context15.a(2, results);
          }
        }, _callee13, this, [[12, 16, 17, 18], [3, 7, 8, 9]]);
      }));
      function receive(_x13) {
        return _receive.apply(this, arguments);
      }
      return receive;
    }()
  }, {
    key: "stopReceiving",
    value: function () {
      var _stopReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee14(localIds) {
        var _iterator5, _step5, localId, transceiver, offer, answer, _iterator6, _step6, _localId, _t4;
        return _regenerator().w(function (_context16) {
          while (1) switch (_context16.n) {
            case 0:
              this.assertRecvDirection();
              if (!this._closed) {
                _context16.n = 1;
                break;
              }
              return _context16.a(2);
            case 1:
              _iterator5 = _createForOfIteratorHelper(localIds);
              _context16.p = 2;
              _iterator5.s();
            case 3:
              if ((_step5 = _iterator5.n()).done) {
                _context16.n = 6;
                break;
              }
              localId = _step5.value;
              logger.debug('stopReceiving() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context16.n = 4;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 4:
              this._remoteSdp.closeMediaSection(transceiver.mid);
            case 5:
              _context16.n = 3;
              break;
            case 6:
              _context16.n = 8;
              break;
            case 7:
              _context16.p = 7;
              _t4 = _context16.v;
              _iterator5.e(_t4);
            case 8:
              _context16.p = 8;
              _iterator5.f();
              return _context16.f(8);
            case 9:
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context16.n = 10;
              return this._pc.setRemoteDescription(offer);
            case 10:
              _context16.n = 11;
              return this._pc.createAnswer();
            case 11:
              answer = _context16.v;
              logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context16.n = 12;
              return this._pc.setLocalDescription(answer);
            case 12:
              _iterator6 = _createForOfIteratorHelper(localIds);
              try {
                for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                  _localId = _step6.value;
                  this._mapMidTransceiver["delete"](_localId);
                }
              } catch (err) {
                _iterator6.e(err);
              } finally {
                _iterator6.f();
              }
            case 13:
              return _context16.a(2);
          }
        }, _callee14, this, [[2, 7, 8, 9]]);
      }));
      function stopReceiving(_x14) {
        return _stopReceiving.apply(this, arguments);
      }
      return stopReceiving;
    }()
  }, {
    key: "pauseReceiving",
    value: function () {
      var _pauseReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee15(localIds) {
        var _iterator7, _step7, localId, transceiver, offer, answer, _t5;
        return _regenerator().w(function (_context17) {
          while (1) switch (_context17.n) {
            case 0:
              this.assertNotClosed();
              this.assertRecvDirection();
              _iterator7 = _createForOfIteratorHelper(localIds);
              _context17.p = 1;
              _iterator7.s();
            case 2:
              if ((_step7 = _iterator7.n()).done) {
                _context17.n = 5;
                break;
              }
              localId = _step7.value;
              logger.debug('pauseReceiving() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context17.n = 3;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 3:
              transceiver.direction = 'inactive';
              this._remoteSdp.pauseMediaSection(localId);
            case 4:
              _context17.n = 2;
              break;
            case 5:
              _context17.n = 7;
              break;
            case 6:
              _context17.p = 6;
              _t5 = _context17.v;
              _iterator7.e(_t5);
            case 7:
              _context17.p = 7;
              _iterator7.f();
              return _context17.f(7);
            case 8:
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context17.n = 9;
              return this._pc.setRemoteDescription(offer);
            case 9:
              _context17.n = 10;
              return this._pc.createAnswer();
            case 10:
              answer = _context17.v;
              logger.debug('pauseReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context17.n = 11;
              return this._pc.setLocalDescription(answer);
            case 11:
              return _context17.a(2);
          }
        }, _callee15, this, [[1, 6, 7, 8]]);
      }));
      function pauseReceiving(_x15) {
        return _pauseReceiving.apply(this, arguments);
      }
      return pauseReceiving;
    }()
  }, {
    key: "resumeReceiving",
    value: function () {
      var _resumeReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee16(localIds) {
        var _iterator8, _step8, localId, transceiver, offer, answer, _t6;
        return _regenerator().w(function (_context18) {
          while (1) switch (_context18.n) {
            case 0:
              this.assertNotClosed();
              this.assertRecvDirection();
              _iterator8 = _createForOfIteratorHelper(localIds);
              _context18.p = 1;
              _iterator8.s();
            case 2:
              if ((_step8 = _iterator8.n()).done) {
                _context18.n = 5;
                break;
              }
              localId = _step8.value;
              logger.debug('resumeReceiving() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context18.n = 3;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 3:
              transceiver.direction = 'recvonly';
              this._remoteSdp.resumeReceivingMediaSection(localId);
            case 4:
              _context18.n = 2;
              break;
            case 5:
              _context18.n = 7;
              break;
            case 6:
              _context18.p = 6;
              _t6 = _context18.v;
              _iterator8.e(_t6);
            case 7:
              _context18.p = 7;
              _iterator8.f();
              return _context18.f(7);
            case 8:
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context18.n = 9;
              return this._pc.setRemoteDescription(offer);
            case 9:
              _context18.n = 10;
              return this._pc.createAnswer();
            case 10:
              answer = _context18.v;
              logger.debug('resumeReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context18.n = 11;
              return this._pc.setLocalDescription(answer);
            case 11:
              return _context18.a(2);
          }
        }, _callee16, this, [[1, 6, 7, 8]]);
      }));
      function resumeReceiving(_x16) {
        return _resumeReceiving.apply(this, arguments);
      }
      return resumeReceiving;
    }()
  }, {
    key: "getReceiverStats",
    value: function () {
      var _getReceiverStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee17(localId) {
        var transceiver;
        return _regenerator().w(function (_context19) {
          while (1) switch (_context19.n) {
            case 0:
              this.assertNotClosed();
              this.assertRecvDirection();
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context19.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              return _context19.a(2, transceiver.receiver.getStats());
          }
        }, _callee17, this);
      }));
      function getReceiverStats(_x17) {
        return _getReceiverStats.apply(this, arguments);
      }
      return getReceiverStats;
    }()
  }, {
    key: "receiveDataChannel",
    value: function () {
      var _receiveDataChannel = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee18(_ref4) {
        var sctpStreamParameters, label, protocol, streamId, ordered, maxPacketLifeTime, maxRetransmits, options, dataChannel, offer, answer, _this$_forcedLocalDtl4, localSdpObject;
        return _regenerator().w(function (_context20) {
          while (1) switch (_context20.n) {
            case 0:
              sctpStreamParameters = _ref4.sctpStreamParameters, label = _ref4.label, protocol = _ref4.protocol;
              this.assertNotClosed();
              this.assertRecvDirection();
              streamId = sctpStreamParameters.streamId, ordered = sctpStreamParameters.ordered, maxPacketLifeTime = sctpStreamParameters.maxPacketLifeTime, maxRetransmits = sctpStreamParameters.maxRetransmits;
              options = {
                negotiated: true,
                id: streamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmits: maxRetransmits,
                protocol: protocol
              };
              logger.debug('receiveDataChannel() [options:%o]', options);
              dataChannel = this._pc.createDataChannel(label, options); // If this is the first DataChannel we need to create the SDP offer with
              // m=application section.
              if (this._hasDataChannelMediaSection) {
                _context20.n = 5;
                break;
              }
              this._remoteSdp.receiveSctpAssociation();
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context20.n = 1;
              return this._pc.setRemoteDescription(offer);
            case 1:
              _context20.n = 2;
              return this._pc.createAnswer();
            case 2:
              answer = _context20.v;
              if (this._transportReady) {
                _context20.n = 3;
                break;
              }
              localSdpObject = sdpTransform.parse(answer.sdp);
              _context20.n = 3;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl4 = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl4 !== void 0 ? _this$_forcedLocalDtl4 : 'client',
                localSdpObject: localSdpObject
              });
            case 3:
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context20.n = 4;
              return this._pc.setLocalDescription(answer);
            case 4:
              this._hasDataChannelMediaSection = true;
            case 5:
              return _context20.a(2, {
                dataChannel: dataChannel
              });
          }
        }, _callee18, this);
      }));
      function receiveDataChannel(_x18) {
        return _receiveDataChannel.apply(this, arguments);
      }
      return receiveDataChannel;
    }()
  }, {
    key: "setupTransport",
    value: function () {
      var _setupTransport = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee19(_ref5) {
        var _this4 = this;
        var localDtlsRole, localSdpObject, dtlsParameters;
        return _regenerator().w(function (_context21) {
          while (1) switch (_context21.n) {
            case 0:
              localDtlsRole = _ref5.localDtlsRole, localSdpObject = _ref5.localSdpObject;
              if (!localSdpObject) {
                localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
              }
              // Get our local DTLS parameters.
              dtlsParameters = sdpCommonUtils.extractDtlsParameters({
                sdpObject: localSdpObject
              }); // Set our DTLS role.
              dtlsParameters.role = localDtlsRole;
              // Update the remote DTLS role in the SDP.
              this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
              // Need to tell the remote transport about our parameters.
              _context21.n = 1;
              return new Promise(function (resolve, reject) {
                _this4.safeEmit('@connect', {
                  dtlsParameters: dtlsParameters
                }, resolve, reject);
              });
            case 1:
              this._transportReady = true;
            case 2:
              return _context21.a(2);
          }
        }, _callee19, this);
      }));
      function setupTransport(_x19) {
        return _setupTransport.apply(this, arguments);
      }
      return setupTransport;
    }()
  }, {
    key: "assertNotClosed",
    value: function assertNotClosed() {
      if (this._closed) {
        throw new errors_1.InvalidStateError('method called in a closed handler');
      }
    }
  }, {
    key: "assertSendDirection",
    value: function assertSendDirection() {
      if (this._direction !== 'send') {
        throw new Error('method can just be called for handlers with "send" direction');
      }
    }
  }, {
    key: "assertRecvDirection",
    value: function assertRecvDirection() {
      if (this._direction !== 'recv') {
        throw new Error('method can just be called for handlers with "recv" direction');
      }
    }
  }], [{
    key: "createFactory",
    value:
    /**
     * Creates a factory function.
     */
    function createFactory() {
      return function () {
        return new Chrome74();
      };
    }
  }]);
}(HandlerInterface_1.HandlerInterface);
exports.Chrome74 = Chrome74;

},{"../Logger":39,"../errors":45,"../ortc":68,"../scalabilityModes":69,"../utils":72,"./HandlerInterface":55,"./ortc/utils":61,"./sdp/RemoteSdp":63,"./sdp/commonUtils":64,"./sdp/unifiedPlanUtils":66,"sdp-transform":76}],51:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o("next", 0), o("throw", 1), o("return", 2); } }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Edge11 = void 0;
var Logger_1 = require("../Logger");
var errors_1 = require("../errors");
var utils = require("../utils");
var ortc = require("../ortc");
var edgeUtils = require("./ortc/edgeUtils");
var HandlerInterface_1 = require("./HandlerInterface");
var logger = new Logger_1.Logger('Edge11');
var NAME = 'Edge11';
var Edge11 = /*#__PURE__*/function (_HandlerInterface_1$H) {
  function Edge11() {
    var _this;
    _classCallCheck(this, Edge11);
    _this = _callSuper(this, Edge11);
    // Generic sending RTP parameters for audio and video.
    _defineProperty(_this, "_sendingRtpParametersByKind", void 0);
    // Transport remote ICE parameters.
    _defineProperty(_this, "_remoteIceParameters", void 0);
    // Transport remote ICE candidates.
    _defineProperty(_this, "_remoteIceCandidates", void 0);
    // Transport remote DTLS parameters.
    _defineProperty(_this, "_remoteDtlsParameters", void 0);
    // ICE gatherer.
    _defineProperty(_this, "_iceGatherer", void 0);
    // ICE transport.
    _defineProperty(_this, "_iceTransport", void 0);
    // DTLS transport.
    _defineProperty(_this, "_dtlsTransport", void 0);
    // Map of RTCRtpSenders indexed by id.
    _defineProperty(_this, "_rtpSenders", new Map());
    // Map of RTCRtpReceivers indexed by id.
    _defineProperty(_this, "_rtpReceivers", new Map());
    // Next localId for sending tracks.
    _defineProperty(_this, "_nextSendLocalId", 0);
    // Local RTCP CNAME.
    _defineProperty(_this, "_cname", void 0);
    // Got transport local and remote parameters.
    _defineProperty(_this, "_transportReady", false);
    return _this;
  }
  _inherits(Edge11, _HandlerInterface_1$H);
  return _createClass(Edge11, [{
    key: "name",
    get: function get() {
      return NAME;
    }
  }, {
    key: "close",
    value: function close() {
      logger.debug('close()');
      // Close the ICE gatherer.
      // NOTE: Not yet implemented by Edge.
      try {
        this._iceGatherer.close();
      } catch (error) {}
      // Close the ICE transport.
      try {
        this._iceTransport.stop();
      } catch (error) {}
      // Close the DTLS transport.
      try {
        this._dtlsTransport.stop();
      } catch (error) {}
      // Close RTCRtpSenders.
      var _iterator = _createForOfIteratorHelper(this._rtpSenders.values()),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var rtpSender = _step.value;
          try {
            rtpSender.stop();
          } catch (error) {}
        }
        // Close RTCRtpReceivers.
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      var _iterator2 = _createForOfIteratorHelper(this._rtpReceivers.values()),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var rtpReceiver = _step2.value;
          try {
            rtpReceiver.stop();
          } catch (error) {}
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      this.emit('@close');
    }
  }, {
    key: "getNativeRtpCapabilities",
    value: function () {
      var _getNativeRtpCapabilities = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {
        return _regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              logger.debug('getNativeRtpCapabilities()');
              return _context.a(2, edgeUtils.getCapabilities());
          }
        }, _callee);
      }));
      function getNativeRtpCapabilities() {
        return _getNativeRtpCapabilities.apply(this, arguments);
      }
      return getNativeRtpCapabilities;
    }()
  }, {
    key: "getNativeSctpCapabilities",
    value: function () {
      var _getNativeSctpCapabilities = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2() {
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.n) {
            case 0:
              logger.debug('getNativeSctpCapabilities()');
              return _context2.a(2, {
                numStreams: {
                  OS: 0,
                  MIS: 0
                }
              });
          }
        }, _callee2);
      }));
      function getNativeSctpCapabilities() {
        return _getNativeSctpCapabilities.apply(this, arguments);
      }
      return getNativeSctpCapabilities;
    }()
  }, {
    key: "run",
    value: function run(_ref) {
      var direction = _ref.direction,
        iceParameters = _ref.iceParameters,
        iceCandidates = _ref.iceCandidates,
        dtlsParameters = _ref.dtlsParameters,
        sctpParameters = _ref.sctpParameters,
        iceServers = _ref.iceServers,
        iceTransportPolicy = _ref.iceTransportPolicy,
        additionalSettings = _ref.additionalSettings,
        proprietaryConstraints = _ref.proprietaryConstraints,
        extendedRtpCapabilities = _ref.extendedRtpCapabilities;
      logger.debug('run()');
      this._sendingRtpParametersByKind = {
        audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
        video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
      };
      this._remoteIceParameters = iceParameters;
      this._remoteIceCandidates = iceCandidates;
      this._remoteDtlsParameters = dtlsParameters;
      this._cname = "CNAME-".concat(utils.generateRandomNumber());
      this.setIceGatherer({
        iceServers: iceServers,
        iceTransportPolicy: iceTransportPolicy
      });
      this.setIceTransport();
      this.setDtlsTransport();
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "updateIceServers",
    value: function () {
      var _updateIceServers = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(iceServers) {
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.n) {
            case 0:
              throw new errors_1.UnsupportedError('not supported');
            case 1:
              return _context3.a(2);
          }
        }, _callee3);
      }));
      function updateIceServers(_x) {
        return _updateIceServers.apply(this, arguments);
      }
      return updateIceServers;
    }()
  }, {
    key: "restartIce",
    value: function () {
      var _restartIce = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(iceParameters) {
        var _iterator3, _step3, candidate;
        return _regenerator().w(function (_context4) {
          while (1) switch (_context4.n) {
            case 0:
              logger.debug('restartIce()');
              this._remoteIceParameters = iceParameters;
              if (this._transportReady) {
                _context4.n = 1;
                break;
              }
              return _context4.a(2);
            case 1:
              logger.debug('restartIce() | calling iceTransport.start()');
              this._iceTransport.start(this._iceGatherer, iceParameters, 'controlling');
              _iterator3 = _createForOfIteratorHelper(this._remoteIceCandidates);
              try {
                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                  candidate = _step3.value;
                  this._iceTransport.addRemoteCandidate(candidate);
                }
              } catch (err) {
                _iterator3.e(err);
              } finally {
                _iterator3.f();
              }
              this._iceTransport.addRemoteCandidate({});
            case 2:
              return _context4.a(2);
          }
        }, _callee4, this);
      }));
      function restartIce(_x2) {
        return _restartIce.apply(this, arguments);
      }
      return restartIce;
    }()
  }, {
    key: "getTransportStats",
    value: function () {
      var _getTransportStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5() {
        return _regenerator().w(function (_context5) {
          while (1) switch (_context5.n) {
            case 0:
              return _context5.a(2, this._iceTransport.getStats());
          }
        }, _callee5, this);
      }));
      function getTransportStats() {
        return _getTransportStats.apply(this, arguments);
      }
      return getTransportStats;
    }()
  }, {
    key: "send",
    value: function () {
      var _send = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6(// eslint-disable-next-line @typescript-eslint/no-unused-vars
      _ref2) {
        var track, encodings, codecOptions, codec, rtpSender, rtpParameters, useRtx, _iterator4, _step4, encoding, edgeRtpParameters, localId;
        return _regenerator().w(function (_context6) {
          while (1) switch (_context6.n) {
            case 0:
              track = _ref2.track, encodings = _ref2.encodings, codecOptions = _ref2.codecOptions, codec = _ref2.codec;
              logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
              if (this._transportReady) {
                _context6.n = 1;
                break;
              }
              _context6.n = 1;
              return this.setupTransport({
                localDtlsRole: 'server'
              });
            case 1:
              logger.debug('send() | calling new RTCRtpSender()');
              rtpSender = new RTCRtpSender(track, this._dtlsTransport);
              rtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
              rtpParameters.codecs = ortc.reduceCodecs(rtpParameters.codecs, codec);
              useRtx = rtpParameters.codecs.some(function (_codec) {
                return /.+\/rtx$/i.test(_codec.mimeType);
              });
              if (!encodings) {
                encodings = [{}];
              }
              _iterator4 = _createForOfIteratorHelper(encodings);
              try {
                for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                  encoding = _step4.value;
                  encoding.ssrc = utils.generateRandomNumber();
                  if (useRtx) {
                    encoding.rtx = {
                      ssrc: utils.generateRandomNumber()
                    };
                  }
                }
              } catch (err) {
                _iterator4.e(err);
              } finally {
                _iterator4.f();
              }
              rtpParameters.encodings = encodings;
              // Fill RTCRtpParameters.rtcp.
              rtpParameters.rtcp = {
                cname: this._cname,
                reducedSize: true,
                mux: true
              };
              // NOTE: Convert our standard RTCRtpParameters into those that Edge
              // expects.
              edgeRtpParameters = edgeUtils.mangleRtpParameters(rtpParameters);
              logger.debug('send() | calling rtpSender.send() [params:%o]', edgeRtpParameters);
              _context6.n = 2;
              return rtpSender.send(edgeRtpParameters);
            case 2:
              localId = String(this._nextSendLocalId);
              this._nextSendLocalId++;
              // Store it.
              this._rtpSenders.set(localId, rtpSender);
              return _context6.a(2, {
                localId: localId,
                rtpParameters: rtpParameters,
                rtpSender: rtpSender
              });
          }
        }, _callee6, this);
      }));
      function send(_x3) {
        return _send.apply(this, arguments);
      }
      return send;
    }()
  }, {
    key: "stopSending",
    value: function () {
      var _stopSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7(localId) {
        var rtpSender, _t;
        return _regenerator().w(function (_context7) {
          while (1) switch (_context7.n) {
            case 0:
              logger.debug('stopSending() [localId:%s]', localId);
              rtpSender = this._rtpSenders.get(localId);
              if (rtpSender) {
                _context7.n = 1;
                break;
              }
              throw new Error('RTCRtpSender not found');
            case 1:
              this._rtpSenders["delete"](localId);
              _context7.p = 2;
              logger.debug('stopSending() | calling rtpSender.stop()');
              rtpSender.stop();
              _context7.n = 4;
              break;
            case 3:
              _context7.p = 3;
              _t = _context7.v;
              logger.warn('stopSending() | rtpSender.stop() failed:%o', _t);
              throw _t;
            case 4:
              return _context7.a(2);
          }
        }, _callee7, this, [[2, 3]]);
      }));
      function stopSending(_x4) {
        return _stopSending.apply(this, arguments);
      }
      return stopSending;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "pauseSending",
    value: function () {
      var _pauseSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8(localId) {
        return _regenerator().w(function (_context8) {
          while (1) switch (_context8.n) {
            case 0:
              return _context8.a(2);
          }
        }, _callee8);
      }));
      function pauseSending(_x5) {
        return _pauseSending.apply(this, arguments);
      }
      return pauseSending;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "resumeSending",
    value: function () {
      var _resumeSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee9(localId) {
        return _regenerator().w(function (_context9) {
          while (1) switch (_context9.n) {
            case 0:
              return _context9.a(2);
          }
        }, _callee9);
      }));
      function resumeSending(_x6) {
        return _resumeSending.apply(this, arguments);
      }
      return resumeSending;
    }()
  }, {
    key: "replaceTrack",
    value: function () {
      var _replaceTrack = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee0(localId, track) {
        var rtpSender;
        return _regenerator().w(function (_context0) {
          while (1) switch (_context0.n) {
            case 0:
              if (track) {
                logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
              } else {
                logger.debug('replaceTrack() [localId:%s, no track]', localId);
              }
              rtpSender = this._rtpSenders.get(localId);
              if (rtpSender) {
                _context0.n = 1;
                break;
              }
              throw new Error('RTCRtpSender not found');
            case 1:
              rtpSender.setTrack(track);
            case 2:
              return _context0.a(2);
          }
        }, _callee0, this);
      }));
      function replaceTrack(_x7, _x8) {
        return _replaceTrack.apply(this, arguments);
      }
      return replaceTrack;
    }()
  }, {
    key: "setMaxSpatialLayer",
    value: function () {
      var _setMaxSpatialLayer = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee1(localId, spatialLayer) {
        var rtpSender, parameters;
        return _regenerator().w(function (_context1) {
          while (1) switch (_context1.n) {
            case 0:
              logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
              rtpSender = this._rtpSenders.get(localId);
              if (rtpSender) {
                _context1.n = 1;
                break;
              }
              throw new Error('RTCRtpSender not found');
            case 1:
              parameters = rtpSender.getParameters();
              parameters.encodings.forEach(function (encoding, idx) {
                if (idx <= spatialLayer) {
                  encoding.active = true;
                } else {
                  encoding.active = false;
                }
              });
              _context1.n = 2;
              return rtpSender.setParameters(parameters);
            case 2:
              return _context1.a(2);
          }
        }, _callee1, this);
      }));
      function setMaxSpatialLayer(_x9, _x0) {
        return _setMaxSpatialLayer.apply(this, arguments);
      }
      return setMaxSpatialLayer;
    }()
  }, {
    key: "setRtpEncodingParameters",
    value: function () {
      var _setRtpEncodingParameters = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee10(localId, params) {
        var rtpSender, parameters;
        return _regenerator().w(function (_context10) {
          while (1) switch (_context10.n) {
            case 0:
              logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
              rtpSender = this._rtpSenders.get(localId);
              if (rtpSender) {
                _context10.n = 1;
                break;
              }
              throw new Error('RTCRtpSender not found');
            case 1:
              parameters = rtpSender.getParameters();
              parameters.encodings.forEach(function (encoding, idx) {
                parameters.encodings[idx] = _objectSpread(_objectSpread({}, encoding), params);
              });
              _context10.n = 2;
              return rtpSender.setParameters(parameters);
            case 2:
              return _context10.a(2);
          }
        }, _callee10, this);
      }));
      function setRtpEncodingParameters(_x1, _x10) {
        return _setRtpEncodingParameters.apply(this, arguments);
      }
      return setRtpEncodingParameters;
    }()
  }, {
    key: "getSenderStats",
    value: function () {
      var _getSenderStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee11(localId) {
        var rtpSender;
        return _regenerator().w(function (_context11) {
          while (1) switch (_context11.n) {
            case 0:
              rtpSender = this._rtpSenders.get(localId);
              if (rtpSender) {
                _context11.n = 1;
                break;
              }
              throw new Error('RTCRtpSender not found');
            case 1:
              return _context11.a(2, rtpSender.getStats());
          }
        }, _callee11, this);
      }));
      function getSenderStats(_x11) {
        return _getSenderStats.apply(this, arguments);
      }
      return getSenderStats;
    }()
  }, {
    key: "sendDataChannel",
    value: function () {
      var _sendDataChannel = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee12(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      options) {
        return _regenerator().w(function (_context12) {
          while (1) switch (_context12.n) {
            case 0:
              throw new errors_1.UnsupportedError('not implemented');
            case 1:
              return _context12.a(2);
          }
        }, _callee12);
      }));
      function sendDataChannel(_x12) {
        return _sendDataChannel.apply(this, arguments);
      }
      return sendDataChannel;
    }()
  }, {
    key: "receive",
    value: function () {
      var _receive = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee13(optionsList) {
        var results, _iterator5, _step5, options, trackId, kind, _iterator6, _step6, _options, _trackId, _kind, rtpParameters, rtpReceiver, edgeRtpParameters, localId, _t2;
        return _regenerator().w(function (_context13) {
          while (1) switch (_context13.n) {
            case 0:
              results = [];
              _iterator5 = _createForOfIteratorHelper(optionsList);
              try {
                for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                  options = _step5.value;
                  trackId = options.trackId, kind = options.kind;
                  logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
                }
              } catch (err) {
                _iterator5.e(err);
              } finally {
                _iterator5.f();
              }
              if (this._transportReady) {
                _context13.n = 1;
                break;
              }
              _context13.n = 1;
              return this.setupTransport({
                localDtlsRole: 'server'
              });
            case 1:
              _iterator6 = _createForOfIteratorHelper(optionsList);
              _context13.p = 2;
              _iterator6.s();
            case 3:
              if ((_step6 = _iterator6.n()).done) {
                _context13.n = 6;
                break;
              }
              _options = _step6.value;
              _trackId = _options.trackId, _kind = _options.kind, rtpParameters = _options.rtpParameters;
              logger.debug('receive() | calling new RTCRtpReceiver()');
              rtpReceiver = new RTCRtpReceiver(this._dtlsTransport, _kind);
              rtpReceiver.addEventListener('error', function (event) {
                logger.error('rtpReceiver "error" event [event:%o]', event);
              });
              // NOTE: Convert our standard RTCRtpParameters into those that Edge
              // expects.
              edgeRtpParameters = edgeUtils.mangleRtpParameters(rtpParameters);
              logger.debug('receive() | calling rtpReceiver.receive() [params:%o]', edgeRtpParameters);
              _context13.n = 4;
              return rtpReceiver.receive(edgeRtpParameters);
            case 4:
              localId = _trackId; // Store it.
              this._rtpReceivers.set(localId, rtpReceiver);
              results.push({
                localId: localId,
                track: rtpReceiver.track,
                rtpReceiver: rtpReceiver
              });
            case 5:
              _context13.n = 3;
              break;
            case 6:
              _context13.n = 8;
              break;
            case 7:
              _context13.p = 7;
              _t2 = _context13.v;
              _iterator6.e(_t2);
            case 8:
              _context13.p = 8;
              _iterator6.f();
              return _context13.f(8);
            case 9:
              return _context13.a(2, results);
          }
        }, _callee13, this, [[2, 7, 8, 9]]);
      }));
      function receive(_x13) {
        return _receive.apply(this, arguments);
      }
      return receive;
    }()
  }, {
    key: "stopReceiving",
    value: function () {
      var _stopReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee14(localIds) {
        var _iterator7, _step7, localId, rtpReceiver, _t3;
        return _regenerator().w(function (_context14) {
          while (1) switch (_context14.n) {
            case 0:
              _iterator7 = _createForOfIteratorHelper(localIds);
              _context14.p = 1;
              _iterator7.s();
            case 2:
              if ((_step7 = _iterator7.n()).done) {
                _context14.n = 5;
                break;
              }
              localId = _step7.value;
              logger.debug('stopReceiving() [localId:%s]', localId);
              rtpReceiver = this._rtpReceivers.get(localId);
              if (rtpReceiver) {
                _context14.n = 3;
                break;
              }
              throw new Error('RTCRtpReceiver not found');
            case 3:
              this._rtpReceivers["delete"](localId);
              try {
                logger.debug('stopReceiving() | calling rtpReceiver.stop()');
                rtpReceiver.stop();
              } catch (error) {
                logger.warn('stopReceiving() | rtpReceiver.stop() failed:%o', error);
              }
            case 4:
              _context14.n = 2;
              break;
            case 5:
              _context14.n = 7;
              break;
            case 6:
              _context14.p = 6;
              _t3 = _context14.v;
              _iterator7.e(_t3);
            case 7:
              _context14.p = 7;
              _iterator7.f();
              return _context14.f(7);
            case 8:
              return _context14.a(2);
          }
        }, _callee14, this, [[1, 6, 7, 8]]);
      }));
      function stopReceiving(_x14) {
        return _stopReceiving.apply(this, arguments);
      }
      return stopReceiving;
    }()
  }, {
    key: "pauseReceiving",
    value: function () {
      var _pauseReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee15(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      localIds) {
        return _regenerator().w(function (_context15) {
          while (1) switch (_context15.n) {
            case 0:
              return _context15.a(2);
          }
        }, _callee15);
      }));
      function pauseReceiving(_x15) {
        return _pauseReceiving.apply(this, arguments);
      }
      return pauseReceiving;
    }()
  }, {
    key: "resumeReceiving",
    value: function () {
      var _resumeReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee16(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      localIds) {
        return _regenerator().w(function (_context16) {
          while (1) switch (_context16.n) {
            case 0:
              return _context16.a(2);
          }
        }, _callee16);
      }));
      function resumeReceiving(_x16) {
        return _resumeReceiving.apply(this, arguments);
      }
      return resumeReceiving;
    }()
  }, {
    key: "getReceiverStats",
    value: function () {
      var _getReceiverStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee17(localId) {
        var rtpReceiver;
        return _regenerator().w(function (_context17) {
          while (1) switch (_context17.n) {
            case 0:
              rtpReceiver = this._rtpReceivers.get(localId);
              if (rtpReceiver) {
                _context17.n = 1;
                break;
              }
              throw new Error('RTCRtpReceiver not found');
            case 1:
              return _context17.a(2, rtpReceiver.getStats());
          }
        }, _callee17, this);
      }));
      function getReceiverStats(_x17) {
        return _getReceiverStats.apply(this, arguments);
      }
      return getReceiverStats;
    }()
  }, {
    key: "receiveDataChannel",
    value: function () {
      var _receiveDataChannel = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee18(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      options) {
        return _regenerator().w(function (_context18) {
          while (1) switch (_context18.n) {
            case 0:
              throw new errors_1.UnsupportedError('not implemented');
            case 1:
              return _context18.a(2);
          }
        }, _callee18);
      }));
      function receiveDataChannel(_x18) {
        return _receiveDataChannel.apply(this, arguments);
      }
      return receiveDataChannel;
    }()
  }, {
    key: "setIceGatherer",
    value: function setIceGatherer(_ref3) {
      var iceServers = _ref3.iceServers,
        iceTransportPolicy = _ref3.iceTransportPolicy;
      // @ts-expect-error --- On purpose
      var iceGatherer = new RTCIceGatherer({
        iceServers: iceServers !== null && iceServers !== void 0 ? iceServers : [],
        gatherPolicy: iceTransportPolicy !== null && iceTransportPolicy !== void 0 ? iceTransportPolicy : 'all'
      });
      iceGatherer.addEventListener('error', function (event) {
        logger.error('iceGatherer "error" event [event:%o]', event);
      });
      // NOTE: Not yet implemented by Edge, which starts gathering automatically.
      try {
        iceGatherer.gather();
      } catch (error) {
        logger.debug('setIceGatherer() | iceGatherer.gather() failed: %s', error.toString());
      }
      this._iceGatherer = iceGatherer;
    }
  }, {
    key: "setIceTransport",
    value: function setIceTransport() {
      var _this2 = this;
      var iceTransport = new RTCIceTransport(this._iceGatherer);
      // NOTE: Not yet implemented by Edge.
      iceTransport.addEventListener('statechange', function () {
        switch (iceTransport.state) {
          case 'checking':
            {
              _this2.emit('@connectionstatechange', 'connecting');
              break;
            }
          case 'connected':
          case 'completed':
            {
              _this2.emit('@connectionstatechange', 'connected');
              break;
            }
          case 'failed':
            {
              _this2.emit('@connectionstatechange', 'failed');
              break;
            }
          case 'disconnected':
            {
              _this2.emit('@connectionstatechange', 'disconnected');
              break;
            }
          case 'closed':
            {
              _this2.emit('@connectionstatechange', 'closed');
              break;
            }
        }
      });
      // NOTE: Not standard, but implemented by Edge.
      iceTransport.addEventListener('icestatechange', function () {
        switch (iceTransport.state) {
          case 'checking':
            {
              _this2.emit('@connectionstatechange', 'connecting');
              break;
            }
          case 'connected':
          case 'completed':
            {
              _this2.emit('@connectionstatechange', 'connected');
              break;
            }
          case 'failed':
            {
              _this2.emit('@connectionstatechange', 'failed');
              break;
            }
          case 'disconnected':
            {
              _this2.emit('@connectionstatechange', 'disconnected');
              break;
            }
          case 'closed':
            {
              _this2.emit('@connectionstatechange', 'closed');
              break;
            }
        }
      });
      iceTransport.addEventListener('candidatepairchange', function (event) {
        logger.debug('iceTransport "candidatepairchange" event [pair:%o]', event.pair);
      });
      this._iceTransport = iceTransport;
    }
  }, {
    key: "setDtlsTransport",
    value: function setDtlsTransport() {
      var _this3 = this;
      var dtlsTransport = new RTCDtlsTransport(this._iceTransport);
      // NOTE: Not yet implemented by Edge.
      dtlsTransport.addEventListener('statechange', function () {
        logger.debug('dtlsTransport "statechange" event [state:%s]', dtlsTransport.state);
      });
      // NOTE: Not standard, but implemented by Edge.
      dtlsTransport.addEventListener('dtlsstatechange', function () {
        logger.debug('dtlsTransport "dtlsstatechange" event [state:%s]', dtlsTransport.state);
        if (dtlsTransport.state === 'closed') {
          _this3.emit('@connectionstatechange', 'closed');
        }
      });
      dtlsTransport.addEventListener('error', function (event) {
        logger.error('dtlsTransport "error" event [event:%o]', event);
      });
      this._dtlsTransport = dtlsTransport;
    }
  }, {
    key: "setupTransport",
    value: function () {
      var _setupTransport = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee19(_ref4) {
        var _this4 = this;
        var localDtlsRole, dtlsParameters, _iterator8, _step8, candidate;
        return _regenerator().w(function (_context19) {
          while (1) switch (_context19.n) {
            case 0:
              localDtlsRole = _ref4.localDtlsRole;
              logger.debug('setupTransport()');
              // Get our local DTLS parameters.
              dtlsParameters = this._dtlsTransport.getLocalParameters();
              dtlsParameters.role = localDtlsRole;
              // Need to tell the remote transport about our parameters.
              _context19.n = 1;
              return new Promise(function (resolve, reject) {
                _this4.safeEmit('@connect', {
                  dtlsParameters: dtlsParameters
                }, resolve, reject);
              });
            case 1:
              // Start the RTCIceTransport.
              this._iceTransport.start(this._iceGatherer, this._remoteIceParameters, 'controlling');
              // Add remote ICE candidates.
              _iterator8 = _createForOfIteratorHelper(this._remoteIceCandidates);
              try {
                for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
                  candidate = _step8.value;
                  this._iceTransport.addRemoteCandidate(candidate);
                }
                // Also signal a 'complete' candidate as per spec.
                // NOTE: It should be {complete: true} but Edge prefers {}.
                // NOTE: If we don't signal end of candidates, the Edge RTCIceTransport
                // won't enter the 'completed' state.
              } catch (err) {
                _iterator8.e(err);
              } finally {
                _iterator8.f();
              }
              this._iceTransport.addRemoteCandidate({});
              // NOTE: Edge does not like SHA less than 256.
              this._remoteDtlsParameters.fingerprints = this._remoteDtlsParameters.fingerprints.filter(function (fingerprint) {
                return fingerprint.algorithm === 'sha-256' || fingerprint.algorithm === 'sha-384' || fingerprint.algorithm === 'sha-512';
              });
              // Start the RTCDtlsTransport.
              this._dtlsTransport.start(this._remoteDtlsParameters);
              this._transportReady = true;
            case 2:
              return _context19.a(2);
          }
        }, _callee19, this);
      }));
      function setupTransport(_x19) {
        return _setupTransport.apply(this, arguments);
      }
      return setupTransport;
    }()
  }], [{
    key: "createFactory",
    value:
    /**
     * Creates a factory function.
     */
    function createFactory() {
      return function () {
        return new Edge11();
      };
    }
  }]);
}(HandlerInterface_1.HandlerInterface);
exports.Edge11 = Edge11;

},{"../Logger":39,"../errors":45,"../ortc":68,"../utils":72,"./HandlerInterface":55,"./ortc/edgeUtils":60}],52:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o("next", 0), o("throw", 1), o("return", 2); } }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FakeHandler = void 0;
var fake_mediastreamtrack_1 = require("fake-mediastreamtrack");
var enhancedEvents_1 = require("../enhancedEvents");
var Logger_1 = require("../Logger");
var utils = require("../utils");
var ortc = require("../ortc");
var errors_1 = require("../errors");
var HandlerInterface_1 = require("./HandlerInterface");
var logger = new Logger_1.Logger('FakeHandler');
var NAME = 'FakeHandler';
var FakeDataChannel = /*#__PURE__*/function (_enhancedEvents_1$Enh) {
  function FakeDataChannel(_ref) {
    var _this;
    var id = _ref.id,
      ordered = _ref.ordered,
      maxPacketLifeTime = _ref.maxPacketLifeTime,
      maxRetransmits = _ref.maxRetransmits,
      label = _ref.label,
      protocol = _ref.protocol;
    _classCallCheck(this, FakeDataChannel);
    _this = _callSuper(this, FakeDataChannel);
    _defineProperty(_this, "id", void 0);
    _defineProperty(_this, "ordered", void 0);
    _defineProperty(_this, "maxPacketLifeTime", void 0);
    _defineProperty(_this, "maxRetransmits", void 0);
    _defineProperty(_this, "label", void 0);
    _defineProperty(_this, "protocol", void 0);
    _this.id = id;
    _this.ordered = ordered;
    _this.maxPacketLifeTime = maxPacketLifeTime;
    _this.maxRetransmits = maxRetransmits;
    _this.label = label;
    _this.protocol = protocol;
    return _this;
  }
  _inherits(FakeDataChannel, _enhancedEvents_1$Enh);
  return _createClass(FakeDataChannel, [{
    key: "close",
    value: function close() {
      this.safeEmit('close');
      this.emit('@close');
    }
  }, {
    key: "send",
    value: function send(data) {
      this.safeEmit('message', data);
    }
  }, {
    key: "addEventListener",
    value: function addEventListener(event, fn) {
      this.on(event, fn);
    }
  }]);
}(enhancedEvents_1.EnhancedEventEmitter);
var FakeHandler = /*#__PURE__*/function (_HandlerInterface_1$H) {
  function FakeHandler(fakeParameters) {
    var _this2;
    _classCallCheck(this, FakeHandler);
    _this2 = _callSuper(this, FakeHandler);
    // Closed flag.
    _defineProperty(_this2, "_closed", false);
    // Fake parameters source of RTP and SCTP parameters and capabilities.
    _defineProperty(_this2, "fakeParameters", void 0);
    // Generic sending RTP parameters for audio and video.
    _defineProperty(_this2, "_rtpParametersByKind", void 0);
    // Local RTCP CNAME.
    _defineProperty(_this2, "_cname", "CNAME-".concat(utils.generateRandomNumber()));
    // Got transport local and remote parameters.
    _defineProperty(_this2, "_transportReady", false);
    // Next localId.
    _defineProperty(_this2, "_nextLocalId", 1);
    // Sending and receiving tracks indexed by localId.
    _defineProperty(_this2, "_tracks", new Map());
    // DataChannel id value counter. It must be incremented for each new DataChannel.
    _defineProperty(_this2, "_nextSctpStreamId", 0);
    _this2.fakeParameters = fakeParameters;
    return _this2;
  }
  _inherits(FakeHandler, _HandlerInterface_1$H);
  return _createClass(FakeHandler, [{
    key: "name",
    get: function get() {
      return NAME;
    }
  }, {
    key: "close",
    value: function close() {
      logger.debug('close()');
      if (this._closed) {
        return;
      }
      this._closed = true;
    }
    // NOTE: Custom method for simulation purposes.
  }, {
    key: "setIceGatheringState",
    value: function setIceGatheringState(iceGatheringState) {
      this.emit('@icegatheringstatechange', iceGatheringState);
    }
    // NOTE: Custom method for simulation purposes.
  }, {
    key: "setConnectionState",
    value: function setConnectionState(connectionState) {
      this.emit('@connectionstatechange', connectionState);
    }
  }, {
    key: "getNativeRtpCapabilities",
    value: function () {
      var _getNativeRtpCapabilities = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {
        return _regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              logger.debug('getNativeRtpCapabilities()');
              return _context.a(2, this.fakeParameters.generateNativeRtpCapabilities());
          }
        }, _callee, this);
      }));
      function getNativeRtpCapabilities() {
        return _getNativeRtpCapabilities.apply(this, arguments);
      }
      return getNativeRtpCapabilities;
    }()
  }, {
    key: "getNativeSctpCapabilities",
    value: function () {
      var _getNativeSctpCapabilities = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2() {
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.n) {
            case 0:
              logger.debug('getNativeSctpCapabilities()');
              return _context2.a(2, this.fakeParameters.generateNativeSctpCapabilities());
          }
        }, _callee2, this);
      }));
      function getNativeSctpCapabilities() {
        return _getNativeSctpCapabilities.apply(this, arguments);
      }
      return getNativeSctpCapabilities;
    }()
  }, {
    key: "run",
    value: function run(_ref2) {
      var direction = _ref2.direction,
        iceParameters = _ref2.iceParameters,
        iceCandidates = _ref2.iceCandidates,
        dtlsParameters = _ref2.dtlsParameters,
        sctpParameters = _ref2.sctpParameters,
        iceServers = _ref2.iceServers,
        iceTransportPolicy = _ref2.iceTransportPolicy,
        proprietaryConstraints = _ref2.proprietaryConstraints,
        extendedRtpCapabilities = _ref2.extendedRtpCapabilities;
      this.assertNotClosed();
      logger.debug('run()');
      // Generic sending RTP parameters for audio and video.
      // @type {Object}
      this._rtpParametersByKind = {
        audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
        video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
      };
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "updateIceServers",
    value: function () {
      var _updateIceServers = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(iceServers) {
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.n) {
            case 0:
              this.assertNotClosed();
              logger.debug('updateIceServers()');
            case 1:
              return _context3.a(2);
          }
        }, _callee3, this);
      }));
      function updateIceServers(_x) {
        return _updateIceServers.apply(this, arguments);
      }
      return updateIceServers;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "restartIce",
    value: function () {
      var _restartIce = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(iceParameters) {
        return _regenerator().w(function (_context4) {
          while (1) switch (_context4.n) {
            case 0:
              this.assertNotClosed();
              logger.debug('restartIce()');
            case 1:
              return _context4.a(2);
          }
        }, _callee4, this);
      }));
      function restartIce(_x2) {
        return _restartIce.apply(this, arguments);
      }
      return restartIce;
    }()
  }, {
    key: "getTransportStats",
    value: function () {
      var _getTransportStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5() {
        return _regenerator().w(function (_context5) {
          while (1) switch (_context5.n) {
            case 0:
              this.assertNotClosed();
              return _context5.a(2, new Map());
          }
        }, _callee5, this);
      }));
      function getTransportStats() {
        return _getTransportStats.apply(this, arguments);
      }
      return getTransportStats;
    }()
  }, {
    key: "send",
    value: function () {
      var _send = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6(// eslint-disable-next-line @typescript-eslint/no-unused-vars
      _ref3) {
        var track, encodings, codecOptions, codec, rtpParameters, useRtx, _iterator, _step, encoding, localId;
        return _regenerator().w(function (_context6) {
          while (1) switch (_context6.n) {
            case 0:
              track = _ref3.track, encodings = _ref3.encodings, codecOptions = _ref3.codecOptions, codec = _ref3.codec;
              this.assertNotClosed();
              logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
              if (this._transportReady) {
                _context6.n = 1;
                break;
              }
              _context6.n = 1;
              return this.setupTransport({
                localDtlsRole: 'server'
              });
            case 1:
              rtpParameters = utils.clone(this._rtpParametersByKind[track.kind]);
              useRtx = rtpParameters.codecs.some(function (_codec) {
                return /.+\/rtx$/i.test(_codec.mimeType);
              });
              rtpParameters.mid = "mid-".concat(utils.generateRandomNumber());
              if (!encodings) {
                encodings = [{}];
              }
              _iterator = _createForOfIteratorHelper(encodings);
              try {
                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                  encoding = _step.value;
                  encoding.ssrc = utils.generateRandomNumber();
                  if (useRtx) {
                    encoding.rtx = {
                      ssrc: utils.generateRandomNumber()
                    };
                  }
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
              rtpParameters.encodings = encodings;
              // Fill RTCRtpParameters.rtcp.
              rtpParameters.rtcp = {
                cname: this._cname,
                reducedSize: true,
                mux: true
              };
              localId = this._nextLocalId++;
              this._tracks.set(localId, track);
              return _context6.a(2, {
                localId: String(localId),
                rtpParameters: rtpParameters
              });
          }
        }, _callee6, this);
      }));
      function send(_x3) {
        return _send.apply(this, arguments);
      }
      return send;
    }()
  }, {
    key: "stopSending",
    value: function () {
      var _stopSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7(localId) {
        return _regenerator().w(function (_context7) {
          while (1) switch (_context7.n) {
            case 0:
              logger.debug('stopSending() [localId:%s]', localId);
              if (!this._closed) {
                _context7.n = 1;
                break;
              }
              return _context7.a(2);
            case 1:
              if (this._tracks.has(Number(localId))) {
                _context7.n = 2;
                break;
              }
              throw new Error('local track not found');
            case 2:
              this._tracks["delete"](Number(localId));
            case 3:
              return _context7.a(2);
          }
        }, _callee7, this);
      }));
      function stopSending(_x4) {
        return _stopSending.apply(this, arguments);
      }
      return stopSending;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "pauseSending",
    value: function () {
      var _pauseSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8(localId) {
        return _regenerator().w(function (_context8) {
          while (1) switch (_context8.n) {
            case 0:
              this.assertNotClosed();
              // Unimplemented.
            case 1:
              return _context8.a(2);
          }
        }, _callee8, this);
      }));
      function pauseSending(_x5) {
        return _pauseSending.apply(this, arguments);
      }
      return pauseSending;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "resumeSending",
    value: function () {
      var _resumeSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee9(localId) {
        return _regenerator().w(function (_context9) {
          while (1) switch (_context9.n) {
            case 0:
              this.assertNotClosed();
              // Unimplemented.
            case 1:
              return _context9.a(2);
          }
        }, _callee9, this);
      }));
      function resumeSending(_x6) {
        return _resumeSending.apply(this, arguments);
      }
      return resumeSending;
    }()
  }, {
    key: "replaceTrack",
    value: function () {
      var _replaceTrack = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee0(localId, track) {
        return _regenerator().w(function (_context0) {
          while (1) switch (_context0.n) {
            case 0:
              this.assertNotClosed();
              if (track) {
                logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
              } else {
                logger.debug('replaceTrack() [localId:%s, no track]', localId);
              }
              this._tracks["delete"](Number(localId));
              this._tracks.set(Number(localId), track);
            case 1:
              return _context0.a(2);
          }
        }, _callee0, this);
      }));
      function replaceTrack(_x7, _x8) {
        return _replaceTrack.apply(this, arguments);
      }
      return replaceTrack;
    }()
  }, {
    key: "setMaxSpatialLayer",
    value: function () {
      var _setMaxSpatialLayer = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee1(localId, spatialLayer) {
        return _regenerator().w(function (_context1) {
          while (1) switch (_context1.n) {
            case 0:
              this.assertNotClosed();
              logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
            case 1:
              return _context1.a(2);
          }
        }, _callee1, this);
      }));
      function setMaxSpatialLayer(_x9, _x0) {
        return _setMaxSpatialLayer.apply(this, arguments);
      }
      return setMaxSpatialLayer;
    }()
  }, {
    key: "setRtpEncodingParameters",
    value: function () {
      var _setRtpEncodingParameters = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee10(localId, params) {
        return _regenerator().w(function (_context10) {
          while (1) switch (_context10.n) {
            case 0:
              this.assertNotClosed();
              logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
            case 1:
              return _context10.a(2);
          }
        }, _callee10, this);
      }));
      function setRtpEncodingParameters(_x1, _x10) {
        return _setRtpEncodingParameters.apply(this, arguments);
      }
      return setRtpEncodingParameters;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "getSenderStats",
    value: function () {
      var _getSenderStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee11(localId) {
        return _regenerator().w(function (_context11) {
          while (1) switch (_context11.n) {
            case 0:
              this.assertNotClosed();
              return _context11.a(2, new Map());
          }
        }, _callee11, this);
      }));
      function getSenderStats(_x11) {
        return _getSenderStats.apply(this, arguments);
      }
      return getSenderStats;
    }()
  }, {
    key: "sendDataChannel",
    value: function () {
      var _sendDataChannel = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee12(_ref4) {
        var ordered, maxPacketLifeTime, maxRetransmits, label, protocol, dataChannel, sctpStreamParameters;
        return _regenerator().w(function (_context12) {
          while (1) switch (_context12.n) {
            case 0:
              ordered = _ref4.ordered, maxPacketLifeTime = _ref4.maxPacketLifeTime, maxRetransmits = _ref4.maxRetransmits, label = _ref4.label, protocol = _ref4.protocol;
              this.assertNotClosed();
              if (this._transportReady) {
                _context12.n = 1;
                break;
              }
              _context12.n = 1;
              return this.setupTransport({
                localDtlsRole: 'server'
              });
            case 1:
              logger.debug('sendDataChannel()');
              dataChannel = new FakeDataChannel({
                id: this._nextSctpStreamId++,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmits: maxRetransmits,
                label: label,
                protocol: protocol
              });
              sctpStreamParameters = {
                streamId: this._nextSctpStreamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmits: maxRetransmits
              }; // @ts-expect-error --- On purpose.
              return _context12.a(2, {
                dataChannel: dataChannel,
                sctpStreamParameters: sctpStreamParameters
              });
          }
        }, _callee12, this);
      }));
      function sendDataChannel(_x12) {
        return _sendDataChannel.apply(this, arguments);
      }
      return sendDataChannel;
    }()
  }, {
    key: "receive",
    value: function () {
      var _receive = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee13(optionsList) {
        var results, _iterator2, _step2, options, trackId, kind, localId, track, _t;
        return _regenerator().w(function (_context13) {
          while (1) switch (_context13.n) {
            case 0:
              this.assertNotClosed();
              results = [];
              _iterator2 = _createForOfIteratorHelper(optionsList);
              _context13.p = 1;
              _iterator2.s();
            case 2:
              if ((_step2 = _iterator2.n()).done) {
                _context13.n = 5;
                break;
              }
              options = _step2.value;
              trackId = options.trackId, kind = options.kind;
              if (this._transportReady) {
                _context13.n = 3;
                break;
              }
              _context13.n = 3;
              return this.setupTransport({
                localDtlsRole: 'client'
              });
            case 3:
              logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
              localId = this._nextLocalId++;
              track = new fake_mediastreamtrack_1.FakeMediaStreamTrack({
                kind: kind
              });
              this._tracks.set(localId, track);
              results.push({
                localId: String(localId),
                track: track
              });
            case 4:
              _context13.n = 2;
              break;
            case 5:
              _context13.n = 7;
              break;
            case 6:
              _context13.p = 6;
              _t = _context13.v;
              _iterator2.e(_t);
            case 7:
              _context13.p = 7;
              _iterator2.f();
              return _context13.f(7);
            case 8:
              return _context13.a(2, results);
          }
        }, _callee13, this, [[1, 6, 7, 8]]);
      }));
      function receive(_x13) {
        return _receive.apply(this, arguments);
      }
      return receive;
    }()
  }, {
    key: "stopReceiving",
    value: function () {
      var _stopReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee14(localIds) {
        var _iterator3, _step3, localId;
        return _regenerator().w(function (_context14) {
          while (1) switch (_context14.n) {
            case 0:
              if (!this._closed) {
                _context14.n = 1;
                break;
              }
              return _context14.a(2);
            case 1:
              _iterator3 = _createForOfIteratorHelper(localIds);
              try {
                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                  localId = _step3.value;
                  logger.debug('stopReceiving() [localId:%s]', localId);
                  this._tracks["delete"](Number(localId));
                }
              } catch (err) {
                _iterator3.e(err);
              } finally {
                _iterator3.f();
              }
            case 2:
              return _context14.a(2);
          }
        }, _callee14, this);
      }));
      function stopReceiving(_x14) {
        return _stopReceiving.apply(this, arguments);
      }
      return stopReceiving;
    }()
  }, {
    key: "pauseReceiving",
    value: function () {
      var _pauseReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee15(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      localIds) {
        return _regenerator().w(function (_context15) {
          while (1) switch (_context15.n) {
            case 0:
              this.assertNotClosed();
              // Unimplemented.
            case 1:
              return _context15.a(2);
          }
        }, _callee15, this);
      }));
      function pauseReceiving(_x15) {
        return _pauseReceiving.apply(this, arguments);
      }
      return pauseReceiving;
    }()
  }, {
    key: "resumeReceiving",
    value: function () {
      var _resumeReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee16(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      localIds) {
        return _regenerator().w(function (_context16) {
          while (1) switch (_context16.n) {
            case 0:
              this.assertNotClosed();
              // Unimplemented.
            case 1:
              return _context16.a(2);
          }
        }, _callee16, this);
      }));
      function resumeReceiving(_x16) {
        return _resumeReceiving.apply(this, arguments);
      }
      return resumeReceiving;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "getReceiverStats",
    value: function () {
      var _getReceiverStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee17(localId) {
        return _regenerator().w(function (_context17) {
          while (1) switch (_context17.n) {
            case 0:
              this.assertNotClosed();
              return _context17.a(2, new Map());
          }
        }, _callee17, this);
      }));
      function getReceiverStats(_x17) {
        return _getReceiverStats.apply(this, arguments);
      }
      return getReceiverStats;
    }()
  }, {
    key: "receiveDataChannel",
    value: function () {
      var _receiveDataChannel = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee18(_ref5) {
        var sctpStreamParameters, label, protocol, dataChannel;
        return _regenerator().w(function (_context18) {
          while (1) switch (_context18.n) {
            case 0:
              sctpStreamParameters = _ref5.sctpStreamParameters, label = _ref5.label, protocol = _ref5.protocol;
              this.assertNotClosed();
              if (this._transportReady) {
                _context18.n = 1;
                break;
              }
              _context18.n = 1;
              return this.setupTransport({
                localDtlsRole: 'client'
              });
            case 1:
              logger.debug('receiveDataChannel()');
              dataChannel = new FakeDataChannel({
                id: sctpStreamParameters.streamId,
                ordered: sctpStreamParameters.ordered,
                maxPacketLifeTime: sctpStreamParameters.maxPacketLifeTime,
                maxRetransmits: sctpStreamParameters.maxRetransmits,
                label: label,
                protocol: protocol
              }); // @ts-expect-error --- On purpose.
              return _context18.a(2, {
                dataChannel: dataChannel
              });
          }
        }, _callee18, this);
      }));
      function receiveDataChannel(_x18) {
        return _receiveDataChannel.apply(this, arguments);
      }
      return receiveDataChannel;
    }()
  }, {
    key: "setupTransport",
    value: function () {
      var _setupTransport = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee19(_ref6) {
        var _this3 = this;
        var localDtlsRole, localSdpObject, dtlsParameters;
        return _regenerator().w(function (_context19) {
          while (1) switch (_context19.n) {
            case 0:
              localDtlsRole = _ref6.localDtlsRole, localSdpObject = _ref6.localSdpObject;
              dtlsParameters = utils.clone(this.fakeParameters.generateLocalDtlsParameters()); // Set our DTLS role.
              if (localDtlsRole) {
                dtlsParameters.role = localDtlsRole;
              }
              // Assume we are connecting now.
              this.emit('@connectionstatechange', 'connecting');
              // Need to tell the remote transport about our parameters.
              _context19.n = 1;
              return new Promise(function (resolve, reject) {
                return _this3.emit('@connect', {
                  dtlsParameters: dtlsParameters
                }, resolve, reject);
              });
            case 1:
              this._transportReady = true;
            case 2:
              return _context19.a(2);
          }
        }, _callee19, this);
      }));
      function setupTransport(_x19) {
        return _setupTransport.apply(this, arguments);
      }
      return setupTransport;
    }()
  }, {
    key: "assertNotClosed",
    value: function assertNotClosed() {
      if (this._closed) {
        throw new errors_1.InvalidStateError('method called in a closed handler');
      }
    }
  }], [{
    key: "createFactory",
    value:
    /**
     * Creates a factory function.
     */
    function createFactory(fakeParameters) {
      return function () {
        return new FakeHandler(fakeParameters);
      };
    }
  }]);
}(HandlerInterface_1.HandlerInterface);
exports.FakeHandler = FakeHandler;

},{"../Logger":39,"../enhancedEvents":44,"../errors":45,"../ortc":68,"../utils":72,"./HandlerInterface":55,"fake-mediastreamtrack":31}],53:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorValues(e) { if (null != e) { var t = e["function" == typeof Symbol && Symbol.iterator || "@@iterator"], r = 0; if (t) return t.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) return { next: function next() { return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e }; } }; } throw new TypeError(_typeof(e) + " is not iterable"); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o("next", 0), o("throw", 1), o("return", 2); } }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Firefox120 = void 0;
var sdpTransform = require("sdp-transform");
var Logger_1 = require("../Logger");
var errors_1 = require("../errors");
var utils = require("../utils");
var ortc = require("../ortc");
var sdpCommonUtils = require("./sdp/commonUtils");
var sdpUnifiedPlanUtils = require("./sdp/unifiedPlanUtils");
var HandlerInterface_1 = require("./HandlerInterface");
var RemoteSdp_1 = require("./sdp/RemoteSdp");
var scalabilityModes_1 = require("../scalabilityModes");
var logger = new Logger_1.Logger('Firefox120');
var NAME = 'Firefox120';
var SCTP_NUM_STREAMS = {
  OS: 16,
  MIS: 2048
};
var Firefox120 = /*#__PURE__*/function (_HandlerInterface_1$H) {
  function Firefox120() {
    var _this;
    _classCallCheck(this, Firefox120);
    _this = _callSuper(this, Firefox120);
    // Closed flag.
    _defineProperty(_this, "_closed", false);
    // Handler direction.
    _defineProperty(_this, "_direction", void 0);
    // Remote SDP handler.
    _defineProperty(_this, "_remoteSdp", void 0);
    // Generic sending RTP parameters for audio and video.
    _defineProperty(_this, "_sendingRtpParametersByKind", void 0);
    // Generic sending RTP parameters for audio and video suitable for the SDP
    // remote answer.
    _defineProperty(_this, "_sendingRemoteRtpParametersByKind", void 0);
    // RTCPeerConnection instance.
    _defineProperty(_this, "_pc", void 0);
    // Map of RTCTransceivers indexed by MID.
    _defineProperty(_this, "_mapMidTransceiver", new Map());
    // Local stream for sending.
    _defineProperty(_this, "_sendStream", new MediaStream());
    // Whether a DataChannel m=application section has been created.
    _defineProperty(_this, "_hasDataChannelMediaSection", false);
    // Sending DataChannel id value counter. Incremented for each new DataChannel.
    _defineProperty(_this, "_nextSendSctpStreamId", 0);
    // Got transport local and remote parameters.
    _defineProperty(_this, "_transportReady", false);
    return _this;
  }
  _inherits(Firefox120, _HandlerInterface_1$H);
  return _createClass(Firefox120, [{
    key: "name",
    get: function get() {
      return NAME;
    }
  }, {
    key: "close",
    value: function close() {
      logger.debug('close()');
      if (this._closed) {
        return;
      }
      this._closed = true;
      // Close RTCPeerConnection.
      if (this._pc) {
        try {
          this._pc.close();
        } catch (error) {}
      }
      this.emit('@close');
    }
  }, {
    key: "getNativeRtpCapabilities",
    value: function () {
      var _getNativeRtpCapabilities = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {
        var pc, canvas, fakeStream, fakeVideoTrack, offer, sdpObject, nativeRtpCapabilities, _t;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              logger.debug('getNativeRtpCapabilities()');
              pc = new RTCPeerConnection({
                iceServers: [],
                iceTransportPolicy: 'all',
                bundlePolicy: 'max-bundle',
                rtcpMuxPolicy: 'require'
              }); // NOTE: We need to add a real video track to get the RID extension mapping,
              // otherwiser Firefox doesn't include it in the SDP.
              canvas = document.createElement('canvas'); // NOTE: Otherwise Firefox fails in next line.
              canvas.getContext('2d');
              fakeStream = canvas.captureStream();
              fakeVideoTrack = fakeStream.getVideoTracks()[0];
              _context.p = 1;
              pc.addTransceiver('audio', {
                direction: 'sendrecv'
              });
              pc.addTransceiver(fakeVideoTrack, {
                direction: 'sendrecv',
                sendEncodings: [{
                  rid: 'r0',
                  maxBitrate: 100000
                }, {
                  rid: 'r1',
                  maxBitrate: 500000
                }]
              });
              _context.n = 2;
              return pc.createOffer();
            case 2:
              offer = _context.v;
              try {
                canvas.remove();
              } catch (error) {}
              try {
                fakeVideoTrack.stop();
              } catch (error) {}
              try {
                pc.close();
              } catch (error) {}
              sdpObject = sdpTransform.parse(offer.sdp);
              nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject: sdpObject
              });
              return _context.a(2, nativeRtpCapabilities);
            case 3:
              _context.p = 3;
              _t = _context.v;
              try {
                canvas.remove();
              } catch (error2) {}
              try {
                fakeVideoTrack.stop();
              } catch (error2) {}
              try {
                pc.close();
              } catch (error2) {}
              throw _t;
            case 4:
              return _context.a(2);
          }
        }, _callee, null, [[1, 3]]);
      }));
      function getNativeRtpCapabilities() {
        return _getNativeRtpCapabilities.apply(this, arguments);
      }
      return getNativeRtpCapabilities;
    }()
  }, {
    key: "getNativeSctpCapabilities",
    value: function () {
      var _getNativeSctpCapabilities = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2() {
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.n) {
            case 0:
              logger.debug('getNativeSctpCapabilities()');
              return _context2.a(2, {
                numStreams: SCTP_NUM_STREAMS
              });
          }
        }, _callee2);
      }));
      function getNativeSctpCapabilities() {
        return _getNativeSctpCapabilities.apply(this, arguments);
      }
      return getNativeSctpCapabilities;
    }()
  }, {
    key: "run",
    value: function run(_ref) {
      var _this2 = this;
      var direction = _ref.direction,
        iceParameters = _ref.iceParameters,
        iceCandidates = _ref.iceCandidates,
        dtlsParameters = _ref.dtlsParameters,
        sctpParameters = _ref.sctpParameters,
        iceServers = _ref.iceServers,
        iceTransportPolicy = _ref.iceTransportPolicy,
        additionalSettings = _ref.additionalSettings,
        proprietaryConstraints = _ref.proprietaryConstraints,
        extendedRtpCapabilities = _ref.extendedRtpCapabilities;
      this.assertNotClosed();
      logger.debug('run()');
      this._direction = direction;
      this._remoteSdp = new RemoteSdp_1.RemoteSdp({
        iceParameters: iceParameters,
        iceCandidates: iceCandidates,
        dtlsParameters: dtlsParameters,
        sctpParameters: sctpParameters
      });
      this._sendingRtpParametersByKind = {
        audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
        video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
      };
      this._sendingRemoteRtpParametersByKind = {
        audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
        video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)
      };
      this._pc = new RTCPeerConnection(_objectSpread({
        iceServers: iceServers !== null && iceServers !== void 0 ? iceServers : [],
        iceTransportPolicy: iceTransportPolicy !== null && iceTransportPolicy !== void 0 ? iceTransportPolicy : 'all',
        bundlePolicy: 'max-bundle',
        rtcpMuxPolicy: 'require'
      }, additionalSettings), proprietaryConstraints);
      this._pc.addEventListener('icegatheringstatechange', function () {
        _this2.emit('@icegatheringstatechange', _this2._pc.iceGatheringState);
      });
      this._pc.addEventListener('icecandidateerror', function (event) {
        _this2.emit('@icecandidateerror', event);
      });
      if (this._pc.connectionState) {
        this._pc.addEventListener('connectionstatechange', function () {
          _this2.emit('@connectionstatechange', _this2._pc.connectionState);
        });
      } else {
        this._pc.addEventListener('iceconnectionstatechange', function () {
          logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
          switch (_this2._pc.iceConnectionState) {
            case 'checking':
              {
                _this2.emit('@connectionstatechange', 'connecting');
                break;
              }
            case 'connected':
            case 'completed':
              {
                _this2.emit('@connectionstatechange', 'connected');
                break;
              }
            case 'failed':
              {
                _this2.emit('@connectionstatechange', 'failed');
                break;
              }
            case 'disconnected':
              {
                _this2.emit('@connectionstatechange', 'disconnected');
                break;
              }
            case 'closed':
              {
                _this2.emit('@connectionstatechange', 'closed');
                break;
              }
          }
        });
      }
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "updateIceServers",
    value: function () {
      var _updateIceServers = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(iceServers) {
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.n) {
            case 0:
              this.assertNotClosed();
              // NOTE: Firefox does not implement pc.setConfiguration().
              throw new errors_1.UnsupportedError('not supported');
            case 1:
              return _context3.a(2);
          }
        }, _callee3, this);
      }));
      function updateIceServers(_x) {
        return _updateIceServers.apply(this, arguments);
      }
      return updateIceServers;
    }()
  }, {
    key: "restartIce",
    value: function () {
      var _restartIce = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(iceParameters) {
        var offer, answer, _offer, _answer;
        return _regenerator().w(function (_context4) {
          while (1) switch (_context4.n) {
            case 0:
              this.assertNotClosed();
              logger.debug('restartIce()');
              // Provide the remote SDP handler with new remote ICE parameters.
              this._remoteSdp.updateIceParameters(iceParameters);
              if (this._transportReady) {
                _context4.n = 1;
                break;
              }
              return _context4.a(2);
            case 1:
              if (!(this._direction === 'send')) {
                _context4.n = 5;
                break;
              }
              _context4.n = 2;
              return this._pc.createOffer({
                iceRestart: true
              });
            case 2:
              offer = _context4.v;
              logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context4.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context4.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              _context4.n = 8;
              break;
            case 5:
              _offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', _offer);
              _context4.n = 6;
              return this._pc.setRemoteDescription(_offer);
            case 6:
              _context4.n = 7;
              return this._pc.createAnswer();
            case 7:
              _answer = _context4.v;
              logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', _answer);
              _context4.n = 8;
              return this._pc.setLocalDescription(_answer);
            case 8:
              return _context4.a(2);
          }
        }, _callee4, this);
      }));
      function restartIce(_x2) {
        return _restartIce.apply(this, arguments);
      }
      return restartIce;
    }()
  }, {
    key: "getTransportStats",
    value: function () {
      var _getTransportStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5() {
        return _regenerator().w(function (_context5) {
          while (1) switch (_context5.n) {
            case 0:
              this.assertNotClosed();
              return _context5.a(2, this._pc.getStats());
          }
        }, _callee5, this);
      }));
      function getTransportStats() {
        return _getTransportStats.apply(this, arguments);
      }
      return getTransportStats;
    }()
  }, {
    key: "send",
    value: function () {
      var _send = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6(_ref2) {
        var track, encodings, codecOptions, codec, onRtpSender, sendingRtpParameters, sendingRemoteRtpParameters, transceiver, offer, localSdpObject, layers, localId, offerMediaObject, newEncodings, _iterator, _step, encoding, answer;
        return _regenerator().w(function (_context6) {
          while (1) switch (_context6.n) {
            case 0:
              track = _ref2.track, encodings = _ref2.encodings, codecOptions = _ref2.codecOptions, codec = _ref2.codec, onRtpSender = _ref2.onRtpSender;
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
              if (encodings && encodings.length > 1) {
                encodings.forEach(function (encoding, idx) {
                  encoding.rid = "r".concat(idx);
                });
              }
              sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]); // This may throw.
              sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
              sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]); // This may throw.
              sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
              // NOTE: Firefox fails sometimes to properly anticipate the closed media
              // section that it should use, so don't reuse closed media sections.
              //   https://github.com/versatica/mediasoup-client/issues/104
              //
              // const mediaSectionIdx = this._remoteSdp!.getNextMediaSectionIdx();
              transceiver = this._pc.addTransceiver(track, {
                direction: 'sendonly',
                streams: [this._sendStream],
                sendEncodings: encodings
              });
              if (onRtpSender) {
                onRtpSender(transceiver.sender);
              }
              _context6.n = 1;
              return this._pc.createOffer();
            case 1:
              offer = _context6.v;
              localSdpObject = sdpTransform.parse(offer.sdp); // @ts-expect-error --- sdpTransform.SessionDescription type doesn't
              // define extmapAllowMixed field.
              if (localSdpObject.extmapAllowMixed) {
                this._remoteSdp.setSessionExtmapAllowMixed();
              }
              // In Firefox use DTLS role client even if we are the "offerer" since
              // Firefox does not respect ICE-Lite.
              if (this._transportReady) {
                _context6.n = 2;
                break;
              }
              _context6.n = 2;
              return this.setupTransport({
                localDtlsRole: 'client',
                localSdpObject: localSdpObject
              });
            case 2:
              layers = (0, scalabilityModes_1.parse)((encodings !== null && encodings !== void 0 ? encodings : [{}])[0].scalabilityMode);
              logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context6.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              // We can now get the transceiver.mid.
              localId = transceiver.mid; // Set MID.
              sendingRtpParameters.mid = localId;
              localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
              offerMediaObject = localSdpObject.media[localSdpObject.media.length - 1]; // Set RTCP CNAME.
              sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
                offerMediaObject: offerMediaObject
              });
              // Set RTP encodings by parsing the SDP offer if no encodings are given.
              if (!encodings) {
                sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
                  offerMediaObject: offerMediaObject
                });
              }
              // Set RTP encodings by parsing the SDP offer and complete them with given
              // one if just a single encoding has been given.
              else if (encodings.length === 1) {
                newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
                  offerMediaObject: offerMediaObject
                });
                Object.assign(newEncodings[0], encodings[0]);
                sendingRtpParameters.encodings = newEncodings;
              }
              // Otherwise if more than 1 encoding are given use them verbatim.
              else {
                sendingRtpParameters.encodings = encodings;
              }
              // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
              // each encoding.
              if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {
                _iterator = _createForOfIteratorHelper(sendingRtpParameters.encodings);
                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    encoding = _step.value;
                    if (encoding.scalabilityMode) {
                      encoding.scalabilityMode = "L1T".concat(layers.temporalLayers);
                    } else {
                      encoding.scalabilityMode = 'L1T3';
                    }
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
              }
              this._remoteSdp.send({
                offerMediaObject: offerMediaObject,
                offerRtpParameters: sendingRtpParameters,
                answerRtpParameters: sendingRemoteRtpParameters,
                codecOptions: codecOptions
              });
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context6.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              // Store in the map.
              this._mapMidTransceiver.set(localId, transceiver);
              return _context6.a(2, {
                localId: localId,
                rtpParameters: sendingRtpParameters,
                rtpSender: transceiver.sender
              });
          }
        }, _callee6, this);
      }));
      function send(_x3) {
        return _send.apply(this, arguments);
      }
      return send;
    }()
  }, {
    key: "stopSending",
    value: function () {
      var _stopSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7(localId) {
        var transceiver, offer, answer;
        return _regenerator().w(function (_context7) {
          while (1) switch (_context7.n) {
            case 0:
              this.assertSendDirection();
              logger.debug('stopSending() [localId:%s]', localId);
              if (!this._closed) {
                _context7.n = 1;
                break;
              }
              return _context7.a(2);
            case 1:
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context7.n = 2;
                break;
              }
              throw new Error('associated transceiver not found');
            case 2:
              void transceiver.sender.replaceTrack(null);
              // NOTE: Cannot use stop() the transceiver due to the the note above in
              // send() method.
              // try
              // {
              // 	transceiver.stop();
              // }
              // catch (error)
              // {}
              this._pc.removeTrack(transceiver.sender);
              // NOTE: Cannot use closeMediaSection() due to the the note above in send()
              // method.
              // this._remoteSdp!.closeMediaSection(transceiver.mid);
              this._remoteSdp.disableMediaSection(transceiver.mid);
              _context7.n = 3;
              return this._pc.createOffer();
            case 3:
              offer = _context7.v;
              logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context7.n = 4;
              return this._pc.setLocalDescription(offer);
            case 4:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context7.n = 5;
              return this._pc.setRemoteDescription(answer);
            case 5:
              this._mapMidTransceiver["delete"](localId);
            case 6:
              return _context7.a(2);
          }
        }, _callee7, this);
      }));
      function stopSending(_x4) {
        return _stopSending.apply(this, arguments);
      }
      return stopSending;
    }()
  }, {
    key: "pauseSending",
    value: function () {
      var _pauseSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8(localId) {
        var transceiver, offer, answer;
        return _regenerator().w(function (_context8) {
          while (1) switch (_context8.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('pauseSending() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context8.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              transceiver.direction = 'inactive';
              this._remoteSdp.pauseMediaSection(localId);
              _context8.n = 2;
              return this._pc.createOffer();
            case 2:
              offer = _context8.v;
              logger.debug('pauseSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context8.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('pauseSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context8.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              return _context8.a(2);
          }
        }, _callee8, this);
      }));
      function pauseSending(_x5) {
        return _pauseSending.apply(this, arguments);
      }
      return pauseSending;
    }()
  }, {
    key: "resumeSending",
    value: function () {
      var _resumeSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee9(localId) {
        var transceiver, offer, answer;
        return _regenerator().w(function (_context9) {
          while (1) switch (_context9.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('resumeSending() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context9.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              transceiver.direction = 'sendonly';
              this._remoteSdp.resumeSendingMediaSection(localId);
              _context9.n = 2;
              return this._pc.createOffer();
            case 2:
              offer = _context9.v;
              logger.debug('resumeSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context9.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('resumeSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context9.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              return _context9.a(2);
          }
        }, _callee9, this);
      }));
      function resumeSending(_x6) {
        return _resumeSending.apply(this, arguments);
      }
      return resumeSending;
    }()
  }, {
    key: "replaceTrack",
    value: function () {
      var _replaceTrack = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee0(localId, track) {
        var transceiver;
        return _regenerator().w(function (_context0) {
          while (1) switch (_context0.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              if (track) {
                logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
              } else {
                logger.debug('replaceTrack() [localId:%s, no track]', localId);
              }
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context0.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              _context0.n = 2;
              return transceiver.sender.replaceTrack(track);
            case 2:
              return _context0.a(2);
          }
        }, _callee0, this);
      }));
      function replaceTrack(_x7, _x8) {
        return _replaceTrack.apply(this, arguments);
      }
      return replaceTrack;
    }()
  }, {
    key: "setMaxSpatialLayer",
    value: function () {
      var _setMaxSpatialLayer = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee1(localId, spatialLayer) {
        var transceiver, parameters, offer, answer;
        return _regenerator().w(function (_context1) {
          while (1) switch (_context1.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context1.n = 1;
                break;
              }
              throw new Error('associated transceiver not found');
            case 1:
              parameters = transceiver.sender.getParameters();
              parameters.encodings.forEach(function (encoding, idx) {
                if (idx <= spatialLayer) {
                  encoding.active = true;
                } else {
                  encoding.active = false;
                }
              });
              _context1.n = 2;
              return transceiver.sender.setParameters(parameters);
            case 2:
              this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
              _context1.n = 3;
              return this._pc.createOffer();
            case 3:
              offer = _context1.v;
              logger.debug('setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context1.n = 4;
              return this._pc.setLocalDescription(offer);
            case 4:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context1.n = 5;
              return this._pc.setRemoteDescription(answer);
            case 5:
              return _context1.a(2);
          }
        }, _callee1, this);
      }));
      function setMaxSpatialLayer(_x9, _x0) {
        return _setMaxSpatialLayer.apply(this, arguments);
      }
      return setMaxSpatialLayer;
    }()
  }, {
    key: "setRtpEncodingParameters",
    value: function () {
      var _setRtpEncodingParameters = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee10(localId, params) {
        var transceiver, parameters, offer, answer;
        return _regenerator().w(function (_context10) {
          while (1) switch (_context10.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context10.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              parameters = transceiver.sender.getParameters();
              parameters.encodings.forEach(function (encoding, idx) {
                parameters.encodings[idx] = _objectSpread(_objectSpread({}, encoding), params);
              });
              _context10.n = 2;
              return transceiver.sender.setParameters(parameters);
            case 2:
              this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
              _context10.n = 3;
              return this._pc.createOffer();
            case 3:
              offer = _context10.v;
              logger.debug('setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context10.n = 4;
              return this._pc.setLocalDescription(offer);
            case 4:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context10.n = 5;
              return this._pc.setRemoteDescription(answer);
            case 5:
              return _context10.a(2);
          }
        }, _callee10, this);
      }));
      function setRtpEncodingParameters(_x1, _x10) {
        return _setRtpEncodingParameters.apply(this, arguments);
      }
      return setRtpEncodingParameters;
    }()
  }, {
    key: "getSenderStats",
    value: function () {
      var _getSenderStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee11(localId) {
        var transceiver;
        return _regenerator().w(function (_context11) {
          while (1) switch (_context11.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context11.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              return _context11.a(2, transceiver.sender.getStats());
          }
        }, _callee11, this);
      }));
      function getSenderStats(_x11) {
        return _getSenderStats.apply(this, arguments);
      }
      return getSenderStats;
    }()
  }, {
    key: "sendDataChannel",
    value: function () {
      var _sendDataChannel = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee12(_ref3) {
        var ordered, maxPacketLifeTime, maxRetransmits, label, protocol, options, dataChannel, offer, localSdpObject, offerMediaObject, answer, sctpStreamParameters;
        return _regenerator().w(function (_context12) {
          while (1) switch (_context12.n) {
            case 0:
              ordered = _ref3.ordered, maxPacketLifeTime = _ref3.maxPacketLifeTime, maxRetransmits = _ref3.maxRetransmits, label = _ref3.label, protocol = _ref3.protocol;
              this.assertNotClosed();
              this.assertSendDirection();
              options = {
                negotiated: true,
                id: this._nextSendSctpStreamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmits: maxRetransmits,
                protocol: protocol
              };
              logger.debug('sendDataChannel() [options:%o]', options);
              dataChannel = this._pc.createDataChannel(label, options); // Increase next id.
              this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
              // If this is the first DataChannel we need to create the SDP answer with
              // m=application section.
              if (this._hasDataChannelMediaSection) {
                _context12.n = 5;
                break;
              }
              _context12.n = 1;
              return this._pc.createOffer();
            case 1:
              offer = _context12.v;
              localSdpObject = sdpTransform.parse(offer.sdp);
              offerMediaObject = localSdpObject.media.find(function (m) {
                return m.type === 'application';
              });
              if (this._transportReady) {
                _context12.n = 2;
                break;
              }
              _context12.n = 2;
              return this.setupTransport({
                localDtlsRole: 'client',
                localSdpObject: localSdpObject
              });
            case 2:
              logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context12.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              this._remoteSdp.sendSctpAssociation({
                offerMediaObject: offerMediaObject
              });
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context12.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              this._hasDataChannelMediaSection = true;
            case 5:
              sctpStreamParameters = {
                streamId: options.id,
                ordered: options.ordered,
                maxPacketLifeTime: options.maxPacketLifeTime,
                maxRetransmits: options.maxRetransmits
              };
              return _context12.a(2, {
                dataChannel: dataChannel,
                sctpStreamParameters: sctpStreamParameters
              });
          }
        }, _callee12, this);
      }));
      function sendDataChannel(_x12) {
        return _sendDataChannel.apply(this, arguments);
      }
      return sendDataChannel;
    }()
  }, {
    key: "receive",
    value: function () {
      var _receive = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee13(optionsList) {
        var _this3 = this;
        var results, mapLocalId, _iterator2, _step2, _rtpParameters$mid, options, trackId, kind, rtpParameters, streamId, localId, offer, _iterator3, _step3, _loop, answer, localSdpObject, _iterator4, _step4, _loop2, _iterator5, _step5, _loop3, _t2, _t3, _t4;
        return _regenerator().w(function (_context16) {
          while (1) switch (_context16.n) {
            case 0:
              this.assertNotClosed();
              this.assertRecvDirection();
              results = [];
              mapLocalId = new Map();
              _iterator2 = _createForOfIteratorHelper(optionsList);
              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  options = _step2.value;
                  trackId = options.trackId, kind = options.kind, rtpParameters = options.rtpParameters, streamId = options.streamId;
                  logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
                  localId = (_rtpParameters$mid = rtpParameters.mid) !== null && _rtpParameters$mid !== void 0 ? _rtpParameters$mid : String(this._mapMidTransceiver.size);
                  mapLocalId.set(trackId, localId);
                  this._remoteSdp.receive({
                    mid: localId,
                    kind: kind,
                    offerRtpParameters: rtpParameters,
                    streamId: streamId !== null && streamId !== void 0 ? streamId : rtpParameters.rtcp.cname,
                    trackId: trackId
                  });
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context16.n = 1;
              return this._pc.setRemoteDescription(offer);
            case 1:
              _iterator3 = _createForOfIteratorHelper(optionsList);
              _context16.p = 2;
              _loop = /*#__PURE__*/_regenerator().m(function _loop() {
                var options, trackId, onRtpReceiver, _localId, transceiver;
                return _regenerator().w(function (_context13) {
                  while (1) switch (_context13.n) {
                    case 0:
                      options = _step3.value;
                      trackId = options.trackId, onRtpReceiver = options.onRtpReceiver;
                      if (!onRtpReceiver) {
                        _context13.n = 2;
                        break;
                      }
                      _localId = mapLocalId.get(trackId);
                      transceiver = _this3._pc.getTransceivers().find(function (t) {
                        return t.mid === _localId;
                      });
                      if (transceiver) {
                        _context13.n = 1;
                        break;
                      }
                      throw new Error('transceiver not found');
                    case 1:
                      onRtpReceiver(transceiver.receiver);
                    case 2:
                      return _context13.a(2);
                  }
                }, _loop);
              });
              _iterator3.s();
            case 3:
              if ((_step3 = _iterator3.n()).done) {
                _context16.n = 5;
                break;
              }
              return _context16.d(_regeneratorValues(_loop()), 4);
            case 4:
              _context16.n = 3;
              break;
            case 5:
              _context16.n = 7;
              break;
            case 6:
              _context16.p = 6;
              _t2 = _context16.v;
              _iterator3.e(_t2);
            case 7:
              _context16.p = 7;
              _iterator3.f();
              return _context16.f(7);
            case 8:
              _context16.n = 9;
              return this._pc.createAnswer();
            case 9:
              answer = _context16.v;
              localSdpObject = sdpTransform.parse(answer.sdp);
              _iterator4 = _createForOfIteratorHelper(optionsList);
              _context16.p = 10;
              _loop2 = /*#__PURE__*/_regenerator().m(function _loop2() {
                var options, trackId, rtpParameters, localId, answerMediaObject;
                return _regenerator().w(function (_context14) {
                  while (1) switch (_context14.n) {
                    case 0:
                      options = _step4.value;
                      trackId = options.trackId, rtpParameters = options.rtpParameters;
                      localId = mapLocalId.get(trackId);
                      answerMediaObject = localSdpObject.media.find(function (m) {
                        return String(m.mid) === localId;
                      }); // May need to modify codec parameters in the answer based on codec
                      // parameters in the offer.
                      sdpCommonUtils.applyCodecParameters({
                        offerRtpParameters: rtpParameters,
                        answerMediaObject: answerMediaObject
                      });
                      answer = {
                        type: 'answer',
                        sdp: sdpTransform.write(localSdpObject)
                      };
                    case 1:
                      return _context14.a(2);
                  }
                }, _loop2);
              });
              _iterator4.s();
            case 11:
              if ((_step4 = _iterator4.n()).done) {
                _context16.n = 13;
                break;
              }
              return _context16.d(_regeneratorValues(_loop2()), 12);
            case 12:
              _context16.n = 11;
              break;
            case 13:
              _context16.n = 15;
              break;
            case 14:
              _context16.p = 14;
              _t3 = _context16.v;
              _iterator4.e(_t3);
            case 15:
              _context16.p = 15;
              _iterator4.f();
              return _context16.f(15);
            case 16:
              if (this._transportReady) {
                _context16.n = 17;
                break;
              }
              _context16.n = 17;
              return this.setupTransport({
                localDtlsRole: 'client',
                localSdpObject: localSdpObject
              });
            case 17:
              logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context16.n = 18;
              return this._pc.setLocalDescription(answer);
            case 18:
              _iterator5 = _createForOfIteratorHelper(optionsList);
              _context16.p = 19;
              _loop3 = /*#__PURE__*/_regenerator().m(function _loop3() {
                var options, trackId, localId, transceiver;
                return _regenerator().w(function (_context15) {
                  while (1) switch (_context15.n) {
                    case 0:
                      options = _step5.value;
                      trackId = options.trackId;
                      localId = mapLocalId.get(trackId);
                      transceiver = _this3._pc.getTransceivers().find(function (t) {
                        return t.mid === localId;
                      });
                      if (transceiver) {
                        _context15.n = 1;
                        break;
                      }
                      throw new Error('new RTCRtpTransceiver not found');
                    case 1:
                      // Store in the map.
                      _this3._mapMidTransceiver.set(localId, transceiver);
                      results.push({
                        localId: localId,
                        track: transceiver.receiver.track,
                        rtpReceiver: transceiver.receiver
                      });
                    case 2:
                      return _context15.a(2);
                  }
                }, _loop3);
              });
              _iterator5.s();
            case 20:
              if ((_step5 = _iterator5.n()).done) {
                _context16.n = 22;
                break;
              }
              return _context16.d(_regeneratorValues(_loop3()), 21);
            case 21:
              _context16.n = 20;
              break;
            case 22:
              _context16.n = 24;
              break;
            case 23:
              _context16.p = 23;
              _t4 = _context16.v;
              _iterator5.e(_t4);
            case 24:
              _context16.p = 24;
              _iterator5.f();
              return _context16.f(24);
            case 25:
              return _context16.a(2, results);
          }
        }, _callee13, this, [[19, 23, 24, 25], [10, 14, 15, 16], [2, 6, 7, 8]]);
      }));
      function receive(_x13) {
        return _receive.apply(this, arguments);
      }
      return receive;
    }()
  }, {
    key: "stopReceiving",
    value: function () {
      var _stopReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee14(localIds) {
        var _iterator6, _step6, localId, transceiver, offer, answer, _iterator7, _step7, _localId2, _t5;
        return _regenerator().w(function (_context17) {
          while (1) switch (_context17.n) {
            case 0:
              this.assertRecvDirection();
              if (!this._closed) {
                _context17.n = 1;
                break;
              }
              return _context17.a(2);
            case 1:
              _iterator6 = _createForOfIteratorHelper(localIds);
              _context17.p = 2;
              _iterator6.s();
            case 3:
              if ((_step6 = _iterator6.n()).done) {
                _context17.n = 6;
                break;
              }
              localId = _step6.value;
              logger.debug('stopReceiving() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context17.n = 4;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 4:
              this._remoteSdp.closeMediaSection(transceiver.mid);
            case 5:
              _context17.n = 3;
              break;
            case 6:
              _context17.n = 8;
              break;
            case 7:
              _context17.p = 7;
              _t5 = _context17.v;
              _iterator6.e(_t5);
            case 8:
              _context17.p = 8;
              _iterator6.f();
              return _context17.f(8);
            case 9:
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context17.n = 10;
              return this._pc.setRemoteDescription(offer);
            case 10:
              _context17.n = 11;
              return this._pc.createAnswer();
            case 11:
              answer = _context17.v;
              logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context17.n = 12;
              return this._pc.setLocalDescription(answer);
            case 12:
              _iterator7 = _createForOfIteratorHelper(localIds);
              try {
                for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                  _localId2 = _step7.value;
                  this._mapMidTransceiver["delete"](_localId2);
                }
              } catch (err) {
                _iterator7.e(err);
              } finally {
                _iterator7.f();
              }
            case 13:
              return _context17.a(2);
          }
        }, _callee14, this, [[2, 7, 8, 9]]);
      }));
      function stopReceiving(_x14) {
        return _stopReceiving.apply(this, arguments);
      }
      return stopReceiving;
    }()
  }, {
    key: "pauseReceiving",
    value: function () {
      var _pauseReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee15(localIds) {
        var _iterator8, _step8, localId, transceiver, offer, answer, _t6;
        return _regenerator().w(function (_context18) {
          while (1) switch (_context18.n) {
            case 0:
              this.assertNotClosed();
              this.assertRecvDirection();
              _iterator8 = _createForOfIteratorHelper(localIds);
              _context18.p = 1;
              _iterator8.s();
            case 2:
              if ((_step8 = _iterator8.n()).done) {
                _context18.n = 5;
                break;
              }
              localId = _step8.value;
              logger.debug('pauseReceiving() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context18.n = 3;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 3:
              transceiver.direction = 'inactive';
              this._remoteSdp.pauseMediaSection(localId);
            case 4:
              _context18.n = 2;
              break;
            case 5:
              _context18.n = 7;
              break;
            case 6:
              _context18.p = 6;
              _t6 = _context18.v;
              _iterator8.e(_t6);
            case 7:
              _context18.p = 7;
              _iterator8.f();
              return _context18.f(7);
            case 8:
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context18.n = 9;
              return this._pc.setRemoteDescription(offer);
            case 9:
              _context18.n = 10;
              return this._pc.createAnswer();
            case 10:
              answer = _context18.v;
              logger.debug('pauseReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context18.n = 11;
              return this._pc.setLocalDescription(answer);
            case 11:
              return _context18.a(2);
          }
        }, _callee15, this, [[1, 6, 7, 8]]);
      }));
      function pauseReceiving(_x15) {
        return _pauseReceiving.apply(this, arguments);
      }
      return pauseReceiving;
    }()
  }, {
    key: "resumeReceiving",
    value: function () {
      var _resumeReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee16(localIds) {
        var _iterator9, _step9, localId, transceiver, offer, answer, _t7;
        return _regenerator().w(function (_context19) {
          while (1) switch (_context19.n) {
            case 0:
              this.assertNotClosed();
              this.assertRecvDirection();
              _iterator9 = _createForOfIteratorHelper(localIds);
              _context19.p = 1;
              _iterator9.s();
            case 2:
              if ((_step9 = _iterator9.n()).done) {
                _context19.n = 5;
                break;
              }
              localId = _step9.value;
              logger.debug('resumeReceiving() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context19.n = 3;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 3:
              transceiver.direction = 'recvonly';
              this._remoteSdp.resumeReceivingMediaSection(localId);
            case 4:
              _context19.n = 2;
              break;
            case 5:
              _context19.n = 7;
              break;
            case 6:
              _context19.p = 6;
              _t7 = _context19.v;
              _iterator9.e(_t7);
            case 7:
              _context19.p = 7;
              _iterator9.f();
              return _context19.f(7);
            case 8:
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context19.n = 9;
              return this._pc.setRemoteDescription(offer);
            case 9:
              _context19.n = 10;
              return this._pc.createAnswer();
            case 10:
              answer = _context19.v;
              logger.debug('resumeReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context19.n = 11;
              return this._pc.setLocalDescription(answer);
            case 11:
              return _context19.a(2);
          }
        }, _callee16, this, [[1, 6, 7, 8]]);
      }));
      function resumeReceiving(_x16) {
        return _resumeReceiving.apply(this, arguments);
      }
      return resumeReceiving;
    }()
  }, {
    key: "getReceiverStats",
    value: function () {
      var _getReceiverStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee17(localId) {
        var transceiver;
        return _regenerator().w(function (_context20) {
          while (1) switch (_context20.n) {
            case 0:
              this.assertRecvDirection();
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context20.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              return _context20.a(2, transceiver.receiver.getStats());
          }
        }, _callee17, this);
      }));
      function getReceiverStats(_x17) {
        return _getReceiverStats.apply(this, arguments);
      }
      return getReceiverStats;
    }()
  }, {
    key: "receiveDataChannel",
    value: function () {
      var _receiveDataChannel = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee18(_ref4) {
        var sctpStreamParameters, label, protocol, streamId, ordered, maxPacketLifeTime, maxRetransmits, options, dataChannel, offer, answer, localSdpObject;
        return _regenerator().w(function (_context21) {
          while (1) switch (_context21.n) {
            case 0:
              sctpStreamParameters = _ref4.sctpStreamParameters, label = _ref4.label, protocol = _ref4.protocol;
              this.assertNotClosed();
              this.assertRecvDirection();
              streamId = sctpStreamParameters.streamId, ordered = sctpStreamParameters.ordered, maxPacketLifeTime = sctpStreamParameters.maxPacketLifeTime, maxRetransmits = sctpStreamParameters.maxRetransmits;
              options = {
                negotiated: true,
                id: streamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmits: maxRetransmits,
                protocol: protocol
              };
              logger.debug('receiveDataChannel() [options:%o]', options);
              dataChannel = this._pc.createDataChannel(label, options); // If this is the first DataChannel we need to create the SDP offer with
              // m=application section.
              if (this._hasDataChannelMediaSection) {
                _context21.n = 5;
                break;
              }
              this._remoteSdp.receiveSctpAssociation();
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context21.n = 1;
              return this._pc.setRemoteDescription(offer);
            case 1:
              _context21.n = 2;
              return this._pc.createAnswer();
            case 2:
              answer = _context21.v;
              if (this._transportReady) {
                _context21.n = 3;
                break;
              }
              localSdpObject = sdpTransform.parse(answer.sdp);
              _context21.n = 3;
              return this.setupTransport({
                localDtlsRole: 'client',
                localSdpObject: localSdpObject
              });
            case 3:
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context21.n = 4;
              return this._pc.setLocalDescription(answer);
            case 4:
              this._hasDataChannelMediaSection = true;
            case 5:
              return _context21.a(2, {
                dataChannel: dataChannel
              });
          }
        }, _callee18, this);
      }));
      function receiveDataChannel(_x18) {
        return _receiveDataChannel.apply(this, arguments);
      }
      return receiveDataChannel;
    }()
  }, {
    key: "setupTransport",
    value: function () {
      var _setupTransport = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee19(_ref5) {
        var _this4 = this;
        var localDtlsRole, localSdpObject, dtlsParameters;
        return _regenerator().w(function (_context22) {
          while (1) switch (_context22.n) {
            case 0:
              localDtlsRole = _ref5.localDtlsRole, localSdpObject = _ref5.localSdpObject;
              if (!localSdpObject) {
                localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
              }
              // Get our local DTLS parameters.
              dtlsParameters = sdpCommonUtils.extractDtlsParameters({
                sdpObject: localSdpObject
              }); // Set our DTLS role.
              dtlsParameters.role = localDtlsRole;
              // Update the remote DTLS role in the SDP.
              this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
              // Need to tell the remote transport about our parameters.
              _context22.n = 1;
              return new Promise(function (resolve, reject) {
                _this4.safeEmit('@connect', {
                  dtlsParameters: dtlsParameters
                }, resolve, reject);
              });
            case 1:
              this._transportReady = true;
            case 2:
              return _context22.a(2);
          }
        }, _callee19, this);
      }));
      function setupTransport(_x19) {
        return _setupTransport.apply(this, arguments);
      }
      return setupTransport;
    }()
  }, {
    key: "assertNotClosed",
    value: function assertNotClosed() {
      if (this._closed) {
        throw new errors_1.InvalidStateError('method called in a closed handler');
      }
    }
  }, {
    key: "assertSendDirection",
    value: function assertSendDirection() {
      if (this._direction !== 'send') {
        throw new Error('method can just be called for handlers with "send" direction');
      }
    }
  }, {
    key: "assertRecvDirection",
    value: function assertRecvDirection() {
      if (this._direction !== 'recv') {
        throw new Error('method can just be called for handlers with "recv" direction');
      }
    }
  }], [{
    key: "createFactory",
    value:
    /**
     * Creates a factory function.
     */
    function createFactory() {
      return function () {
        return new Firefox120();
      };
    }
  }]);
}(HandlerInterface_1.HandlerInterface);
exports.Firefox120 = Firefox120;

},{"../Logger":39,"../errors":45,"../ortc":68,"../scalabilityModes":69,"../utils":72,"./HandlerInterface":55,"./sdp/RemoteSdp":63,"./sdp/commonUtils":64,"./sdp/unifiedPlanUtils":66,"sdp-transform":76}],54:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorValues(e) { if (null != e) { var t = e["function" == typeof Symbol && Symbol.iterator || "@@iterator"], r = 0; if (t) return t.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) return { next: function next() { return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e }; } }; } throw new TypeError(_typeof(e) + " is not iterable"); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o("next", 0), o("throw", 1), o("return", 2); } }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Firefox60 = void 0;
var sdpTransform = require("sdp-transform");
var Logger_1 = require("../Logger");
var errors_1 = require("../errors");
var utils = require("../utils");
var ortc = require("../ortc");
var sdpCommonUtils = require("./sdp/commonUtils");
var sdpUnifiedPlanUtils = require("./sdp/unifiedPlanUtils");
var HandlerInterface_1 = require("./HandlerInterface");
var RemoteSdp_1 = require("./sdp/RemoteSdp");
var scalabilityModes_1 = require("../scalabilityModes");
var logger = new Logger_1.Logger('Firefox60');
var NAME = 'Firefox60';
var SCTP_NUM_STREAMS = {
  OS: 16,
  MIS: 2048
};
var Firefox60 = /*#__PURE__*/function (_HandlerInterface_1$H) {
  function Firefox60() {
    var _this;
    _classCallCheck(this, Firefox60);
    _this = _callSuper(this, Firefox60);
    // Closed flag.
    _defineProperty(_this, "_closed", false);
    // Handler direction.
    _defineProperty(_this, "_direction", void 0);
    // Remote SDP handler.
    _defineProperty(_this, "_remoteSdp", void 0);
    // Generic sending RTP parameters for audio and video.
    _defineProperty(_this, "_sendingRtpParametersByKind", void 0);
    // Generic sending RTP parameters for audio and video suitable for the SDP
    // remote answer.
    _defineProperty(_this, "_sendingRemoteRtpParametersByKind", void 0);
    // RTCPeerConnection instance.
    _defineProperty(_this, "_pc", void 0);
    // Map of RTCTransceivers indexed by MID.
    _defineProperty(_this, "_mapMidTransceiver", new Map());
    // Local stream for sending.
    _defineProperty(_this, "_sendStream", new MediaStream());
    // Whether a DataChannel m=application section has been created.
    _defineProperty(_this, "_hasDataChannelMediaSection", false);
    // Sending DataChannel id value counter. Incremented for each new DataChannel.
    _defineProperty(_this, "_nextSendSctpStreamId", 0);
    // Got transport local and remote parameters.
    _defineProperty(_this, "_transportReady", false);
    return _this;
  }
  _inherits(Firefox60, _HandlerInterface_1$H);
  return _createClass(Firefox60, [{
    key: "name",
    get: function get() {
      return NAME;
    }
  }, {
    key: "close",
    value: function close() {
      logger.debug('close()');
      if (this._closed) {
        return;
      }
      this._closed = true;
      // Close RTCPeerConnection.
      if (this._pc) {
        try {
          this._pc.close();
        } catch (error) {}
      }
      this.emit('@close');
    }
  }, {
    key: "getNativeRtpCapabilities",
    value: function () {
      var _getNativeRtpCapabilities = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {
        var pc, canvas, fakeStream, fakeVideoTrack, videoTransceiver, parameters, encodings, offer, sdpObject, nativeRtpCapabilities, _t;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              logger.debug('getNativeRtpCapabilities()');
              pc = new RTCPeerConnection({
                iceServers: [],
                iceTransportPolicy: 'all',
                bundlePolicy: 'max-bundle',
                rtcpMuxPolicy: 'require'
              }); // NOTE: We need to add a real video track to get the RID extension mapping.
              canvas = document.createElement('canvas'); // NOTE: Otherwise Firefox fails in next line.
              canvas.getContext('2d');
              fakeStream = canvas.captureStream();
              fakeVideoTrack = fakeStream.getVideoTracks()[0];
              _context.p = 1;
              pc.addTransceiver('audio', {
                direction: 'sendrecv'
              });
              videoTransceiver = pc.addTransceiver(fakeVideoTrack, {
                direction: 'sendrecv'
              });
              parameters = videoTransceiver.sender.getParameters();
              encodings = [{
                rid: 'r0',
                maxBitrate: 100000
              }, {
                rid: 'r1',
                maxBitrate: 500000
              }];
              parameters.encodings = encodings;
              _context.n = 2;
              return videoTransceiver.sender.setParameters(parameters);
            case 2:
              _context.n = 3;
              return pc.createOffer();
            case 3:
              offer = _context.v;
              try {
                canvas.remove();
              } catch (error) {}
              try {
                fakeVideoTrack.stop();
              } catch (error) {}
              try {
                pc.close();
              } catch (error) {}
              sdpObject = sdpTransform.parse(offer.sdp);
              nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject: sdpObject
              });
              return _context.a(2, nativeRtpCapabilities);
            case 4:
              _context.p = 4;
              _t = _context.v;
              try {
                canvas.remove();
              } catch (error2) {}
              try {
                fakeVideoTrack.stop();
              } catch (error2) {}
              try {
                pc.close();
              } catch (error2) {}
              throw _t;
            case 5:
              return _context.a(2);
          }
        }, _callee, null, [[1, 4]]);
      }));
      function getNativeRtpCapabilities() {
        return _getNativeRtpCapabilities.apply(this, arguments);
      }
      return getNativeRtpCapabilities;
    }()
  }, {
    key: "getNativeSctpCapabilities",
    value: function () {
      var _getNativeSctpCapabilities = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2() {
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.n) {
            case 0:
              logger.debug('getNativeSctpCapabilities()');
              return _context2.a(2, {
                numStreams: SCTP_NUM_STREAMS
              });
          }
        }, _callee2);
      }));
      function getNativeSctpCapabilities() {
        return _getNativeSctpCapabilities.apply(this, arguments);
      }
      return getNativeSctpCapabilities;
    }()
  }, {
    key: "run",
    value: function run(_ref) {
      var _this2 = this;
      var direction = _ref.direction,
        iceParameters = _ref.iceParameters,
        iceCandidates = _ref.iceCandidates,
        dtlsParameters = _ref.dtlsParameters,
        sctpParameters = _ref.sctpParameters,
        iceServers = _ref.iceServers,
        iceTransportPolicy = _ref.iceTransportPolicy,
        additionalSettings = _ref.additionalSettings,
        proprietaryConstraints = _ref.proprietaryConstraints,
        extendedRtpCapabilities = _ref.extendedRtpCapabilities;
      this.assertNotClosed();
      logger.debug('run()');
      this._direction = direction;
      this._remoteSdp = new RemoteSdp_1.RemoteSdp({
        iceParameters: iceParameters,
        iceCandidates: iceCandidates,
        dtlsParameters: dtlsParameters,
        sctpParameters: sctpParameters
      });
      this._sendingRtpParametersByKind = {
        audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
        video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
      };
      this._sendingRemoteRtpParametersByKind = {
        audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
        video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)
      };
      this._pc = new RTCPeerConnection(_objectSpread({
        iceServers: iceServers !== null && iceServers !== void 0 ? iceServers : [],
        iceTransportPolicy: iceTransportPolicy !== null && iceTransportPolicy !== void 0 ? iceTransportPolicy : 'all',
        bundlePolicy: 'max-bundle',
        rtcpMuxPolicy: 'require'
      }, additionalSettings), proprietaryConstraints);
      this._pc.addEventListener('icegatheringstatechange', function () {
        _this2.emit('@icegatheringstatechange', _this2._pc.iceGatheringState);
      });
      this._pc.addEventListener('icecandidateerror', function (event) {
        _this2.emit('@icecandidateerror', event);
      });
      if (this._pc.connectionState) {
        this._pc.addEventListener('connectionstatechange', function () {
          _this2.emit('@connectionstatechange', _this2._pc.connectionState);
        });
      } else {
        this._pc.addEventListener('iceconnectionstatechange', function () {
          logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
          switch (_this2._pc.iceConnectionState) {
            case 'checking':
              {
                _this2.emit('@connectionstatechange', 'connecting');
                break;
              }
            case 'connected':
            case 'completed':
              {
                _this2.emit('@connectionstatechange', 'connected');
                break;
              }
            case 'failed':
              {
                _this2.emit('@connectionstatechange', 'failed');
                break;
              }
            case 'disconnected':
              {
                _this2.emit('@connectionstatechange', 'disconnected');
                break;
              }
            case 'closed':
              {
                _this2.emit('@connectionstatechange', 'closed');
                break;
              }
          }
        });
      }
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "updateIceServers",
    value: function () {
      var _updateIceServers = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(iceServers) {
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.n) {
            case 0:
              this.assertNotClosed();
              // NOTE: Firefox does not implement pc.setConfiguration().
              throw new errors_1.UnsupportedError('not supported');
            case 1:
              return _context3.a(2);
          }
        }, _callee3, this);
      }));
      function updateIceServers(_x) {
        return _updateIceServers.apply(this, arguments);
      }
      return updateIceServers;
    }()
  }, {
    key: "restartIce",
    value: function () {
      var _restartIce = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(iceParameters) {
        var offer, answer, _offer, _answer;
        return _regenerator().w(function (_context4) {
          while (1) switch (_context4.n) {
            case 0:
              this.assertNotClosed();
              logger.debug('restartIce()');
              // Provide the remote SDP handler with new remote ICE parameters.
              this._remoteSdp.updateIceParameters(iceParameters);
              if (this._transportReady) {
                _context4.n = 1;
                break;
              }
              return _context4.a(2);
            case 1:
              if (!(this._direction === 'send')) {
                _context4.n = 5;
                break;
              }
              _context4.n = 2;
              return this._pc.createOffer({
                iceRestart: true
              });
            case 2:
              offer = _context4.v;
              logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context4.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context4.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              _context4.n = 8;
              break;
            case 5:
              _offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', _offer);
              _context4.n = 6;
              return this._pc.setRemoteDescription(_offer);
            case 6:
              _context4.n = 7;
              return this._pc.createAnswer();
            case 7:
              _answer = _context4.v;
              logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', _answer);
              _context4.n = 8;
              return this._pc.setLocalDescription(_answer);
            case 8:
              return _context4.a(2);
          }
        }, _callee4, this);
      }));
      function restartIce(_x2) {
        return _restartIce.apply(this, arguments);
      }
      return restartIce;
    }()
  }, {
    key: "getTransportStats",
    value: function () {
      var _getTransportStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5() {
        return _regenerator().w(function (_context5) {
          while (1) switch (_context5.n) {
            case 0:
              this.assertNotClosed();
              return _context5.a(2, this._pc.getStats());
          }
        }, _callee5, this);
      }));
      function getTransportStats() {
        return _getTransportStats.apply(this, arguments);
      }
      return getTransportStats;
    }()
  }, {
    key: "send",
    value: function () {
      var _send = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6(_ref2) {
        var track, encodings, codecOptions, codec, sendingRtpParameters, sendingRemoteRtpParameters, transceiver, parameters, offer, localSdpObject, layers, localId, offerMediaObject, newEncodings, _iterator, _step, encoding, answer;
        return _regenerator().w(function (_context6) {
          while (1) switch (_context6.n) {
            case 0:
              track = _ref2.track, encodings = _ref2.encodings, codecOptions = _ref2.codecOptions, codec = _ref2.codec;
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
              if (encodings) {
                encodings = utils.clone(encodings);
                encodings.forEach(function (encoding, idx) {
                  encoding.rid = "r".concat(idx);
                });
                // Clone the encodings and reverse them because Firefox likes them
                // from high to low.
                encodings.reverse();
              }
              sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]); // This may throw.
              sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
              sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]); // This may throw.
              sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
              // NOTE: Firefox fails sometimes to properly anticipate the closed media
              // section that it should use, so don't reuse closed media sections.
              //   https://github.com/versatica/mediasoup-client/issues/104
              //
              // const mediaSectionIdx = this._remoteSdp!.getNextMediaSectionIdx();
              transceiver = this._pc.addTransceiver(track, {
                direction: 'sendonly',
                streams: [this._sendStream]
              }); // NOTE: This is not spec compliants. Encodings should be given in addTransceiver
              // second argument, but Firefox does not support it.
              if (!encodings) {
                _context6.n = 1;
                break;
              }
              parameters = transceiver.sender.getParameters();
              parameters.encodings = encodings;
              _context6.n = 1;
              return transceiver.sender.setParameters(parameters);
            case 1:
              _context6.n = 2;
              return this._pc.createOffer();
            case 2:
              offer = _context6.v;
              localSdpObject = sdpTransform.parse(offer.sdp); // @ts-expect-error --- sdpTransform.SessionDescription type doesn't
              // define extmapAllowMixed field.
              if (localSdpObject.extmapAllowMixed) {
                this._remoteSdp.setSessionExtmapAllowMixed();
              }
              // In Firefox use DTLS role client even if we are the "offerer" since
              // Firefox does not respect ICE-Lite.
              if (this._transportReady) {
                _context6.n = 3;
                break;
              }
              _context6.n = 3;
              return this.setupTransport({
                localDtlsRole: 'client',
                localSdpObject: localSdpObject
              });
            case 3:
              layers = (0, scalabilityModes_1.parse)((encodings !== null && encodings !== void 0 ? encodings : [{}])[0].scalabilityMode);
              logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context6.n = 4;
              return this._pc.setLocalDescription(offer);
            case 4:
              // We can now get the transceiver.mid.
              localId = transceiver.mid; // Set MID.
              sendingRtpParameters.mid = localId;
              localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
              offerMediaObject = localSdpObject.media[localSdpObject.media.length - 1]; // Set RTCP CNAME.
              sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
                offerMediaObject: offerMediaObject
              });
              // Set RTP encodings by parsing the SDP offer if no encodings are given.
              if (!encodings) {
                sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
                  offerMediaObject: offerMediaObject
                });
              }
              // Set RTP encodings by parsing the SDP offer and complete them with given
              // one if just a single encoding has been given.
              else if (encodings.length === 1) {
                newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
                  offerMediaObject: offerMediaObject
                });
                Object.assign(newEncodings[0], encodings[0]);
                sendingRtpParameters.encodings = newEncodings;
              }
              // Otherwise if more than 1 encoding are given use them verbatim (but
              // reverse them back since we reversed them above to satisfy Firefox).
              else {
                sendingRtpParameters.encodings = encodings.reverse();
              }
              // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
              // each encoding.
              if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {
                _iterator = _createForOfIteratorHelper(sendingRtpParameters.encodings);
                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    encoding = _step.value;
                    if (encoding.scalabilityMode) {
                      encoding.scalabilityMode = "L1T".concat(layers.temporalLayers);
                    } else {
                      encoding.scalabilityMode = 'L1T3';
                    }
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
              }
              this._remoteSdp.send({
                offerMediaObject: offerMediaObject,
                offerRtpParameters: sendingRtpParameters,
                answerRtpParameters: sendingRemoteRtpParameters,
                codecOptions: codecOptions
              });
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context6.n = 5;
              return this._pc.setRemoteDescription(answer);
            case 5:
              // Store in the map.
              this._mapMidTransceiver.set(localId, transceiver);
              return _context6.a(2, {
                localId: localId,
                rtpParameters: sendingRtpParameters,
                rtpSender: transceiver.sender
              });
          }
        }, _callee6, this);
      }));
      function send(_x3) {
        return _send.apply(this, arguments);
      }
      return send;
    }()
  }, {
    key: "stopSending",
    value: function () {
      var _stopSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7(localId) {
        var transceiver, offer, answer;
        return _regenerator().w(function (_context7) {
          while (1) switch (_context7.n) {
            case 0:
              this.assertSendDirection();
              logger.debug('stopSending() [localId:%s]', localId);
              if (!this._closed) {
                _context7.n = 1;
                break;
              }
              return _context7.a(2);
            case 1:
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context7.n = 2;
                break;
              }
              throw new Error('associated transceiver not found');
            case 2:
              void transceiver.sender.replaceTrack(null);
              // NOTE: Cannot use stop() the transceiver due to the the note above in
              // send() method.
              // try
              // {
              // 	transceiver.stop();
              // }
              // catch (error)
              // {}
              this._pc.removeTrack(transceiver.sender);
              // NOTE: Cannot use closeMediaSection() due to the the note above in send()
              // method.
              // this._remoteSdp!.closeMediaSection(transceiver.mid);
              this._remoteSdp.disableMediaSection(transceiver.mid);
              _context7.n = 3;
              return this._pc.createOffer();
            case 3:
              offer = _context7.v;
              logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context7.n = 4;
              return this._pc.setLocalDescription(offer);
            case 4:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context7.n = 5;
              return this._pc.setRemoteDescription(answer);
            case 5:
              this._mapMidTransceiver["delete"](localId);
            case 6:
              return _context7.a(2);
          }
        }, _callee7, this);
      }));
      function stopSending(_x4) {
        return _stopSending.apply(this, arguments);
      }
      return stopSending;
    }()
  }, {
    key: "pauseSending",
    value: function () {
      var _pauseSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8(localId) {
        var transceiver, offer, answer;
        return _regenerator().w(function (_context8) {
          while (1) switch (_context8.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('pauseSending() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context8.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              transceiver.direction = 'inactive';
              this._remoteSdp.pauseMediaSection(localId);
              _context8.n = 2;
              return this._pc.createOffer();
            case 2:
              offer = _context8.v;
              logger.debug('pauseSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context8.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('pauseSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context8.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              return _context8.a(2);
          }
        }, _callee8, this);
      }));
      function pauseSending(_x5) {
        return _pauseSending.apply(this, arguments);
      }
      return pauseSending;
    }()
  }, {
    key: "resumeSending",
    value: function () {
      var _resumeSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee9(localId) {
        var transceiver, offer, answer;
        return _regenerator().w(function (_context9) {
          while (1) switch (_context9.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('resumeSending() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context9.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              transceiver.direction = 'sendonly';
              this._remoteSdp.resumeSendingMediaSection(localId);
              _context9.n = 2;
              return this._pc.createOffer();
            case 2:
              offer = _context9.v;
              logger.debug('resumeSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context9.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('resumeSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context9.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              return _context9.a(2);
          }
        }, _callee9, this);
      }));
      function resumeSending(_x6) {
        return _resumeSending.apply(this, arguments);
      }
      return resumeSending;
    }()
  }, {
    key: "replaceTrack",
    value: function () {
      var _replaceTrack = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee0(localId, track) {
        var transceiver;
        return _regenerator().w(function (_context0) {
          while (1) switch (_context0.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              if (track) {
                logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
              } else {
                logger.debug('replaceTrack() [localId:%s, no track]', localId);
              }
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context0.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              _context0.n = 2;
              return transceiver.sender.replaceTrack(track);
            case 2:
              return _context0.a(2);
          }
        }, _callee0, this);
      }));
      function replaceTrack(_x7, _x8) {
        return _replaceTrack.apply(this, arguments);
      }
      return replaceTrack;
    }()
  }, {
    key: "setMaxSpatialLayer",
    value: function () {
      var _setMaxSpatialLayer = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee1(localId, spatialLayer) {
        var transceiver, parameters, offer, answer;
        return _regenerator().w(function (_context1) {
          while (1) switch (_context1.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context1.n = 1;
                break;
              }
              throw new Error('associated transceiver not found');
            case 1:
              parameters = transceiver.sender.getParameters(); // NOTE: We require encodings given from low to high, however Firefox
              // requires them in reverse order, so do magic here.
              spatialLayer = parameters.encodings.length - 1 - spatialLayer;
              parameters.encodings.forEach(function (encoding, idx) {
                if (idx >= spatialLayer) {
                  encoding.active = true;
                } else {
                  encoding.active = false;
                }
              });
              _context1.n = 2;
              return transceiver.sender.setParameters(parameters);
            case 2:
              this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
              _context1.n = 3;
              return this._pc.createOffer();
            case 3:
              offer = _context1.v;
              logger.debug('setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context1.n = 4;
              return this._pc.setLocalDescription(offer);
            case 4:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context1.n = 5;
              return this._pc.setRemoteDescription(answer);
            case 5:
              return _context1.a(2);
          }
        }, _callee1, this);
      }));
      function setMaxSpatialLayer(_x9, _x0) {
        return _setMaxSpatialLayer.apply(this, arguments);
      }
      return setMaxSpatialLayer;
    }()
  }, {
    key: "setRtpEncodingParameters",
    value: function () {
      var _setRtpEncodingParameters = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee10(localId, params) {
        var transceiver, parameters, offer, answer;
        return _regenerator().w(function (_context10) {
          while (1) switch (_context10.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context10.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              parameters = transceiver.sender.getParameters();
              parameters.encodings.forEach(function (encoding, idx) {
                parameters.encodings[idx] = _objectSpread(_objectSpread({}, encoding), params);
              });
              _context10.n = 2;
              return transceiver.sender.setParameters(parameters);
            case 2:
              this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
              _context10.n = 3;
              return this._pc.createOffer();
            case 3:
              offer = _context10.v;
              logger.debug('setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context10.n = 4;
              return this._pc.setLocalDescription(offer);
            case 4:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context10.n = 5;
              return this._pc.setRemoteDescription(answer);
            case 5:
              return _context10.a(2);
          }
        }, _callee10, this);
      }));
      function setRtpEncodingParameters(_x1, _x10) {
        return _setRtpEncodingParameters.apply(this, arguments);
      }
      return setRtpEncodingParameters;
    }()
  }, {
    key: "getSenderStats",
    value: function () {
      var _getSenderStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee11(localId) {
        var transceiver;
        return _regenerator().w(function (_context11) {
          while (1) switch (_context11.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context11.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              return _context11.a(2, transceiver.sender.getStats());
          }
        }, _callee11, this);
      }));
      function getSenderStats(_x11) {
        return _getSenderStats.apply(this, arguments);
      }
      return getSenderStats;
    }()
  }, {
    key: "sendDataChannel",
    value: function () {
      var _sendDataChannel = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee12(_ref3) {
        var ordered, maxPacketLifeTime, maxRetransmits, label, protocol, options, dataChannel, offer, localSdpObject, offerMediaObject, answer, sctpStreamParameters;
        return _regenerator().w(function (_context12) {
          while (1) switch (_context12.n) {
            case 0:
              ordered = _ref3.ordered, maxPacketLifeTime = _ref3.maxPacketLifeTime, maxRetransmits = _ref3.maxRetransmits, label = _ref3.label, protocol = _ref3.protocol;
              this.assertNotClosed();
              this.assertSendDirection();
              options = {
                negotiated: true,
                id: this._nextSendSctpStreamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmits: maxRetransmits,
                protocol: protocol
              };
              logger.debug('sendDataChannel() [options:%o]', options);
              dataChannel = this._pc.createDataChannel(label, options); // Increase next id.
              this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
              // If this is the first DataChannel we need to create the SDP answer with
              // m=application section.
              if (this._hasDataChannelMediaSection) {
                _context12.n = 5;
                break;
              }
              _context12.n = 1;
              return this._pc.createOffer();
            case 1:
              offer = _context12.v;
              localSdpObject = sdpTransform.parse(offer.sdp);
              offerMediaObject = localSdpObject.media.find(function (m) {
                return m.type === 'application';
              });
              if (this._transportReady) {
                _context12.n = 2;
                break;
              }
              _context12.n = 2;
              return this.setupTransport({
                localDtlsRole: 'client',
                localSdpObject: localSdpObject
              });
            case 2:
              logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context12.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              this._remoteSdp.sendSctpAssociation({
                offerMediaObject: offerMediaObject
              });
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context12.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              this._hasDataChannelMediaSection = true;
            case 5:
              sctpStreamParameters = {
                streamId: options.id,
                ordered: options.ordered,
                maxPacketLifeTime: options.maxPacketLifeTime,
                maxRetransmits: options.maxRetransmits
              };
              return _context12.a(2, {
                dataChannel: dataChannel,
                sctpStreamParameters: sctpStreamParameters
              });
          }
        }, _callee12, this);
      }));
      function sendDataChannel(_x12) {
        return _sendDataChannel.apply(this, arguments);
      }
      return sendDataChannel;
    }()
  }, {
    key: "receive",
    value: function () {
      var _receive = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee13(optionsList) {
        var _this3 = this;
        var results, mapLocalId, _iterator2, _step2, _rtpParameters$mid, options, trackId, kind, rtpParameters, streamId, localId, offer, answer, localSdpObject, _iterator3, _step3, _loop, _iterator4, _step4, _loop2, _t2, _t3;
        return _regenerator().w(function (_context15) {
          while (1) switch (_context15.n) {
            case 0:
              this.assertNotClosed();
              this.assertRecvDirection();
              results = [];
              mapLocalId = new Map();
              _iterator2 = _createForOfIteratorHelper(optionsList);
              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  options = _step2.value;
                  trackId = options.trackId, kind = options.kind, rtpParameters = options.rtpParameters, streamId = options.streamId;
                  logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
                  localId = (_rtpParameters$mid = rtpParameters.mid) !== null && _rtpParameters$mid !== void 0 ? _rtpParameters$mid : String(this._mapMidTransceiver.size);
                  mapLocalId.set(trackId, localId);
                  this._remoteSdp.receive({
                    mid: localId,
                    kind: kind,
                    offerRtpParameters: rtpParameters,
                    streamId: streamId !== null && streamId !== void 0 ? streamId : rtpParameters.rtcp.cname,
                    trackId: trackId
                  });
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context15.n = 1;
              return this._pc.setRemoteDescription(offer);
            case 1:
              _context15.n = 2;
              return this._pc.createAnswer();
            case 2:
              answer = _context15.v;
              localSdpObject = sdpTransform.parse(answer.sdp);
              _iterator3 = _createForOfIteratorHelper(optionsList);
              _context15.p = 3;
              _loop = /*#__PURE__*/_regenerator().m(function _loop() {
                var options, trackId, rtpParameters, localId, answerMediaObject;
                return _regenerator().w(function (_context13) {
                  while (1) switch (_context13.n) {
                    case 0:
                      options = _step3.value;
                      trackId = options.trackId, rtpParameters = options.rtpParameters;
                      localId = mapLocalId.get(trackId);
                      answerMediaObject = localSdpObject.media.find(function (m) {
                        return String(m.mid) === localId;
                      }); // May need to modify codec parameters in the answer based on codec
                      // parameters in the offer.
                      sdpCommonUtils.applyCodecParameters({
                        offerRtpParameters: rtpParameters,
                        answerMediaObject: answerMediaObject
                      });
                      answer = {
                        type: 'answer',
                        sdp: sdpTransform.write(localSdpObject)
                      };
                    case 1:
                      return _context13.a(2);
                  }
                }, _loop);
              });
              _iterator3.s();
            case 4:
              if ((_step3 = _iterator3.n()).done) {
                _context15.n = 6;
                break;
              }
              return _context15.d(_regeneratorValues(_loop()), 5);
            case 5:
              _context15.n = 4;
              break;
            case 6:
              _context15.n = 8;
              break;
            case 7:
              _context15.p = 7;
              _t2 = _context15.v;
              _iterator3.e(_t2);
            case 8:
              _context15.p = 8;
              _iterator3.f();
              return _context15.f(8);
            case 9:
              if (this._transportReady) {
                _context15.n = 10;
                break;
              }
              _context15.n = 10;
              return this.setupTransport({
                localDtlsRole: 'client',
                localSdpObject: localSdpObject
              });
            case 10:
              logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context15.n = 11;
              return this._pc.setLocalDescription(answer);
            case 11:
              _iterator4 = _createForOfIteratorHelper(optionsList);
              _context15.p = 12;
              _loop2 = /*#__PURE__*/_regenerator().m(function _loop2() {
                var options, trackId, localId, transceiver;
                return _regenerator().w(function (_context14) {
                  while (1) switch (_context14.n) {
                    case 0:
                      options = _step4.value;
                      trackId = options.trackId;
                      localId = mapLocalId.get(trackId);
                      transceiver = _this3._pc.getTransceivers().find(function (t) {
                        return t.mid === localId;
                      });
                      if (transceiver) {
                        _context14.n = 1;
                        break;
                      }
                      throw new Error('new RTCRtpTransceiver not found');
                    case 1:
                      // Store in the map.
                      _this3._mapMidTransceiver.set(localId, transceiver);
                      results.push({
                        localId: localId,
                        track: transceiver.receiver.track,
                        rtpReceiver: transceiver.receiver
                      });
                    case 2:
                      return _context14.a(2);
                  }
                }, _loop2);
              });
              _iterator4.s();
            case 13:
              if ((_step4 = _iterator4.n()).done) {
                _context15.n = 15;
                break;
              }
              return _context15.d(_regeneratorValues(_loop2()), 14);
            case 14:
              _context15.n = 13;
              break;
            case 15:
              _context15.n = 17;
              break;
            case 16:
              _context15.p = 16;
              _t3 = _context15.v;
              _iterator4.e(_t3);
            case 17:
              _context15.p = 17;
              _iterator4.f();
              return _context15.f(17);
            case 18:
              return _context15.a(2, results);
          }
        }, _callee13, this, [[12, 16, 17, 18], [3, 7, 8, 9]]);
      }));
      function receive(_x13) {
        return _receive.apply(this, arguments);
      }
      return receive;
    }()
  }, {
    key: "stopReceiving",
    value: function () {
      var _stopReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee14(localIds) {
        var _iterator5, _step5, localId, transceiver, offer, answer, _iterator6, _step6, _localId, _t4;
        return _regenerator().w(function (_context16) {
          while (1) switch (_context16.n) {
            case 0:
              this.assertRecvDirection();
              if (!this._closed) {
                _context16.n = 1;
                break;
              }
              return _context16.a(2);
            case 1:
              _iterator5 = _createForOfIteratorHelper(localIds);
              _context16.p = 2;
              _iterator5.s();
            case 3:
              if ((_step5 = _iterator5.n()).done) {
                _context16.n = 6;
                break;
              }
              localId = _step5.value;
              logger.debug('stopReceiving() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context16.n = 4;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 4:
              this._remoteSdp.closeMediaSection(transceiver.mid);
            case 5:
              _context16.n = 3;
              break;
            case 6:
              _context16.n = 8;
              break;
            case 7:
              _context16.p = 7;
              _t4 = _context16.v;
              _iterator5.e(_t4);
            case 8:
              _context16.p = 8;
              _iterator5.f();
              return _context16.f(8);
            case 9:
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context16.n = 10;
              return this._pc.setRemoteDescription(offer);
            case 10:
              _context16.n = 11;
              return this._pc.createAnswer();
            case 11:
              answer = _context16.v;
              logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context16.n = 12;
              return this._pc.setLocalDescription(answer);
            case 12:
              _iterator6 = _createForOfIteratorHelper(localIds);
              try {
                for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                  _localId = _step6.value;
                  this._mapMidTransceiver["delete"](_localId);
                }
              } catch (err) {
                _iterator6.e(err);
              } finally {
                _iterator6.f();
              }
            case 13:
              return _context16.a(2);
          }
        }, _callee14, this, [[2, 7, 8, 9]]);
      }));
      function stopReceiving(_x14) {
        return _stopReceiving.apply(this, arguments);
      }
      return stopReceiving;
    }()
  }, {
    key: "pauseReceiving",
    value: function () {
      var _pauseReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee15(localIds) {
        var _iterator7, _step7, localId, transceiver, offer, answer, _t5;
        return _regenerator().w(function (_context17) {
          while (1) switch (_context17.n) {
            case 0:
              this.assertNotClosed();
              this.assertRecvDirection();
              _iterator7 = _createForOfIteratorHelper(localIds);
              _context17.p = 1;
              _iterator7.s();
            case 2:
              if ((_step7 = _iterator7.n()).done) {
                _context17.n = 5;
                break;
              }
              localId = _step7.value;
              logger.debug('pauseReceiving() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context17.n = 3;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 3:
              transceiver.direction = 'inactive';
              this._remoteSdp.pauseMediaSection(localId);
            case 4:
              _context17.n = 2;
              break;
            case 5:
              _context17.n = 7;
              break;
            case 6:
              _context17.p = 6;
              _t5 = _context17.v;
              _iterator7.e(_t5);
            case 7:
              _context17.p = 7;
              _iterator7.f();
              return _context17.f(7);
            case 8:
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context17.n = 9;
              return this._pc.setRemoteDescription(offer);
            case 9:
              _context17.n = 10;
              return this._pc.createAnswer();
            case 10:
              answer = _context17.v;
              logger.debug('pauseReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context17.n = 11;
              return this._pc.setLocalDescription(answer);
            case 11:
              return _context17.a(2);
          }
        }, _callee15, this, [[1, 6, 7, 8]]);
      }));
      function pauseReceiving(_x15) {
        return _pauseReceiving.apply(this, arguments);
      }
      return pauseReceiving;
    }()
  }, {
    key: "resumeReceiving",
    value: function () {
      var _resumeReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee16(localIds) {
        var _iterator8, _step8, localId, transceiver, offer, answer, _t6;
        return _regenerator().w(function (_context18) {
          while (1) switch (_context18.n) {
            case 0:
              this.assertNotClosed();
              this.assertRecvDirection();
              _iterator8 = _createForOfIteratorHelper(localIds);
              _context18.p = 1;
              _iterator8.s();
            case 2:
              if ((_step8 = _iterator8.n()).done) {
                _context18.n = 5;
                break;
              }
              localId = _step8.value;
              logger.debug('resumeReceiving() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context18.n = 3;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 3:
              transceiver.direction = 'recvonly';
              this._remoteSdp.resumeReceivingMediaSection(localId);
            case 4:
              _context18.n = 2;
              break;
            case 5:
              _context18.n = 7;
              break;
            case 6:
              _context18.p = 6;
              _t6 = _context18.v;
              _iterator8.e(_t6);
            case 7:
              _context18.p = 7;
              _iterator8.f();
              return _context18.f(7);
            case 8:
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context18.n = 9;
              return this._pc.setRemoteDescription(offer);
            case 9:
              _context18.n = 10;
              return this._pc.createAnswer();
            case 10:
              answer = _context18.v;
              logger.debug('resumeReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context18.n = 11;
              return this._pc.setLocalDescription(answer);
            case 11:
              return _context18.a(2);
          }
        }, _callee16, this, [[1, 6, 7, 8]]);
      }));
      function resumeReceiving(_x16) {
        return _resumeReceiving.apply(this, arguments);
      }
      return resumeReceiving;
    }()
  }, {
    key: "getReceiverStats",
    value: function () {
      var _getReceiverStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee17(localId) {
        var transceiver;
        return _regenerator().w(function (_context19) {
          while (1) switch (_context19.n) {
            case 0:
              this.assertRecvDirection();
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context19.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              return _context19.a(2, transceiver.receiver.getStats());
          }
        }, _callee17, this);
      }));
      function getReceiverStats(_x17) {
        return _getReceiverStats.apply(this, arguments);
      }
      return getReceiverStats;
    }()
  }, {
    key: "receiveDataChannel",
    value: function () {
      var _receiveDataChannel = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee18(_ref4) {
        var sctpStreamParameters, label, protocol, streamId, ordered, maxPacketLifeTime, maxRetransmits, options, dataChannel, offer, answer, localSdpObject;
        return _regenerator().w(function (_context20) {
          while (1) switch (_context20.n) {
            case 0:
              sctpStreamParameters = _ref4.sctpStreamParameters, label = _ref4.label, protocol = _ref4.protocol;
              this.assertNotClosed();
              this.assertRecvDirection();
              streamId = sctpStreamParameters.streamId, ordered = sctpStreamParameters.ordered, maxPacketLifeTime = sctpStreamParameters.maxPacketLifeTime, maxRetransmits = sctpStreamParameters.maxRetransmits;
              options = {
                negotiated: true,
                id: streamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmits: maxRetransmits,
                protocol: protocol
              };
              logger.debug('receiveDataChannel() [options:%o]', options);
              dataChannel = this._pc.createDataChannel(label, options); // If this is the first DataChannel we need to create the SDP offer with
              // m=application section.
              if (this._hasDataChannelMediaSection) {
                _context20.n = 5;
                break;
              }
              this._remoteSdp.receiveSctpAssociation();
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context20.n = 1;
              return this._pc.setRemoteDescription(offer);
            case 1:
              _context20.n = 2;
              return this._pc.createAnswer();
            case 2:
              answer = _context20.v;
              if (this._transportReady) {
                _context20.n = 3;
                break;
              }
              localSdpObject = sdpTransform.parse(answer.sdp);
              _context20.n = 3;
              return this.setupTransport({
                localDtlsRole: 'client',
                localSdpObject: localSdpObject
              });
            case 3:
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context20.n = 4;
              return this._pc.setLocalDescription(answer);
            case 4:
              this._hasDataChannelMediaSection = true;
            case 5:
              return _context20.a(2, {
                dataChannel: dataChannel
              });
          }
        }, _callee18, this);
      }));
      function receiveDataChannel(_x18) {
        return _receiveDataChannel.apply(this, arguments);
      }
      return receiveDataChannel;
    }()
  }, {
    key: "setupTransport",
    value: function () {
      var _setupTransport = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee19(_ref5) {
        var _this4 = this;
        var localDtlsRole, localSdpObject, dtlsParameters;
        return _regenerator().w(function (_context21) {
          while (1) switch (_context21.n) {
            case 0:
              localDtlsRole = _ref5.localDtlsRole, localSdpObject = _ref5.localSdpObject;
              if (!localSdpObject) {
                localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
              }
              // Get our local DTLS parameters.
              dtlsParameters = sdpCommonUtils.extractDtlsParameters({
                sdpObject: localSdpObject
              }); // Set our DTLS role.
              dtlsParameters.role = localDtlsRole;
              // Update the remote DTLS role in the SDP.
              this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
              // Need to tell the remote transport about our parameters.
              _context21.n = 1;
              return new Promise(function (resolve, reject) {
                _this4.safeEmit('@connect', {
                  dtlsParameters: dtlsParameters
                }, resolve, reject);
              });
            case 1:
              this._transportReady = true;
            case 2:
              return _context21.a(2);
          }
        }, _callee19, this);
      }));
      function setupTransport(_x19) {
        return _setupTransport.apply(this, arguments);
      }
      return setupTransport;
    }()
  }, {
    key: "assertNotClosed",
    value: function assertNotClosed() {
      if (this._closed) {
        throw new errors_1.InvalidStateError('method called in a closed handler');
      }
    }
  }, {
    key: "assertSendDirection",
    value: function assertSendDirection() {
      if (this._direction !== 'send') {
        throw new Error('method can just be called for handlers with "send" direction');
      }
    }
  }, {
    key: "assertRecvDirection",
    value: function assertRecvDirection() {
      if (this._direction !== 'recv') {
        throw new Error('method can just be called for handlers with "recv" direction');
      }
    }
  }], [{
    key: "createFactory",
    value:
    /**
     * Creates a factory function.
     */
    function createFactory() {
      return function () {
        return new Firefox60();
      };
    }
  }]);
}(HandlerInterface_1.HandlerInterface);
exports.Firefox60 = Firefox60;

},{"../Logger":39,"../errors":45,"../ortc":68,"../scalabilityModes":69,"../utils":72,"./HandlerInterface":55,"./sdp/RemoteSdp":63,"./sdp/commonUtils":64,"./sdp/unifiedPlanUtils":66,"sdp-transform":76}],55:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HandlerInterface = void 0;
var enhancedEvents_1 = require("../enhancedEvents");
var HandlerInterface = /*#__PURE__*/function (_enhancedEvents_1$Enh) {
  function HandlerInterface() {
    _classCallCheck(this, HandlerInterface);
    return _callSuper(this, HandlerInterface);
  }
  _inherits(HandlerInterface, _enhancedEvents_1$Enh);
  return _createClass(HandlerInterface);
}(enhancedEvents_1.EnhancedEventEmitter);
exports.HandlerInterface = HandlerInterface;

},{"../enhancedEvents":44}],56:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorValues(e) { if (null != e) { var t = e["function" == typeof Symbol && Symbol.iterator || "@@iterator"], r = 0; if (t) return t.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) return { next: function next() { return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e }; } }; } throw new TypeError(_typeof(e) + " is not iterable"); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o("next", 0), o("throw", 1), o("return", 2); } }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ReactNative = void 0;
var sdpTransform = require("sdp-transform");
var Logger_1 = require("../Logger");
var errors_1 = require("../errors");
var utils = require("../utils");
var ortc = require("../ortc");
var sdpCommonUtils = require("./sdp/commonUtils");
var sdpPlanBUtils = require("./sdp/planBUtils");
var HandlerInterface_1 = require("./HandlerInterface");
var RemoteSdp_1 = require("./sdp/RemoteSdp");
var logger = new Logger_1.Logger('ReactNative');
var NAME = 'ReactNative';
var SCTP_NUM_STREAMS = {
  OS: 1024,
  MIS: 1024
};
var ReactNative = /*#__PURE__*/function (_HandlerInterface_1$H) {
  function ReactNative() {
    var _this;
    _classCallCheck(this, ReactNative);
    _this = _callSuper(this, ReactNative);
    // Handler direction.
    _defineProperty(_this, "_direction", void 0);
    // Remote SDP handler.
    _defineProperty(_this, "_remoteSdp", void 0);
    // Generic sending RTP parameters for audio and video.
    _defineProperty(_this, "_sendingRtpParametersByKind", void 0);
    // Generic sending RTP parameters for audio and video suitable for the SDP
    // remote answer.
    _defineProperty(_this, "_sendingRemoteRtpParametersByKind", void 0);
    // Initial server side DTLS role. If not 'auto', it will force the opposite
    // value in client side.
    _defineProperty(_this, "_forcedLocalDtlsRole", void 0);
    // RTCPeerConnection instance.
    _defineProperty(_this, "_pc", void 0);
    // Local stream for sending.
    _defineProperty(_this, "_sendStream", new MediaStream());
    // Map of sending MediaStreamTracks indexed by localId.
    _defineProperty(_this, "_mapSendLocalIdTrack", new Map());
    // Next sending localId.
    _defineProperty(_this, "_nextSendLocalId", 0);
    // Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.
    // Value is an Object with mid, rtpParameters and rtpReceiver.
    _defineProperty(_this, "_mapRecvLocalIdInfo", new Map());
    // Whether a DataChannel m=application section has been created.
    _defineProperty(_this, "_hasDataChannelMediaSection", false);
    // Sending DataChannel id value counter. Incremented for each new DataChannel.
    _defineProperty(_this, "_nextSendSctpStreamId", 0);
    // Got transport local and remote parameters.
    _defineProperty(_this, "_transportReady", false);
    return _this;
  }
  _inherits(ReactNative, _HandlerInterface_1$H);
  return _createClass(ReactNative, [{
    key: "name",
    get: function get() {
      return NAME;
    }
  }, {
    key: "close",
    value: function close() {
      logger.debug('close()');
      // Free/dispose native MediaStream but DO NOT free/dispose native
      // MediaStreamTracks (that is parent's business).
      // @ts-expect-error --- Proprietary API in react-native-webrtc.
      this._sendStream.release(/* releaseTracks */false);
      // Close RTCPeerConnection.
      if (this._pc) {
        try {
          this._pc.close();
        } catch (error) {}
      }
      this.emit('@close');
    }
  }, {
    key: "getNativeRtpCapabilities",
    value: function () {
      var _getNativeRtpCapabilities = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {
        var pc, offer, sdpObject, nativeRtpCapabilities, _t;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              logger.debug('getNativeRtpCapabilities()');
              pc = new RTCPeerConnection({
                iceServers: [],
                iceTransportPolicy: 'all',
                bundlePolicy: 'max-bundle',
                rtcpMuxPolicy: 'require',
                sdpSemantics: 'plan-b'
              });
              _context.p = 1;
              _context.n = 2;
              return pc.createOffer({
                offerToReceiveAudio: true,
                offerToReceiveVideo: true
              });
            case 2:
              offer = _context.v;
              try {
                pc.close();
              } catch (error) {}
              sdpObject = sdpTransform.parse(offer.sdp);
              nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject: sdpObject
              });
              return _context.a(2, nativeRtpCapabilities);
            case 3:
              _context.p = 3;
              _t = _context.v;
              try {
                pc.close();
              } catch (error2) {}
              throw _t;
            case 4:
              return _context.a(2);
          }
        }, _callee, null, [[1, 3]]);
      }));
      function getNativeRtpCapabilities() {
        return _getNativeRtpCapabilities.apply(this, arguments);
      }
      return getNativeRtpCapabilities;
    }()
  }, {
    key: "getNativeSctpCapabilities",
    value: function () {
      var _getNativeSctpCapabilities = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2() {
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.n) {
            case 0:
              logger.debug('getNativeSctpCapabilities()');
              return _context2.a(2, {
                numStreams: SCTP_NUM_STREAMS
              });
          }
        }, _callee2);
      }));
      function getNativeSctpCapabilities() {
        return _getNativeSctpCapabilities.apply(this, arguments);
      }
      return getNativeSctpCapabilities;
    }()
  }, {
    key: "run",
    value: function run(_ref) {
      var _this2 = this;
      var direction = _ref.direction,
        iceParameters = _ref.iceParameters,
        iceCandidates = _ref.iceCandidates,
        dtlsParameters = _ref.dtlsParameters,
        sctpParameters = _ref.sctpParameters,
        iceServers = _ref.iceServers,
        iceTransportPolicy = _ref.iceTransportPolicy,
        additionalSettings = _ref.additionalSettings,
        proprietaryConstraints = _ref.proprietaryConstraints,
        extendedRtpCapabilities = _ref.extendedRtpCapabilities;
      logger.debug('run()');
      this._direction = direction;
      this._remoteSdp = new RemoteSdp_1.RemoteSdp({
        iceParameters: iceParameters,
        iceCandidates: iceCandidates,
        dtlsParameters: dtlsParameters,
        sctpParameters: sctpParameters,
        planB: true
      });
      this._sendingRtpParametersByKind = {
        audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
        video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
      };
      this._sendingRemoteRtpParametersByKind = {
        audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
        video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)
      };
      if (dtlsParameters.role && dtlsParameters.role !== 'auto') {
        this._forcedLocalDtlsRole = dtlsParameters.role === 'server' ? 'client' : 'server';
      }
      this._pc = new RTCPeerConnection(_objectSpread({
        iceServers: iceServers !== null && iceServers !== void 0 ? iceServers : [],
        iceTransportPolicy: iceTransportPolicy !== null && iceTransportPolicy !== void 0 ? iceTransportPolicy : 'all',
        bundlePolicy: 'max-bundle',
        rtcpMuxPolicy: 'require',
        sdpSemantics: 'plan-b'
      }, additionalSettings), proprietaryConstraints);
      this._pc.addEventListener('icegatheringstatechange', function () {
        _this2.emit('@icegatheringstatechange', _this2._pc.iceGatheringState);
      });
      this._pc.addEventListener('icecandidateerror', function (event) {
        _this2.emit('@icecandidateerror', event);
      });
      if (this._pc.connectionState) {
        this._pc.addEventListener('connectionstatechange', function () {
          _this2.emit('@connectionstatechange', _this2._pc.connectionState);
        });
      } else {
        this._pc.addEventListener('iceconnectionstatechange', function () {
          logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
          switch (_this2._pc.iceConnectionState) {
            case 'checking':
              {
                _this2.emit('@connectionstatechange', 'connecting');
                break;
              }
            case 'connected':
            case 'completed':
              {
                _this2.emit('@connectionstatechange', 'connected');
                break;
              }
            case 'failed':
              {
                _this2.emit('@connectionstatechange', 'failed');
                break;
              }
            case 'disconnected':
              {
                _this2.emit('@connectionstatechange', 'disconnected');
                break;
              }
            case 'closed':
              {
                _this2.emit('@connectionstatechange', 'closed');
                break;
              }
          }
        });
      }
    }
  }, {
    key: "updateIceServers",
    value: function () {
      var _updateIceServers = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(iceServers) {
        var configuration;
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.n) {
            case 0:
              logger.debug('updateIceServers()');
              configuration = this._pc.getConfiguration();
              configuration.iceServers = iceServers;
              this._pc.setConfiguration(configuration);
            case 1:
              return _context3.a(2);
          }
        }, _callee3, this);
      }));
      function updateIceServers(_x) {
        return _updateIceServers.apply(this, arguments);
      }
      return updateIceServers;
    }()
  }, {
    key: "restartIce",
    value: function () {
      var _restartIce = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(iceParameters) {
        var offer, answer, _offer, _answer;
        return _regenerator().w(function (_context4) {
          while (1) switch (_context4.n) {
            case 0:
              logger.debug('restartIce()');
              // Provide the remote SDP handler with new remote ICE parameters.
              this._remoteSdp.updateIceParameters(iceParameters);
              if (this._transportReady) {
                _context4.n = 1;
                break;
              }
              return _context4.a(2);
            case 1:
              if (!(this._direction === 'send')) {
                _context4.n = 5;
                break;
              }
              _context4.n = 2;
              return this._pc.createOffer({
                iceRestart: true
              });
            case 2:
              offer = _context4.v;
              logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context4.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context4.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              _context4.n = 8;
              break;
            case 5:
              _offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', _offer);
              _context4.n = 6;
              return this._pc.setRemoteDescription(_offer);
            case 6:
              _context4.n = 7;
              return this._pc.createAnswer();
            case 7:
              _answer = _context4.v;
              logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', _answer);
              _context4.n = 8;
              return this._pc.setLocalDescription(_answer);
            case 8:
              return _context4.a(2);
          }
        }, _callee4, this);
      }));
      function restartIce(_x2) {
        return _restartIce.apply(this, arguments);
      }
      return restartIce;
    }()
  }, {
    key: "getTransportStats",
    value: function () {
      var _getTransportStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5() {
        return _regenerator().w(function (_context5) {
          while (1) switch (_context5.n) {
            case 0:
              return _context5.a(2, this._pc.getStats());
          }
        }, _callee5, this);
      }));
      function getTransportStats() {
        return _getTransportStats.apply(this, arguments);
      }
      return getTransportStats;
    }()
  }, {
    key: "send",
    value: function () {
      var _send = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6(_ref2) {
        var track, encodings, codecOptions, codec, offer, localSdpObject, offerMediaObject, sendingRtpParameters, sendingRemoteRtpParameters, _this$_forcedLocalDtl, idx, _iterator, _step, encoding, answer, localId;
        return _regenerator().w(function (_context6) {
          while (1) switch (_context6.n) {
            case 0:
              track = _ref2.track, encodings = _ref2.encodings, codecOptions = _ref2.codecOptions, codec = _ref2.codec;
              this.assertSendDirection();
              logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
              if (codec) {
                logger.warn('send() | codec selection is not available in %s handler', this.name);
              }
              this._sendStream.addTrack(track);
              this._pc.addStream(this._sendStream);
              _context6.n = 1;
              return this._pc.createOffer();
            case 1:
              offer = _context6.v;
              localSdpObject = sdpTransform.parse(offer.sdp); // @ts-expect-error --- sdpTransform.SessionDescription type doesn't
              // define extmapAllowMixed field.
              if (localSdpObject.extmapAllowMixed) {
                this._remoteSdp.setSessionExtmapAllowMixed();
              }
              sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
              sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs);
              sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
              sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);
              if (this._transportReady) {
                _context6.n = 2;
                break;
              }
              _context6.n = 2;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl !== void 0 ? _this$_forcedLocalDtl : 'client',
                localSdpObject: localSdpObject
              });
            case 2:
              if (track.kind === 'video' && encodings && encodings.length > 1) {
                logger.debug('send() | enabling simulcast');
                localSdpObject = sdpTransform.parse(offer.sdp);
                offerMediaObject = localSdpObject.media.find(function (m) {
                  return m.type === 'video';
                });
                sdpPlanBUtils.addLegacySimulcast({
                  offerMediaObject: offerMediaObject,
                  track: track,
                  numStreams: encodings.length
                });
                offer = {
                  type: 'offer',
                  sdp: sdpTransform.write(localSdpObject)
                };
              }
              logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context6.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
              offerMediaObject = localSdpObject.media.find(function (m) {
                return m.type === track.kind;
              });
              // Set RTCP CNAME.
              sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
                offerMediaObject: offerMediaObject
              });
              // Set RTP encodings.
              sendingRtpParameters.encodings = sdpPlanBUtils.getRtpEncodings({
                offerMediaObject: offerMediaObject,
                track: track
              });
              // Complete encodings with given values.
              if (encodings) {
                for (idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
                  if (encodings[idx]) {
                    Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
                  }
                }
              }
              // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
              // each encoding.
              if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {
                _iterator = _createForOfIteratorHelper(sendingRtpParameters.encodings);
                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    encoding = _step.value;
                    encoding.scalabilityMode = 'L1T3';
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
              }
              this._remoteSdp.send({
                offerMediaObject: offerMediaObject,
                offerRtpParameters: sendingRtpParameters,
                answerRtpParameters: sendingRemoteRtpParameters,
                codecOptions: codecOptions
              });
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context6.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              localId = String(this._nextSendLocalId);
              this._nextSendLocalId++;
              // Insert into the map.
              this._mapSendLocalIdTrack.set(localId, track);
              return _context6.a(2, {
                localId: localId,
                rtpParameters: sendingRtpParameters
              });
          }
        }, _callee6, this);
      }));
      function send(_x3) {
        return _send.apply(this, arguments);
      }
      return send;
    }()
  }, {
    key: "stopSending",
    value: function () {
      var _stopSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7(localId) {
        var track, offer, answer, _t2;
        return _regenerator().w(function (_context7) {
          while (1) switch (_context7.n) {
            case 0:
              this.assertSendDirection();
              logger.debug('stopSending() [localId:%s]', localId);
              track = this._mapSendLocalIdTrack.get(localId);
              if (track) {
                _context7.n = 1;
                break;
              }
              throw new Error('track not found');
            case 1:
              this._mapSendLocalIdTrack["delete"](localId);
              this._sendStream.removeTrack(track);
              this._pc.addStream(this._sendStream);
              _context7.n = 2;
              return this._pc.createOffer();
            case 2:
              offer = _context7.v;
              logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context7.p = 3;
              _context7.n = 4;
              return this._pc.setLocalDescription(offer);
            case 4:
              _context7.n = 7;
              break;
            case 5:
              _context7.p = 5;
              _t2 = _context7.v;
              if (!(this._sendStream.getTracks().length === 0)) {
                _context7.n = 6;
                break;
              }
              logger.warn('stopSending() | ignoring expected error due no sending tracks: %s', _t2.toString());
              return _context7.a(2);
            case 6:
              throw _t2;
            case 7:
              if (!(this._pc.signalingState === 'stable')) {
                _context7.n = 8;
                break;
              }
              return _context7.a(2);
            case 8:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context7.n = 9;
              return this._pc.setRemoteDescription(answer);
            case 9:
              return _context7.a(2);
          }
        }, _callee7, this, [[3, 5]]);
      }));
      function stopSending(_x4) {
        return _stopSending.apply(this, arguments);
      }
      return stopSending;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "pauseSending",
    value: function () {
      var _pauseSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8(localId) {
        return _regenerator().w(function (_context8) {
          while (1) switch (_context8.n) {
            case 0:
              return _context8.a(2);
          }
        }, _callee8);
      }));
      function pauseSending(_x5) {
        return _pauseSending.apply(this, arguments);
      }
      return pauseSending;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "resumeSending",
    value: function () {
      var _resumeSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee9(localId) {
        return _regenerator().w(function (_context9) {
          while (1) switch (_context9.n) {
            case 0:
              return _context9.a(2);
          }
        }, _callee9);
      }));
      function resumeSending(_x6) {
        return _resumeSending.apply(this, arguments);
      }
      return resumeSending;
    }()
  }, {
    key: "replaceTrack",
    value: function () {
      var _replaceTrack = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee0(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      localId,
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      track) {
        return _regenerator().w(function (_context0) {
          while (1) switch (_context0.n) {
            case 0:
              throw new errors_1.UnsupportedError('not implemented');
            case 1:
              return _context0.a(2);
          }
        }, _callee0);
      }));
      function replaceTrack(_x7, _x8) {
        return _replaceTrack.apply(this, arguments);
      }
      return replaceTrack;
    }()
  }, {
    key: "setMaxSpatialLayer",
    value: function () {
      var _setMaxSpatialLayer = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee1(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      localId,
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      spatialLayer) {
        return _regenerator().w(function (_context1) {
          while (1) switch (_context1.n) {
            case 0:
              throw new errors_1.UnsupportedError('not implemented');
            case 1:
              return _context1.a(2);
          }
        }, _callee1);
      }));
      function setMaxSpatialLayer(_x9, _x0) {
        return _setMaxSpatialLayer.apply(this, arguments);
      }
      return setMaxSpatialLayer;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "setRtpEncodingParameters",
    value: function () {
      var _setRtpEncodingParameters = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee10(localId, params) {
        return _regenerator().w(function (_context10) {
          while (1) switch (_context10.n) {
            case 0:
              throw new errors_1.UnsupportedError('not implemented');
            case 1:
              return _context10.a(2);
          }
        }, _callee10);
      }));
      function setRtpEncodingParameters(_x1, _x10) {
        return _setRtpEncodingParameters.apply(this, arguments);
      }
      return setRtpEncodingParameters;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "getSenderStats",
    value: function () {
      var _getSenderStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee11(localId) {
        return _regenerator().w(function (_context11) {
          while (1) switch (_context11.n) {
            case 0:
              throw new errors_1.UnsupportedError('not implemented');
            case 1:
              return _context11.a(2);
          }
        }, _callee11);
      }));
      function getSenderStats(_x11) {
        return _getSenderStats.apply(this, arguments);
      }
      return getSenderStats;
    }()
  }, {
    key: "sendDataChannel",
    value: function () {
      var _sendDataChannel = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee12(_ref3) {
        var ordered, maxPacketLifeTime, maxRetransmits, label, protocol, options, dataChannel, offer, localSdpObject, offerMediaObject, _this$_forcedLocalDtl2, answer, sctpStreamParameters;
        return _regenerator().w(function (_context12) {
          while (1) switch (_context12.n) {
            case 0:
              ordered = _ref3.ordered, maxPacketLifeTime = _ref3.maxPacketLifeTime, maxRetransmits = _ref3.maxRetransmits, label = _ref3.label, protocol = _ref3.protocol;
              this.assertSendDirection();
              options = {
                negotiated: true,
                id: this._nextSendSctpStreamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmitTime: maxPacketLifeTime,
                // NOTE: Old spec.
                maxRetransmits: maxRetransmits,
                protocol: protocol
              };
              logger.debug('sendDataChannel() [options:%o]', options);
              dataChannel = this._pc.createDataChannel(label, options); // Increase next id.
              this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
              // If this is the first DataChannel we need to create the SDP answer with
              // m=application section.
              if (this._hasDataChannelMediaSection) {
                _context12.n = 5;
                break;
              }
              _context12.n = 1;
              return this._pc.createOffer();
            case 1:
              offer = _context12.v;
              localSdpObject = sdpTransform.parse(offer.sdp);
              offerMediaObject = localSdpObject.media.find(function (m) {
                return m.type === 'application';
              });
              if (this._transportReady) {
                _context12.n = 2;
                break;
              }
              _context12.n = 2;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl2 = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl2 !== void 0 ? _this$_forcedLocalDtl2 : 'client',
                localSdpObject: localSdpObject
              });
            case 2:
              logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context12.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              this._remoteSdp.sendSctpAssociation({
                offerMediaObject: offerMediaObject
              });
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context12.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              this._hasDataChannelMediaSection = true;
            case 5:
              sctpStreamParameters = {
                streamId: options.id,
                ordered: options.ordered,
                maxPacketLifeTime: options.maxPacketLifeTime,
                maxRetransmits: options.maxRetransmits
              };
              return _context12.a(2, {
                dataChannel: dataChannel,
                sctpStreamParameters: sctpStreamParameters
              });
          }
        }, _callee12, this);
      }));
      function sendDataChannel(_x12) {
        return _sendDataChannel.apply(this, arguments);
      }
      return sendDataChannel;
    }()
  }, {
    key: "receive",
    value: function () {
      var _receive = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee13(optionsList) {
        var _this3 = this;
        var results, mapStreamId, _iterator2, _step2, _options$streamId, options, trackId, kind, rtpParameters, mid, streamId, offer, answer, localSdpObject, _iterator3, _step3, _loop, _this$_forcedLocalDtl3, _iterator4, _step4, _loop2, _t3, _t4;
        return _regenerator().w(function (_context15) {
          while (1) switch (_context15.n) {
            case 0:
              this.assertRecvDirection();
              results = [];
              mapStreamId = new Map();
              _iterator2 = _createForOfIteratorHelper(optionsList);
              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  options = _step2.value;
                  trackId = options.trackId, kind = options.kind, rtpParameters = options.rtpParameters;
                  logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
                  mid = kind;
                  streamId = (_options$streamId = options.streamId) !== null && _options$streamId !== void 0 ? _options$streamId : rtpParameters.rtcp.cname; // NOTE: In React-Native we cannot reuse the same remote MediaStream for new
                  // remote tracks. This is because react-native-webrtc does not react on new
                  // tracks generated within already existing streams, so force the streamId
                  // to be different. See:
                  // https://github.com/react-native-webrtc/react-native-webrtc/issues/401
                  logger.debug('receive() | forcing a random remote streamId to avoid well known bug in react-native-webrtc');
                  streamId += "-hack-".concat(utils.generateRandomNumber());
                  mapStreamId.set(trackId, streamId);
                  this._remoteSdp.receive({
                    mid: mid,
                    kind: kind,
                    offerRtpParameters: rtpParameters,
                    streamId: streamId,
                    trackId: trackId
                  });
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context15.n = 1;
              return this._pc.setRemoteDescription(offer);
            case 1:
              _context15.n = 2;
              return this._pc.createAnswer();
            case 2:
              answer = _context15.v;
              localSdpObject = sdpTransform.parse(answer.sdp);
              _iterator3 = _createForOfIteratorHelper(optionsList);
              _context15.p = 3;
              _loop = /*#__PURE__*/_regenerator().m(function _loop() {
                var options, kind, rtpParameters, mid, answerMediaObject;
                return _regenerator().w(function (_context13) {
                  while (1) switch (_context13.n) {
                    case 0:
                      options = _step3.value;
                      kind = options.kind, rtpParameters = options.rtpParameters;
                      mid = kind;
                      answerMediaObject = localSdpObject.media.find(function (m) {
                        return String(m.mid) === mid;
                      }); // May need to modify codec parameters in the answer based on codec
                      // parameters in the offer.
                      sdpCommonUtils.applyCodecParameters({
                        offerRtpParameters: rtpParameters,
                        answerMediaObject: answerMediaObject
                      });
                    case 1:
                      return _context13.a(2);
                  }
                }, _loop);
              });
              _iterator3.s();
            case 4:
              if ((_step3 = _iterator3.n()).done) {
                _context15.n = 6;
                break;
              }
              return _context15.d(_regeneratorValues(_loop()), 5);
            case 5:
              _context15.n = 4;
              break;
            case 6:
              _context15.n = 8;
              break;
            case 7:
              _context15.p = 7;
              _t3 = _context15.v;
              _iterator3.e(_t3);
            case 8:
              _context15.p = 8;
              _iterator3.f();
              return _context15.f(8);
            case 9:
              answer = {
                type: 'answer',
                sdp: sdpTransform.write(localSdpObject)
              };
              if (this._transportReady) {
                _context15.n = 10;
                break;
              }
              _context15.n = 10;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl3 = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl3 !== void 0 ? _this$_forcedLocalDtl3 : 'client',
                localSdpObject: localSdpObject
              });
            case 10:
              logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context15.n = 11;
              return this._pc.setLocalDescription(answer);
            case 11:
              _iterator4 = _createForOfIteratorHelper(optionsList);
              _context15.p = 12;
              _loop2 = /*#__PURE__*/_regenerator().m(function _loop2() {
                var options, kind, trackId, rtpParameters, localId, mid, streamId, stream, track;
                return _regenerator().w(function (_context14) {
                  while (1) switch (_context14.n) {
                    case 0:
                      options = _step4.value;
                      kind = options.kind, trackId = options.trackId, rtpParameters = options.rtpParameters;
                      localId = trackId;
                      mid = kind;
                      streamId = mapStreamId.get(trackId);
                      stream = _this3._pc.getRemoteStreams().find(function (s) {
                        return s.id === streamId;
                      });
                      track = stream.getTrackById(localId);
                      if (track) {
                        _context14.n = 1;
                        break;
                      }
                      throw new Error('remote track not found');
                    case 1:
                      // Insert into the map.
                      _this3._mapRecvLocalIdInfo.set(localId, {
                        mid: mid,
                        rtpParameters: rtpParameters
                      });
                      results.push({
                        localId: localId,
                        track: track
                      });
                    case 2:
                      return _context14.a(2);
                  }
                }, _loop2);
              });
              _iterator4.s();
            case 13:
              if ((_step4 = _iterator4.n()).done) {
                _context15.n = 15;
                break;
              }
              return _context15.d(_regeneratorValues(_loop2()), 14);
            case 14:
              _context15.n = 13;
              break;
            case 15:
              _context15.n = 17;
              break;
            case 16:
              _context15.p = 16;
              _t4 = _context15.v;
              _iterator4.e(_t4);
            case 17:
              _context15.p = 17;
              _iterator4.f();
              return _context15.f(17);
            case 18:
              return _context15.a(2, results);
          }
        }, _callee13, this, [[12, 16, 17, 18], [3, 7, 8, 9]]);
      }));
      function receive(_x13) {
        return _receive.apply(this, arguments);
      }
      return receive;
    }()
  }, {
    key: "stopReceiving",
    value: function () {
      var _stopReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee14(localIds) {
        var _iterator5, _step5, _this$_mapRecvLocalId, localId, _ref4, mid, rtpParameters, offer, answer;
        return _regenerator().w(function (_context16) {
          while (1) switch (_context16.n) {
            case 0:
              this.assertRecvDirection();
              _iterator5 = _createForOfIteratorHelper(localIds);
              try {
                for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                  localId = _step5.value;
                  logger.debug('stopReceiving() [localId:%s]', localId);
                  _ref4 = (_this$_mapRecvLocalId = this._mapRecvLocalIdInfo.get(localId)) !== null && _this$_mapRecvLocalId !== void 0 ? _this$_mapRecvLocalId : {}, mid = _ref4.mid, rtpParameters = _ref4.rtpParameters; // Remove from the map.
                  this._mapRecvLocalIdInfo["delete"](localId);
                  this._remoteSdp.planBStopReceiving({
                    mid: mid,
                    offerRtpParameters: rtpParameters
                  });
                }
              } catch (err) {
                _iterator5.e(err);
              } finally {
                _iterator5.f();
              }
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context16.n = 1;
              return this._pc.setRemoteDescription(offer);
            case 1:
              _context16.n = 2;
              return this._pc.createAnswer();
            case 2:
              answer = _context16.v;
              logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context16.n = 3;
              return this._pc.setLocalDescription(answer);
            case 3:
              return _context16.a(2);
          }
        }, _callee14, this);
      }));
      function stopReceiving(_x14) {
        return _stopReceiving.apply(this, arguments);
      }
      return stopReceiving;
    }()
  }, {
    key: "pauseReceiving",
    value: function () {
      var _pauseReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee15(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      localIds) {
        return _regenerator().w(function (_context17) {
          while (1) switch (_context17.n) {
            case 0:
              return _context17.a(2);
          }
        }, _callee15);
      }));
      function pauseReceiving(_x15) {
        return _pauseReceiving.apply(this, arguments);
      }
      return pauseReceiving;
    }()
  }, {
    key: "resumeReceiving",
    value: function () {
      var _resumeReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee16(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      localIds) {
        return _regenerator().w(function (_context18) {
          while (1) switch (_context18.n) {
            case 0:
              return _context18.a(2);
          }
        }, _callee16);
      }));
      function resumeReceiving(_x16) {
        return _resumeReceiving.apply(this, arguments);
      }
      return resumeReceiving;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "getReceiverStats",
    value: function () {
      var _getReceiverStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee17(localId) {
        return _regenerator().w(function (_context19) {
          while (1) switch (_context19.n) {
            case 0:
              throw new errors_1.UnsupportedError('not implemented');
            case 1:
              return _context19.a(2);
          }
        }, _callee17);
      }));
      function getReceiverStats(_x17) {
        return _getReceiverStats.apply(this, arguments);
      }
      return getReceiverStats;
    }()
  }, {
    key: "receiveDataChannel",
    value: function () {
      var _receiveDataChannel = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee18(_ref5) {
        var sctpStreamParameters, label, protocol, streamId, ordered, maxPacketLifeTime, maxRetransmits, options, dataChannel, offer, answer, _this$_forcedLocalDtl4, localSdpObject;
        return _regenerator().w(function (_context20) {
          while (1) switch (_context20.n) {
            case 0:
              sctpStreamParameters = _ref5.sctpStreamParameters, label = _ref5.label, protocol = _ref5.protocol;
              this.assertRecvDirection();
              streamId = sctpStreamParameters.streamId, ordered = sctpStreamParameters.ordered, maxPacketLifeTime = sctpStreamParameters.maxPacketLifeTime, maxRetransmits = sctpStreamParameters.maxRetransmits;
              options = {
                negotiated: true,
                id: streamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmitTime: maxPacketLifeTime,
                // NOTE: Old spec.
                maxRetransmits: maxRetransmits,
                protocol: protocol
              };
              logger.debug('receiveDataChannel() [options:%o]', options);
              dataChannel = this._pc.createDataChannel(label, options); // If this is the first DataChannel we need to create the SDP offer with
              // m=application section.
              if (this._hasDataChannelMediaSection) {
                _context20.n = 5;
                break;
              }
              this._remoteSdp.receiveSctpAssociation({
                oldDataChannelSpec: true
              });
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context20.n = 1;
              return this._pc.setRemoteDescription(offer);
            case 1:
              _context20.n = 2;
              return this._pc.createAnswer();
            case 2:
              answer = _context20.v;
              if (this._transportReady) {
                _context20.n = 3;
                break;
              }
              localSdpObject = sdpTransform.parse(answer.sdp);
              _context20.n = 3;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl4 = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl4 !== void 0 ? _this$_forcedLocalDtl4 : 'client',
                localSdpObject: localSdpObject
              });
            case 3:
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context20.n = 4;
              return this._pc.setLocalDescription(answer);
            case 4:
              this._hasDataChannelMediaSection = true;
            case 5:
              return _context20.a(2, {
                dataChannel: dataChannel
              });
          }
        }, _callee18, this);
      }));
      function receiveDataChannel(_x18) {
        return _receiveDataChannel.apply(this, arguments);
      }
      return receiveDataChannel;
    }()
  }, {
    key: "setupTransport",
    value: function () {
      var _setupTransport = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee19(_ref6) {
        var _this4 = this;
        var localDtlsRole, localSdpObject, dtlsParameters;
        return _regenerator().w(function (_context21) {
          while (1) switch (_context21.n) {
            case 0:
              localDtlsRole = _ref6.localDtlsRole, localSdpObject = _ref6.localSdpObject;
              if (!localSdpObject) {
                localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
              }
              // Get our local DTLS parameters.
              dtlsParameters = sdpCommonUtils.extractDtlsParameters({
                sdpObject: localSdpObject
              }); // Set our DTLS role.
              dtlsParameters.role = localDtlsRole;
              // Update the remote DTLS role in the SDP.
              this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
              // Need to tell the remote transport about our parameters.
              _context21.n = 1;
              return new Promise(function (resolve, reject) {
                _this4.safeEmit('@connect', {
                  dtlsParameters: dtlsParameters
                }, resolve, reject);
              });
            case 1:
              this._transportReady = true;
            case 2:
              return _context21.a(2);
          }
        }, _callee19, this);
      }));
      function setupTransport(_x19) {
        return _setupTransport.apply(this, arguments);
      }
      return setupTransport;
    }()
  }, {
    key: "assertSendDirection",
    value: function assertSendDirection() {
      if (this._direction !== 'send') {
        throw new Error('method can just be called for handlers with "send" direction');
      }
    }
  }, {
    key: "assertRecvDirection",
    value: function assertRecvDirection() {
      if (this._direction !== 'recv') {
        throw new Error('method can just be called for handlers with "recv" direction');
      }
    }
  }], [{
    key: "createFactory",
    value:
    /**
     * Creates a factory function.
     */
    function createFactory() {
      return function () {
        return new ReactNative();
      };
    }
  }]);
}(HandlerInterface_1.HandlerInterface);
exports.ReactNative = ReactNative;

},{"../Logger":39,"../errors":45,"../ortc":68,"../utils":72,"./HandlerInterface":55,"./sdp/RemoteSdp":63,"./sdp/commonUtils":64,"./sdp/planBUtils":65,"sdp-transform":76}],57:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorValues(e) { if (null != e) { var t = e["function" == typeof Symbol && Symbol.iterator || "@@iterator"], r = 0; if (t) return t.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) return { next: function next() { return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e }; } }; } throw new TypeError(_typeof(e) + " is not iterable"); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o("next", 0), o("throw", 1), o("return", 2); } }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ReactNativeUnifiedPlan = void 0;
var sdpTransform = require("sdp-transform");
var Logger_1 = require("../Logger");
var utils = require("../utils");
var ortc = require("../ortc");
var sdpCommonUtils = require("./sdp/commonUtils");
var sdpUnifiedPlanUtils = require("./sdp/unifiedPlanUtils");
var ortcUtils = require("./ortc/utils");
var errors_1 = require("../errors");
var HandlerInterface_1 = require("./HandlerInterface");
var RemoteSdp_1 = require("./sdp/RemoteSdp");
var scalabilityModes_1 = require("../scalabilityModes");
var logger = new Logger_1.Logger('ReactNativeUnifiedPlan');
var NAME = 'ReactNativeUnifiedPlan';
var SCTP_NUM_STREAMS = {
  OS: 1024,
  MIS: 1024
};
var ReactNativeUnifiedPlan = /*#__PURE__*/function (_HandlerInterface_1$H) {
  function ReactNativeUnifiedPlan() {
    var _this;
    _classCallCheck(this, ReactNativeUnifiedPlan);
    _this = _callSuper(this, ReactNativeUnifiedPlan);
    // Closed flag.
    _defineProperty(_this, "_closed", false);
    // Handler direction.
    _defineProperty(_this, "_direction", void 0);
    // Remote SDP handler.
    _defineProperty(_this, "_remoteSdp", void 0);
    // Generic sending RTP parameters for audio and video.
    _defineProperty(_this, "_sendingRtpParametersByKind", void 0);
    // Generic sending RTP parameters for audio and video suitable for the SDP
    // remote answer.
    _defineProperty(_this, "_sendingRemoteRtpParametersByKind", void 0);
    // Initial server side DTLS role. If not 'auto', it will force the opposite
    // value in client side.
    _defineProperty(_this, "_forcedLocalDtlsRole", void 0);
    // RTCPeerConnection instance.
    _defineProperty(_this, "_pc", void 0);
    // Map of RTCTransceivers indexed by MID.
    _defineProperty(_this, "_mapMidTransceiver", new Map());
    // Local stream for sending.
    _defineProperty(_this, "_sendStream", new MediaStream());
    // Whether a DataChannel m=application section has been created.
    _defineProperty(_this, "_hasDataChannelMediaSection", false);
    // Sending DataChannel id value counter. Incremented for each new DataChannel.
    _defineProperty(_this, "_nextSendSctpStreamId", 0);
    // Got transport local and remote parameters.
    _defineProperty(_this, "_transportReady", false);
    return _this;
  }
  _inherits(ReactNativeUnifiedPlan, _HandlerInterface_1$H);
  return _createClass(ReactNativeUnifiedPlan, [{
    key: "name",
    get: function get() {
      return NAME;
    }
  }, {
    key: "close",
    value: function close() {
      logger.debug('close()');
      if (this._closed) {
        return;
      }
      this._closed = true;
      // Free/dispose native MediaStream but DO NOT free/dispose native
      // MediaStreamTracks (that is parent's business).
      // @ts-expect-error --- Proprietary API in react-native-webrtc.
      this._sendStream.release(/* releaseTracks */false);
      // Close RTCPeerConnection.
      if (this._pc) {
        try {
          this._pc.close();
        } catch (error) {}
      }
      this.emit('@close');
    }
  }, {
    key: "getNativeRtpCapabilities",
    value: function () {
      var _getNativeRtpCapabilities = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {
        var pc, offer, sdpObject, nativeRtpCapabilities, _t;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              logger.debug('getNativeRtpCapabilities()');
              pc = new RTCPeerConnection({
                iceServers: [],
                iceTransportPolicy: 'all',
                bundlePolicy: 'max-bundle',
                rtcpMuxPolicy: 'require',
                sdpSemantics: 'unified-plan'
              });
              _context.p = 1;
              pc.addTransceiver('audio');
              pc.addTransceiver('video');
              _context.n = 2;
              return pc.createOffer();
            case 2:
              offer = _context.v;
              try {
                pc.close();
              } catch (error) {}
              sdpObject = sdpTransform.parse(offer.sdp);
              nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject: sdpObject
              }); // libwebrtc supports NACK for OPUS but doesn't announce it.
              ortcUtils.addNackSupportForOpus(nativeRtpCapabilities);
              return _context.a(2, nativeRtpCapabilities);
            case 3:
              _context.p = 3;
              _t = _context.v;
              try {
                pc.close();
              } catch (error2) {}
              throw _t;
            case 4:
              return _context.a(2);
          }
        }, _callee, null, [[1, 3]]);
      }));
      function getNativeRtpCapabilities() {
        return _getNativeRtpCapabilities.apply(this, arguments);
      }
      return getNativeRtpCapabilities;
    }()
  }, {
    key: "getNativeSctpCapabilities",
    value: function () {
      var _getNativeSctpCapabilities = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2() {
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.n) {
            case 0:
              logger.debug('getNativeSctpCapabilities()');
              return _context2.a(2, {
                numStreams: SCTP_NUM_STREAMS
              });
          }
        }, _callee2);
      }));
      function getNativeSctpCapabilities() {
        return _getNativeSctpCapabilities.apply(this, arguments);
      }
      return getNativeSctpCapabilities;
    }()
  }, {
    key: "run",
    value: function run(_ref) {
      var _this2 = this;
      var direction = _ref.direction,
        iceParameters = _ref.iceParameters,
        iceCandidates = _ref.iceCandidates,
        dtlsParameters = _ref.dtlsParameters,
        sctpParameters = _ref.sctpParameters,
        iceServers = _ref.iceServers,
        iceTransportPolicy = _ref.iceTransportPolicy,
        additionalSettings = _ref.additionalSettings,
        proprietaryConstraints = _ref.proprietaryConstraints,
        extendedRtpCapabilities = _ref.extendedRtpCapabilities;
      this.assertNotClosed();
      logger.debug('run()');
      this._direction = direction;
      this._remoteSdp = new RemoteSdp_1.RemoteSdp({
        iceParameters: iceParameters,
        iceCandidates: iceCandidates,
        dtlsParameters: dtlsParameters,
        sctpParameters: sctpParameters
      });
      this._sendingRtpParametersByKind = {
        audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
        video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
      };
      this._sendingRemoteRtpParametersByKind = {
        audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
        video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)
      };
      if (dtlsParameters.role && dtlsParameters.role !== 'auto') {
        this._forcedLocalDtlsRole = dtlsParameters.role === 'server' ? 'client' : 'server';
      }
      this._pc = new RTCPeerConnection(_objectSpread({
        iceServers: iceServers !== null && iceServers !== void 0 ? iceServers : [],
        iceTransportPolicy: iceTransportPolicy !== null && iceTransportPolicy !== void 0 ? iceTransportPolicy : 'all',
        bundlePolicy: 'max-bundle',
        rtcpMuxPolicy: 'require',
        sdpSemantics: 'unified-plan'
      }, additionalSettings), proprietaryConstraints);
      this._pc.addEventListener('icegatheringstatechange', function () {
        _this2.emit('@icegatheringstatechange', _this2._pc.iceGatheringState);
      });
      this._pc.addEventListener('icecandidateerror', function (event) {
        _this2.emit('@icecandidateerror', event);
      });
      if (this._pc.connectionState) {
        this._pc.addEventListener('connectionstatechange', function () {
          _this2.emit('@connectionstatechange', _this2._pc.connectionState);
        });
      } else {
        this._pc.addEventListener('iceconnectionstatechange', function () {
          logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
          switch (_this2._pc.iceConnectionState) {
            case 'checking':
              {
                _this2.emit('@connectionstatechange', 'connecting');
                break;
              }
            case 'connected':
            case 'completed':
              {
                _this2.emit('@connectionstatechange', 'connected');
                break;
              }
            case 'failed':
              {
                _this2.emit('@connectionstatechange', 'failed');
                break;
              }
            case 'disconnected':
              {
                _this2.emit('@connectionstatechange', 'disconnected');
                break;
              }
            case 'closed':
              {
                _this2.emit('@connectionstatechange', 'closed');
                break;
              }
          }
        });
      }
    }
  }, {
    key: "updateIceServers",
    value: function () {
      var _updateIceServers = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(iceServers) {
        var configuration;
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.n) {
            case 0:
              this.assertNotClosed();
              logger.debug('updateIceServers()');
              configuration = this._pc.getConfiguration();
              configuration.iceServers = iceServers;
              this._pc.setConfiguration(configuration);
            case 1:
              return _context3.a(2);
          }
        }, _callee3, this);
      }));
      function updateIceServers(_x) {
        return _updateIceServers.apply(this, arguments);
      }
      return updateIceServers;
    }()
  }, {
    key: "restartIce",
    value: function () {
      var _restartIce = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(iceParameters) {
        var offer, answer, _offer, _answer;
        return _regenerator().w(function (_context4) {
          while (1) switch (_context4.n) {
            case 0:
              this.assertNotClosed();
              logger.debug('restartIce()');
              // Provide the remote SDP handler with new remote ICE parameters.
              this._remoteSdp.updateIceParameters(iceParameters);
              if (this._transportReady) {
                _context4.n = 1;
                break;
              }
              return _context4.a(2);
            case 1:
              if (!(this._direction === 'send')) {
                _context4.n = 5;
                break;
              }
              _context4.n = 2;
              return this._pc.createOffer({
                iceRestart: true
              });
            case 2:
              offer = _context4.v;
              logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context4.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context4.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              _context4.n = 8;
              break;
            case 5:
              _offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', _offer);
              _context4.n = 6;
              return this._pc.setRemoteDescription(_offer);
            case 6:
              _context4.n = 7;
              return this._pc.createAnswer();
            case 7:
              _answer = _context4.v;
              logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', _answer);
              _context4.n = 8;
              return this._pc.setLocalDescription(_answer);
            case 8:
              return _context4.a(2);
          }
        }, _callee4, this);
      }));
      function restartIce(_x2) {
        return _restartIce.apply(this, arguments);
      }
      return restartIce;
    }()
  }, {
    key: "getTransportStats",
    value: function () {
      var _getTransportStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5() {
        return _regenerator().w(function (_context5) {
          while (1) switch (_context5.n) {
            case 0:
              this.assertNotClosed();
              return _context5.a(2, this._pc.getStats());
          }
        }, _callee5, this);
      }));
      function getTransportStats() {
        return _getTransportStats.apply(this, arguments);
      }
      return getTransportStats;
    }()
  }, {
    key: "send",
    value: function () {
      var _send = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6(_ref2) {
        var _transceiver$mid;
        var track, encodings, codecOptions, codec, onRtpSender, sendingRtpParameters, sendingRemoteRtpParameters, mediaSectionIdx, transceiver, offer, localSdpObject, offerMediaObject, _this$_forcedLocalDtl, hackVp9Svc, layers, localId, newEncodings, _iterator, _step, encoding, answer;
        return _regenerator().w(function (_context6) {
          while (1) switch (_context6.n) {
            case 0:
              track = _ref2.track, encodings = _ref2.encodings, codecOptions = _ref2.codecOptions, codec = _ref2.codec, onRtpSender = _ref2.onRtpSender;
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
              if (encodings && encodings.length > 1) {
                encodings.forEach(function (encoding, idx) {
                  encoding.rid = "r".concat(idx);
                });
              }
              sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]); // This may throw.
              sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
              sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]); // This may throw.
              sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
              mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
              transceiver = this._pc.addTransceiver(track, {
                direction: 'sendonly',
                streams: [this._sendStream],
                sendEncodings: encodings
              });
              if (onRtpSender) {
                onRtpSender(transceiver.sender);
              }
              _context6.n = 1;
              return this._pc.createOffer();
            case 1:
              offer = _context6.v;
              localSdpObject = sdpTransform.parse(offer.sdp); // @ts-expect-error --- sdpTransform.SessionDescription type doesn't
              // define extmapAllowMixed field.
              if (localSdpObject.extmapAllowMixed) {
                this._remoteSdp.setSessionExtmapAllowMixed();
              }
              if (this._transportReady) {
                _context6.n = 2;
                break;
              }
              _context6.n = 2;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl !== void 0 ? _this$_forcedLocalDtl : 'client',
                localSdpObject: localSdpObject
              });
            case 2:
              // Special case for VP9 with SVC.
              hackVp9Svc = false;
              layers = (0, scalabilityModes_1.parse)((encodings !== null && encodings !== void 0 ? encodings : [{}])[0].scalabilityMode);
              if (encodings && encodings.length === 1 && layers.spatialLayers > 1 && sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp9') {
                logger.debug('send() | enabling legacy simulcast for VP9 SVC');
                hackVp9Svc = true;
                localSdpObject = sdpTransform.parse(offer.sdp);
                offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
                sdpUnifiedPlanUtils.addLegacySimulcast({
                  offerMediaObject: offerMediaObject,
                  numStreams: layers.spatialLayers
                });
                offer = {
                  type: 'offer',
                  sdp: sdpTransform.write(localSdpObject)
                };
              }
              logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context6.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              // We can now get the transceiver.mid.
              // NOTE: We cannot read generated MID on iOS react-native-webrtc 111.0.0
              // because transceiver.mid is not available until setRemoteDescription()
              // is called, so this is best effort.
              // Issue: https://github.com/react-native-webrtc/react-native-webrtc/issues/1404
              // NOTE: So let's fill MID in sendingRtpParameters later.
              // NOTE: This is fixed in react-native-webrtc 111.0.3.
              localId = (_transceiver$mid = transceiver.mid) !== null && _transceiver$mid !== void 0 ? _transceiver$mid : undefined;
              if (!localId) {
                logger.warn('send() | missing transceiver.mid (bug in react-native-webrtc, using a workaround');
              }
              // Set MID.
              // NOTE: As per above, it could be unset yet.
              sendingRtpParameters.mid = localId;
              localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
              offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
              // Set RTCP CNAME.
              sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
                offerMediaObject: offerMediaObject
              });
              // Set RTP encodings by parsing the SDP offer if no encodings are given.
              if (!encodings) {
                sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
                  offerMediaObject: offerMediaObject
                });
              }
              // Set RTP encodings by parsing the SDP offer and complete them with given
              // one if just a single encoding has been given.
              else if (encodings.length === 1) {
                newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
                  offerMediaObject: offerMediaObject
                });
                Object.assign(newEncodings[0], encodings[0]);
                // Hack for VP9 SVC.
                if (hackVp9Svc) {
                  newEncodings = [newEncodings[0]];
                }
                sendingRtpParameters.encodings = newEncodings;
              }
              // Otherwise if more than 1 encoding are given use them verbatim.
              else {
                sendingRtpParameters.encodings = encodings;
              }
              // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
              // each encoding.
              if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {
                _iterator = _createForOfIteratorHelper(sendingRtpParameters.encodings);
                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    encoding = _step.value;
                    if (encoding.scalabilityMode) {
                      encoding.scalabilityMode = "L1T".concat(layers.temporalLayers);
                    } else {
                      encoding.scalabilityMode = 'L1T3';
                    }
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
              }
              this._remoteSdp.send({
                offerMediaObject: offerMediaObject,
                reuseMid: mediaSectionIdx.reuseMid,
                offerRtpParameters: sendingRtpParameters,
                answerRtpParameters: sendingRemoteRtpParameters,
                codecOptions: codecOptions
              });
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context6.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              // Follow up of iOS react-native-webrtc 111.0.0 issue told above. Now yes,
              // we can read generated MID (if not done above) and fill sendingRtpParameters.
              // NOTE: This is fixed in react-native-webrtc 111.0.3 so this block isn't
              // needed starting from that version.
              if (!localId) {
                localId = transceiver.mid;
                sendingRtpParameters.mid = localId;
              }
              // Store in the map.
              this._mapMidTransceiver.set(localId, transceiver);
              return _context6.a(2, {
                localId: localId,
                rtpParameters: sendingRtpParameters,
                rtpSender: transceiver.sender
              });
          }
        }, _callee6, this);
      }));
      function send(_x3) {
        return _send.apply(this, arguments);
      }
      return send;
    }()
  }, {
    key: "stopSending",
    value: function () {
      var _stopSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7(localId) {
        var transceiver, mediaSectionClosed, offer, answer;
        return _regenerator().w(function (_context7) {
          while (1) switch (_context7.n) {
            case 0:
              this.assertSendDirection();
              if (!this._closed) {
                _context7.n = 1;
                break;
              }
              return _context7.a(2);
            case 1:
              logger.debug('stopSending() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context7.n = 2;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 2:
              void transceiver.sender.replaceTrack(null);
              this._pc.removeTrack(transceiver.sender);
              mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
              if (mediaSectionClosed) {
                try {
                  transceiver.stop();
                } catch (error) {}
              }
              _context7.n = 3;
              return this._pc.createOffer();
            case 3:
              offer = _context7.v;
              logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context7.n = 4;
              return this._pc.setLocalDescription(offer);
            case 4:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context7.n = 5;
              return this._pc.setRemoteDescription(answer);
            case 5:
              this._mapMidTransceiver["delete"](localId);
            case 6:
              return _context7.a(2);
          }
        }, _callee7, this);
      }));
      function stopSending(_x4) {
        return _stopSending.apply(this, arguments);
      }
      return stopSending;
    }()
  }, {
    key: "pauseSending",
    value: function () {
      var _pauseSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8(localId) {
        var transceiver, offer, answer;
        return _regenerator().w(function (_context8) {
          while (1) switch (_context8.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('pauseSending() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context8.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              transceiver.direction = 'inactive';
              this._remoteSdp.pauseMediaSection(localId);
              _context8.n = 2;
              return this._pc.createOffer();
            case 2:
              offer = _context8.v;
              logger.debug('pauseSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context8.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('pauseSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context8.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              return _context8.a(2);
          }
        }, _callee8, this);
      }));
      function pauseSending(_x5) {
        return _pauseSending.apply(this, arguments);
      }
      return pauseSending;
    }()
  }, {
    key: "resumeSending",
    value: function () {
      var _resumeSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee9(localId) {
        var transceiver, offer, answer;
        return _regenerator().w(function (_context9) {
          while (1) switch (_context9.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('resumeSending() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              this._remoteSdp.resumeSendingMediaSection(localId);
              if (transceiver) {
                _context9.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              transceiver.direction = 'sendonly';
              _context9.n = 2;
              return this._pc.createOffer();
            case 2:
              offer = _context9.v;
              logger.debug('resumeSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context9.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('resumeSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context9.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              return _context9.a(2);
          }
        }, _callee9, this);
      }));
      function resumeSending(_x6) {
        return _resumeSending.apply(this, arguments);
      }
      return resumeSending;
    }()
  }, {
    key: "replaceTrack",
    value: function () {
      var _replaceTrack = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee0(localId, track) {
        var transceiver;
        return _regenerator().w(function (_context0) {
          while (1) switch (_context0.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              if (track) {
                logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
              } else {
                logger.debug('replaceTrack() [localId:%s, no track]', localId);
              }
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context0.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              _context0.n = 2;
              return transceiver.sender.replaceTrack(track);
            case 2:
              return _context0.a(2);
          }
        }, _callee0, this);
      }));
      function replaceTrack(_x7, _x8) {
        return _replaceTrack.apply(this, arguments);
      }
      return replaceTrack;
    }()
  }, {
    key: "setMaxSpatialLayer",
    value: function () {
      var _setMaxSpatialLayer = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee1(localId, spatialLayer) {
        var transceiver, parameters, offer, answer;
        return _regenerator().w(function (_context1) {
          while (1) switch (_context1.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context1.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              parameters = transceiver.sender.getParameters();
              parameters.encodings.forEach(function (encoding, idx) {
                if (idx <= spatialLayer) {
                  encoding.active = true;
                } else {
                  encoding.active = false;
                }
              });
              _context1.n = 2;
              return transceiver.sender.setParameters(parameters);
            case 2:
              this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
              _context1.n = 3;
              return this._pc.createOffer();
            case 3:
              offer = _context1.v;
              logger.debug('setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context1.n = 4;
              return this._pc.setLocalDescription(offer);
            case 4:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context1.n = 5;
              return this._pc.setRemoteDescription(answer);
            case 5:
              return _context1.a(2);
          }
        }, _callee1, this);
      }));
      function setMaxSpatialLayer(_x9, _x0) {
        return _setMaxSpatialLayer.apply(this, arguments);
      }
      return setMaxSpatialLayer;
    }()
  }, {
    key: "setRtpEncodingParameters",
    value: function () {
      var _setRtpEncodingParameters = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee10(localId, params) {
        var transceiver, parameters, offer, answer;
        return _regenerator().w(function (_context10) {
          while (1) switch (_context10.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context10.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              parameters = transceiver.sender.getParameters();
              parameters.encodings.forEach(function (encoding, idx) {
                parameters.encodings[idx] = _objectSpread(_objectSpread({}, encoding), params);
              });
              _context10.n = 2;
              return transceiver.sender.setParameters(parameters);
            case 2:
              this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
              _context10.n = 3;
              return this._pc.createOffer();
            case 3:
              offer = _context10.v;
              logger.debug('setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context10.n = 4;
              return this._pc.setLocalDescription(offer);
            case 4:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context10.n = 5;
              return this._pc.setRemoteDescription(answer);
            case 5:
              return _context10.a(2);
          }
        }, _callee10, this);
      }));
      function setRtpEncodingParameters(_x1, _x10) {
        return _setRtpEncodingParameters.apply(this, arguments);
      }
      return setRtpEncodingParameters;
    }()
  }, {
    key: "getSenderStats",
    value: function () {
      var _getSenderStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee11(localId) {
        var transceiver;
        return _regenerator().w(function (_context11) {
          while (1) switch (_context11.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context11.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              return _context11.a(2, transceiver.sender.getStats());
          }
        }, _callee11, this);
      }));
      function getSenderStats(_x11) {
        return _getSenderStats.apply(this, arguments);
      }
      return getSenderStats;
    }()
  }, {
    key: "sendDataChannel",
    value: function () {
      var _sendDataChannel = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee12(_ref3) {
        var ordered, maxPacketLifeTime, maxRetransmits, label, protocol, options, dataChannel, offer, localSdpObject, offerMediaObject, _this$_forcedLocalDtl2, answer, sctpStreamParameters;
        return _regenerator().w(function (_context12) {
          while (1) switch (_context12.n) {
            case 0:
              ordered = _ref3.ordered, maxPacketLifeTime = _ref3.maxPacketLifeTime, maxRetransmits = _ref3.maxRetransmits, label = _ref3.label, protocol = _ref3.protocol;
              this.assertNotClosed();
              this.assertSendDirection();
              options = {
                negotiated: true,
                id: this._nextSendSctpStreamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmits: maxRetransmits,
                protocol: protocol
              };
              logger.debug('sendDataChannel() [options:%o]', options);
              dataChannel = this._pc.createDataChannel(label, options); // Increase next id.
              this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
              // If this is the first DataChannel we need to create the SDP answer with
              // m=application section.
              if (this._hasDataChannelMediaSection) {
                _context12.n = 5;
                break;
              }
              _context12.n = 1;
              return this._pc.createOffer();
            case 1:
              offer = _context12.v;
              localSdpObject = sdpTransform.parse(offer.sdp);
              offerMediaObject = localSdpObject.media.find(function (m) {
                return m.type === 'application';
              });
              if (this._transportReady) {
                _context12.n = 2;
                break;
              }
              _context12.n = 2;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl2 = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl2 !== void 0 ? _this$_forcedLocalDtl2 : 'client',
                localSdpObject: localSdpObject
              });
            case 2:
              logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context12.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              this._remoteSdp.sendSctpAssociation({
                offerMediaObject: offerMediaObject
              });
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context12.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              this._hasDataChannelMediaSection = true;
            case 5:
              sctpStreamParameters = {
                streamId: options.id,
                ordered: options.ordered,
                maxPacketLifeTime: options.maxPacketLifeTime,
                maxRetransmits: options.maxRetransmits
              };
              return _context12.a(2, {
                dataChannel: dataChannel,
                sctpStreamParameters: sctpStreamParameters
              });
          }
        }, _callee12, this);
      }));
      function sendDataChannel(_x12) {
        return _sendDataChannel.apply(this, arguments);
      }
      return sendDataChannel;
    }()
  }, {
    key: "receive",
    value: function () {
      var _receive = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee13(optionsList) {
        var _this3 = this;
        var results, mapLocalId, _iterator2, _step2, _rtpParameters$mid, options, trackId, kind, rtpParameters, streamId, localId, offer, _iterator3, _step3, _loop, answer, localSdpObject, _iterator4, _step4, _loop2, _this$_forcedLocalDtl3, _iterator5, _step5, _loop3, _t2, _t3, _t4;
        return _regenerator().w(function (_context16) {
          while (1) switch (_context16.n) {
            case 0:
              this.assertNotClosed();
              this.assertRecvDirection();
              results = [];
              mapLocalId = new Map();
              _iterator2 = _createForOfIteratorHelper(optionsList);
              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  options = _step2.value;
                  trackId = options.trackId, kind = options.kind, rtpParameters = options.rtpParameters, streamId = options.streamId;
                  logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
                  localId = (_rtpParameters$mid = rtpParameters.mid) !== null && _rtpParameters$mid !== void 0 ? _rtpParameters$mid : String(this._mapMidTransceiver.size);
                  mapLocalId.set(trackId, localId);
                  this._remoteSdp.receive({
                    mid: localId,
                    kind: kind,
                    offerRtpParameters: rtpParameters,
                    streamId: streamId !== null && streamId !== void 0 ? streamId : rtpParameters.rtcp.cname,
                    trackId: trackId
                  });
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context16.n = 1;
              return this._pc.setRemoteDescription(offer);
            case 1:
              _iterator3 = _createForOfIteratorHelper(optionsList);
              _context16.p = 2;
              _loop = /*#__PURE__*/_regenerator().m(function _loop() {
                var options, trackId, onRtpReceiver, _localId, transceiver;
                return _regenerator().w(function (_context13) {
                  while (1) switch (_context13.n) {
                    case 0:
                      options = _step3.value;
                      trackId = options.trackId, onRtpReceiver = options.onRtpReceiver;
                      if (!onRtpReceiver) {
                        _context13.n = 2;
                        break;
                      }
                      _localId = mapLocalId.get(trackId);
                      transceiver = _this3._pc.getTransceivers().find(function (t) {
                        return t.mid === _localId;
                      });
                      if (transceiver) {
                        _context13.n = 1;
                        break;
                      }
                      throw new Error('transceiver not found');
                    case 1:
                      onRtpReceiver(transceiver.receiver);
                    case 2:
                      return _context13.a(2);
                  }
                }, _loop);
              });
              _iterator3.s();
            case 3:
              if ((_step3 = _iterator3.n()).done) {
                _context16.n = 5;
                break;
              }
              return _context16.d(_regeneratorValues(_loop()), 4);
            case 4:
              _context16.n = 3;
              break;
            case 5:
              _context16.n = 7;
              break;
            case 6:
              _context16.p = 6;
              _t2 = _context16.v;
              _iterator3.e(_t2);
            case 7:
              _context16.p = 7;
              _iterator3.f();
              return _context16.f(7);
            case 8:
              _context16.n = 9;
              return this._pc.createAnswer();
            case 9:
              answer = _context16.v;
              localSdpObject = sdpTransform.parse(answer.sdp);
              _iterator4 = _createForOfIteratorHelper(optionsList);
              _context16.p = 10;
              _loop2 = /*#__PURE__*/_regenerator().m(function _loop2() {
                var options, trackId, rtpParameters, localId, answerMediaObject;
                return _regenerator().w(function (_context14) {
                  while (1) switch (_context14.n) {
                    case 0:
                      options = _step4.value;
                      trackId = options.trackId, rtpParameters = options.rtpParameters;
                      localId = mapLocalId.get(trackId);
                      answerMediaObject = localSdpObject.media.find(function (m) {
                        return String(m.mid) === localId;
                      }); // May need to modify codec parameters in the answer based on codec
                      // parameters in the offer.
                      sdpCommonUtils.applyCodecParameters({
                        offerRtpParameters: rtpParameters,
                        answerMediaObject: answerMediaObject
                      });
                    case 1:
                      return _context14.a(2);
                  }
                }, _loop2);
              });
              _iterator4.s();
            case 11:
              if ((_step4 = _iterator4.n()).done) {
                _context16.n = 13;
                break;
              }
              return _context16.d(_regeneratorValues(_loop2()), 12);
            case 12:
              _context16.n = 11;
              break;
            case 13:
              _context16.n = 15;
              break;
            case 14:
              _context16.p = 14;
              _t3 = _context16.v;
              _iterator4.e(_t3);
            case 15:
              _context16.p = 15;
              _iterator4.f();
              return _context16.f(15);
            case 16:
              answer = {
                type: 'answer',
                sdp: sdpTransform.write(localSdpObject)
              };
              if (this._transportReady) {
                _context16.n = 17;
                break;
              }
              _context16.n = 17;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl3 = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl3 !== void 0 ? _this$_forcedLocalDtl3 : 'client',
                localSdpObject: localSdpObject
              });
            case 17:
              logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context16.n = 18;
              return this._pc.setLocalDescription(answer);
            case 18:
              _iterator5 = _createForOfIteratorHelper(optionsList);
              _context16.p = 19;
              _loop3 = /*#__PURE__*/_regenerator().m(function _loop3() {
                var options, trackId, localId, transceiver;
                return _regenerator().w(function (_context15) {
                  while (1) switch (_context15.n) {
                    case 0:
                      options = _step5.value;
                      trackId = options.trackId;
                      localId = mapLocalId.get(trackId);
                      transceiver = _this3._pc.getTransceivers().find(function (t) {
                        return t.mid === localId;
                      });
                      if (transceiver) {
                        _context15.n = 1;
                        break;
                      }
                      throw new Error('new RTCRtpTransceiver not found');
                    case 1:
                      // Store in the map.
                      _this3._mapMidTransceiver.set(localId, transceiver);
                      results.push({
                        localId: localId,
                        track: transceiver.receiver.track,
                        rtpReceiver: transceiver.receiver
                      });
                    case 2:
                      return _context15.a(2);
                  }
                }, _loop3);
              });
              _iterator5.s();
            case 20:
              if ((_step5 = _iterator5.n()).done) {
                _context16.n = 22;
                break;
              }
              return _context16.d(_regeneratorValues(_loop3()), 21);
            case 21:
              _context16.n = 20;
              break;
            case 22:
              _context16.n = 24;
              break;
            case 23:
              _context16.p = 23;
              _t4 = _context16.v;
              _iterator5.e(_t4);
            case 24:
              _context16.p = 24;
              _iterator5.f();
              return _context16.f(24);
            case 25:
              return _context16.a(2, results);
          }
        }, _callee13, this, [[19, 23, 24, 25], [10, 14, 15, 16], [2, 6, 7, 8]]);
      }));
      function receive(_x13) {
        return _receive.apply(this, arguments);
      }
      return receive;
    }()
  }, {
    key: "stopReceiving",
    value: function () {
      var _stopReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee14(localIds) {
        var _iterator6, _step6, localId, transceiver, offer, answer, _iterator7, _step7, _localId2, _t5;
        return _regenerator().w(function (_context17) {
          while (1) switch (_context17.n) {
            case 0:
              this.assertRecvDirection();
              if (!this._closed) {
                _context17.n = 1;
                break;
              }
              return _context17.a(2);
            case 1:
              _iterator6 = _createForOfIteratorHelper(localIds);
              _context17.p = 2;
              _iterator6.s();
            case 3:
              if ((_step6 = _iterator6.n()).done) {
                _context17.n = 6;
                break;
              }
              localId = _step6.value;
              logger.debug('stopReceiving() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context17.n = 4;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 4:
              this._remoteSdp.closeMediaSection(transceiver.mid);
            case 5:
              _context17.n = 3;
              break;
            case 6:
              _context17.n = 8;
              break;
            case 7:
              _context17.p = 7;
              _t5 = _context17.v;
              _iterator6.e(_t5);
            case 8:
              _context17.p = 8;
              _iterator6.f();
              return _context17.f(8);
            case 9:
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context17.n = 10;
              return this._pc.setRemoteDescription(offer);
            case 10:
              _context17.n = 11;
              return this._pc.createAnswer();
            case 11:
              answer = _context17.v;
              logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context17.n = 12;
              return this._pc.setLocalDescription(answer);
            case 12:
              _iterator7 = _createForOfIteratorHelper(localIds);
              try {
                for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                  _localId2 = _step7.value;
                  this._mapMidTransceiver["delete"](_localId2);
                }
              } catch (err) {
                _iterator7.e(err);
              } finally {
                _iterator7.f();
              }
            case 13:
              return _context17.a(2);
          }
        }, _callee14, this, [[2, 7, 8, 9]]);
      }));
      function stopReceiving(_x14) {
        return _stopReceiving.apply(this, arguments);
      }
      return stopReceiving;
    }()
  }, {
    key: "pauseReceiving",
    value: function () {
      var _pauseReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee15(localIds) {
        var _iterator8, _step8, localId, transceiver, offer, answer, _t6;
        return _regenerator().w(function (_context18) {
          while (1) switch (_context18.n) {
            case 0:
              this.assertNotClosed();
              this.assertRecvDirection();
              _iterator8 = _createForOfIteratorHelper(localIds);
              _context18.p = 1;
              _iterator8.s();
            case 2:
              if ((_step8 = _iterator8.n()).done) {
                _context18.n = 5;
                break;
              }
              localId = _step8.value;
              logger.debug('pauseReceiving() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context18.n = 3;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 3:
              transceiver.direction = 'inactive';
              this._remoteSdp.pauseMediaSection(localId);
            case 4:
              _context18.n = 2;
              break;
            case 5:
              _context18.n = 7;
              break;
            case 6:
              _context18.p = 6;
              _t6 = _context18.v;
              _iterator8.e(_t6);
            case 7:
              _context18.p = 7;
              _iterator8.f();
              return _context18.f(7);
            case 8:
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context18.n = 9;
              return this._pc.setRemoteDescription(offer);
            case 9:
              _context18.n = 10;
              return this._pc.createAnswer();
            case 10:
              answer = _context18.v;
              logger.debug('pauseReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context18.n = 11;
              return this._pc.setLocalDescription(answer);
            case 11:
              return _context18.a(2);
          }
        }, _callee15, this, [[1, 6, 7, 8]]);
      }));
      function pauseReceiving(_x15) {
        return _pauseReceiving.apply(this, arguments);
      }
      return pauseReceiving;
    }()
  }, {
    key: "resumeReceiving",
    value: function () {
      var _resumeReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee16(localIds) {
        var _iterator9, _step9, localId, transceiver, offer, answer, _t7;
        return _regenerator().w(function (_context19) {
          while (1) switch (_context19.n) {
            case 0:
              this.assertNotClosed();
              this.assertRecvDirection();
              _iterator9 = _createForOfIteratorHelper(localIds);
              _context19.p = 1;
              _iterator9.s();
            case 2:
              if ((_step9 = _iterator9.n()).done) {
                _context19.n = 5;
                break;
              }
              localId = _step9.value;
              logger.debug('resumeReceiving() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context19.n = 3;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 3:
              transceiver.direction = 'recvonly';
              this._remoteSdp.resumeReceivingMediaSection(localId);
            case 4:
              _context19.n = 2;
              break;
            case 5:
              _context19.n = 7;
              break;
            case 6:
              _context19.p = 6;
              _t7 = _context19.v;
              _iterator9.e(_t7);
            case 7:
              _context19.p = 7;
              _iterator9.f();
              return _context19.f(7);
            case 8:
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context19.n = 9;
              return this._pc.setRemoteDescription(offer);
            case 9:
              _context19.n = 10;
              return this._pc.createAnswer();
            case 10:
              answer = _context19.v;
              logger.debug('resumeReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context19.n = 11;
              return this._pc.setLocalDescription(answer);
            case 11:
              return _context19.a(2);
          }
        }, _callee16, this, [[1, 6, 7, 8]]);
      }));
      function resumeReceiving(_x16) {
        return _resumeReceiving.apply(this, arguments);
      }
      return resumeReceiving;
    }()
  }, {
    key: "getReceiverStats",
    value: function () {
      var _getReceiverStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee17(localId) {
        var transceiver;
        return _regenerator().w(function (_context20) {
          while (1) switch (_context20.n) {
            case 0:
              this.assertNotClosed();
              this.assertRecvDirection();
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context20.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              return _context20.a(2, transceiver.receiver.getStats());
          }
        }, _callee17, this);
      }));
      function getReceiverStats(_x17) {
        return _getReceiverStats.apply(this, arguments);
      }
      return getReceiverStats;
    }()
  }, {
    key: "receiveDataChannel",
    value: function () {
      var _receiveDataChannel = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee18(_ref4) {
        var sctpStreamParameters, label, protocol, streamId, ordered, maxPacketLifeTime, maxRetransmits, options, dataChannel, offer, answer, _this$_forcedLocalDtl4, localSdpObject;
        return _regenerator().w(function (_context21) {
          while (1) switch (_context21.n) {
            case 0:
              sctpStreamParameters = _ref4.sctpStreamParameters, label = _ref4.label, protocol = _ref4.protocol;
              this.assertNotClosed();
              this.assertRecvDirection();
              streamId = sctpStreamParameters.streamId, ordered = sctpStreamParameters.ordered, maxPacketLifeTime = sctpStreamParameters.maxPacketLifeTime, maxRetransmits = sctpStreamParameters.maxRetransmits;
              options = {
                negotiated: true,
                id: streamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmits: maxRetransmits,
                protocol: protocol
              };
              logger.debug('receiveDataChannel() [options:%o]', options);
              dataChannel = this._pc.createDataChannel(label, options); // If this is the first DataChannel we need to create the SDP offer with
              // m=application section.
              if (this._hasDataChannelMediaSection) {
                _context21.n = 5;
                break;
              }
              this._remoteSdp.receiveSctpAssociation();
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context21.n = 1;
              return this._pc.setRemoteDescription(offer);
            case 1:
              _context21.n = 2;
              return this._pc.createAnswer();
            case 2:
              answer = _context21.v;
              if (this._transportReady) {
                _context21.n = 3;
                break;
              }
              localSdpObject = sdpTransform.parse(answer.sdp);
              _context21.n = 3;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl4 = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl4 !== void 0 ? _this$_forcedLocalDtl4 : 'client',
                localSdpObject: localSdpObject
              });
            case 3:
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context21.n = 4;
              return this._pc.setLocalDescription(answer);
            case 4:
              this._hasDataChannelMediaSection = true;
            case 5:
              return _context21.a(2, {
                dataChannel: dataChannel
              });
          }
        }, _callee18, this);
      }));
      function receiveDataChannel(_x18) {
        return _receiveDataChannel.apply(this, arguments);
      }
      return receiveDataChannel;
    }()
  }, {
    key: "setupTransport",
    value: function () {
      var _setupTransport = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee19(_ref5) {
        var _this4 = this;
        var localDtlsRole, localSdpObject, dtlsParameters;
        return _regenerator().w(function (_context22) {
          while (1) switch (_context22.n) {
            case 0:
              localDtlsRole = _ref5.localDtlsRole, localSdpObject = _ref5.localSdpObject;
              if (!localSdpObject) {
                localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
              }
              // Get our local DTLS parameters.
              dtlsParameters = sdpCommonUtils.extractDtlsParameters({
                sdpObject: localSdpObject
              }); // Set our DTLS role.
              dtlsParameters.role = localDtlsRole;
              // Update the remote DTLS role in the SDP.
              this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
              // Need to tell the remote transport about our parameters.
              _context22.n = 1;
              return new Promise(function (resolve, reject) {
                _this4.safeEmit('@connect', {
                  dtlsParameters: dtlsParameters
                }, resolve, reject);
              });
            case 1:
              this._transportReady = true;
            case 2:
              return _context22.a(2);
          }
        }, _callee19, this);
      }));
      function setupTransport(_x19) {
        return _setupTransport.apply(this, arguments);
      }
      return setupTransport;
    }()
  }, {
    key: "assertNotClosed",
    value: function assertNotClosed() {
      if (this._closed) {
        throw new errors_1.InvalidStateError('method called in a closed handler');
      }
    }
  }, {
    key: "assertSendDirection",
    value: function assertSendDirection() {
      if (this._direction !== 'send') {
        throw new Error('method can just be called for handlers with "send" direction');
      }
    }
  }, {
    key: "assertRecvDirection",
    value: function assertRecvDirection() {
      if (this._direction !== 'recv') {
        throw new Error('method can just be called for handlers with "recv" direction');
      }
    }
  }], [{
    key: "createFactory",
    value:
    /**
     * Creates a factory function.
     */
    function createFactory() {
      return function () {
        return new ReactNativeUnifiedPlan();
      };
    }
  }]);
}(HandlerInterface_1.HandlerInterface);
exports.ReactNativeUnifiedPlan = ReactNativeUnifiedPlan;

},{"../Logger":39,"../errors":45,"../ortc":68,"../scalabilityModes":69,"../utils":72,"./HandlerInterface":55,"./ortc/utils":61,"./sdp/RemoteSdp":63,"./sdp/commonUtils":64,"./sdp/unifiedPlanUtils":66,"sdp-transform":76}],58:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorValues(e) { if (null != e) { var t = e["function" == typeof Symbol && Symbol.iterator || "@@iterator"], r = 0; if (t) return t.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) return { next: function next() { return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e }; } }; } throw new TypeError(_typeof(e) + " is not iterable"); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o("next", 0), o("throw", 1), o("return", 2); } }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Safari11 = void 0;
var sdpTransform = require("sdp-transform");
var Logger_1 = require("../Logger");
var utils = require("../utils");
var ortc = require("../ortc");
var sdpCommonUtils = require("./sdp/commonUtils");
var sdpPlanBUtils = require("./sdp/planBUtils");
var HandlerInterface_1 = require("./HandlerInterface");
var RemoteSdp_1 = require("./sdp/RemoteSdp");
var logger = new Logger_1.Logger('Safari11');
var NAME = 'Safari11';
var SCTP_NUM_STREAMS = {
  OS: 1024,
  MIS: 1024
};
var Safari11 = /*#__PURE__*/function (_HandlerInterface_1$H) {
  function Safari11() {
    var _this;
    _classCallCheck(this, Safari11);
    _this = _callSuper(this, Safari11);
    // Handler direction.
    _defineProperty(_this, "_direction", void 0);
    // Remote SDP handler.
    _defineProperty(_this, "_remoteSdp", void 0);
    // Generic sending RTP parameters for audio and video.
    _defineProperty(_this, "_sendingRtpParametersByKind", void 0);
    // Generic sending RTP parameters for audio and video suitable for the SDP
    // remote answer.
    _defineProperty(_this, "_sendingRemoteRtpParametersByKind", void 0);
    // Initial server side DTLS role. If not 'auto', it will force the opposite
    // value in client side.
    _defineProperty(_this, "_forcedLocalDtlsRole", void 0);
    // RTCPeerConnection instance.
    _defineProperty(_this, "_pc", void 0);
    // Local stream for sending.
    _defineProperty(_this, "_sendStream", new MediaStream());
    // Map of RTCRtpSender indexed by localId.
    _defineProperty(_this, "_mapSendLocalIdRtpSender", new Map());
    // Next sending localId.
    _defineProperty(_this, "_nextSendLocalId", 0);
    // Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.
    // Value is an Object with mid, rtpParameters and rtpReceiver.
    _defineProperty(_this, "_mapRecvLocalIdInfo", new Map());
    // Whether a DataChannel m=application section has been created.
    _defineProperty(_this, "_hasDataChannelMediaSection", false);
    // Sending DataChannel id value counter. Incremented for each new DataChannel.
    _defineProperty(_this, "_nextSendSctpStreamId", 0);
    // Got transport local and remote parameters.
    _defineProperty(_this, "_transportReady", false);
    return _this;
  }
  _inherits(Safari11, _HandlerInterface_1$H);
  return _createClass(Safari11, [{
    key: "name",
    get: function get() {
      return NAME;
    }
  }, {
    key: "close",
    value: function close() {
      logger.debug('close()');
      // Close RTCPeerConnection.
      if (this._pc) {
        try {
          this._pc.close();
        } catch (error) {}
      }
      this.emit('@close');
    }
  }, {
    key: "getNativeRtpCapabilities",
    value: function () {
      var _getNativeRtpCapabilities = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {
        var pc, offer, sdpObject, nativeRtpCapabilities, _t;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              logger.debug('getNativeRtpCapabilities()');
              pc = new RTCPeerConnection({
                iceServers: [],
                iceTransportPolicy: 'all',
                bundlePolicy: 'max-bundle',
                rtcpMuxPolicy: 'require',
                sdpSemantics: 'plan-b'
              });
              _context.p = 1;
              _context.n = 2;
              return pc.createOffer({
                offerToReceiveAudio: true,
                offerToReceiveVideo: true
              });
            case 2:
              offer = _context.v;
              try {
                pc.close();
              } catch (error) {}
              sdpObject = sdpTransform.parse(offer.sdp);
              nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject: sdpObject
              });
              return _context.a(2, nativeRtpCapabilities);
            case 3:
              _context.p = 3;
              _t = _context.v;
              try {
                pc.close();
              } catch (error2) {}
              throw _t;
            case 4:
              return _context.a(2);
          }
        }, _callee, null, [[1, 3]]);
      }));
      function getNativeRtpCapabilities() {
        return _getNativeRtpCapabilities.apply(this, arguments);
      }
      return getNativeRtpCapabilities;
    }()
  }, {
    key: "getNativeSctpCapabilities",
    value: function () {
      var _getNativeSctpCapabilities = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2() {
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.n) {
            case 0:
              logger.debug('getNativeSctpCapabilities()');
              return _context2.a(2, {
                numStreams: SCTP_NUM_STREAMS
              });
          }
        }, _callee2);
      }));
      function getNativeSctpCapabilities() {
        return _getNativeSctpCapabilities.apply(this, arguments);
      }
      return getNativeSctpCapabilities;
    }()
  }, {
    key: "run",
    value: function run(_ref) {
      var _this2 = this;
      var direction = _ref.direction,
        iceParameters = _ref.iceParameters,
        iceCandidates = _ref.iceCandidates,
        dtlsParameters = _ref.dtlsParameters,
        sctpParameters = _ref.sctpParameters,
        iceServers = _ref.iceServers,
        iceTransportPolicy = _ref.iceTransportPolicy,
        additionalSettings = _ref.additionalSettings,
        proprietaryConstraints = _ref.proprietaryConstraints,
        extendedRtpCapabilities = _ref.extendedRtpCapabilities;
      logger.debug('run()');
      this._direction = direction;
      this._remoteSdp = new RemoteSdp_1.RemoteSdp({
        iceParameters: iceParameters,
        iceCandidates: iceCandidates,
        dtlsParameters: dtlsParameters,
        sctpParameters: sctpParameters,
        planB: true
      });
      this._sendingRtpParametersByKind = {
        audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
        video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
      };
      this._sendingRemoteRtpParametersByKind = {
        audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
        video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)
      };
      if (dtlsParameters.role && dtlsParameters.role !== 'auto') {
        this._forcedLocalDtlsRole = dtlsParameters.role === 'server' ? 'client' : 'server';
      }
      this._pc = new RTCPeerConnection(_objectSpread({
        iceServers: iceServers !== null && iceServers !== void 0 ? iceServers : [],
        iceTransportPolicy: iceTransportPolicy !== null && iceTransportPolicy !== void 0 ? iceTransportPolicy : 'all',
        bundlePolicy: 'max-bundle',
        rtcpMuxPolicy: 'require'
      }, additionalSettings), proprietaryConstraints);
      this._pc.addEventListener('icegatheringstatechange', function () {
        _this2.emit('@icegatheringstatechange', _this2._pc.iceGatheringState);
      });
      this._pc.addEventListener('icecandidateerror', function (event) {
        _this2.emit('@icecandidateerror', event);
      });
      if (this._pc.connectionState) {
        this._pc.addEventListener('connectionstatechange', function () {
          _this2.emit('@connectionstatechange', _this2._pc.connectionState);
        });
      } else {
        this._pc.addEventListener('iceconnectionstatechange', function () {
          logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
          switch (_this2._pc.iceConnectionState) {
            case 'checking':
              {
                _this2.emit('@connectionstatechange', 'connecting');
                break;
              }
            case 'connected':
            case 'completed':
              {
                _this2.emit('@connectionstatechange', 'connected');
                break;
              }
            case 'failed':
              {
                _this2.emit('@connectionstatechange', 'failed');
                break;
              }
            case 'disconnected':
              {
                _this2.emit('@connectionstatechange', 'disconnected');
                break;
              }
            case 'closed':
              {
                _this2.emit('@connectionstatechange', 'closed');
                break;
              }
          }
        });
      }
    }
  }, {
    key: "updateIceServers",
    value: function () {
      var _updateIceServers = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(iceServers) {
        var configuration;
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.n) {
            case 0:
              logger.debug('updateIceServers()');
              configuration = this._pc.getConfiguration();
              configuration.iceServers = iceServers;
              this._pc.setConfiguration(configuration);
            case 1:
              return _context3.a(2);
          }
        }, _callee3, this);
      }));
      function updateIceServers(_x) {
        return _updateIceServers.apply(this, arguments);
      }
      return updateIceServers;
    }()
  }, {
    key: "restartIce",
    value: function () {
      var _restartIce = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(iceParameters) {
        var offer, answer, _offer, _answer;
        return _regenerator().w(function (_context4) {
          while (1) switch (_context4.n) {
            case 0:
              logger.debug('restartIce()');
              // Provide the remote SDP handler with new remote ICE parameters.
              this._remoteSdp.updateIceParameters(iceParameters);
              if (this._transportReady) {
                _context4.n = 1;
                break;
              }
              return _context4.a(2);
            case 1:
              if (!(this._direction === 'send')) {
                _context4.n = 5;
                break;
              }
              _context4.n = 2;
              return this._pc.createOffer({
                iceRestart: true
              });
            case 2:
              offer = _context4.v;
              logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context4.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context4.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              _context4.n = 8;
              break;
            case 5:
              _offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', _offer);
              _context4.n = 6;
              return this._pc.setRemoteDescription(_offer);
            case 6:
              _context4.n = 7;
              return this._pc.createAnswer();
            case 7:
              _answer = _context4.v;
              logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', _answer);
              _context4.n = 8;
              return this._pc.setLocalDescription(_answer);
            case 8:
              return _context4.a(2);
          }
        }, _callee4, this);
      }));
      function restartIce(_x2) {
        return _restartIce.apply(this, arguments);
      }
      return restartIce;
    }()
  }, {
    key: "getTransportStats",
    value: function () {
      var _getTransportStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5() {
        return _regenerator().w(function (_context5) {
          while (1) switch (_context5.n) {
            case 0:
              return _context5.a(2, this._pc.getStats());
          }
        }, _callee5, this);
      }));
      function getTransportStats() {
        return _getTransportStats.apply(this, arguments);
      }
      return getTransportStats;
    }()
  }, {
    key: "send",
    value: function () {
      var _send = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6(_ref2) {
        var track, encodings, codecOptions, codec, offer, localSdpObject, offerMediaObject, sendingRtpParameters, sendingRemoteRtpParameters, _this$_forcedLocalDtl, idx, _iterator, _step, encoding, answer, localId, rtpSender;
        return _regenerator().w(function (_context6) {
          while (1) switch (_context6.n) {
            case 0:
              track = _ref2.track, encodings = _ref2.encodings, codecOptions = _ref2.codecOptions, codec = _ref2.codec;
              this.assertSendDirection();
              logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
              if (codec) {
                logger.warn('send() | codec selection is not available in %s handler', this.name);
              }
              this._sendStream.addTrack(track);
              this._pc.addTrack(track, this._sendStream);
              _context6.n = 1;
              return this._pc.createOffer();
            case 1:
              offer = _context6.v;
              localSdpObject = sdpTransform.parse(offer.sdp); // @ts-expect-error --- sdpTransform.SessionDescription type doesn't
              // define extmapAllowMixed field.
              if (localSdpObject.extmapAllowMixed) {
                this._remoteSdp.setSessionExtmapAllowMixed();
              }
              sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
              sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs);
              sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
              sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);
              if (this._transportReady) {
                _context6.n = 2;
                break;
              }
              _context6.n = 2;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl !== void 0 ? _this$_forcedLocalDtl : 'client',
                localSdpObject: localSdpObject
              });
            case 2:
              if (track.kind === 'video' && encodings && encodings.length > 1) {
                logger.debug('send() | enabling simulcast');
                localSdpObject = sdpTransform.parse(offer.sdp);
                offerMediaObject = localSdpObject.media.find(function (m) {
                  return m.type === 'video';
                });
                sdpPlanBUtils.addLegacySimulcast({
                  offerMediaObject: offerMediaObject,
                  track: track,
                  numStreams: encodings.length
                });
                offer = {
                  type: 'offer',
                  sdp: sdpTransform.write(localSdpObject)
                };
              }
              logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context6.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
              offerMediaObject = localSdpObject.media.find(function (m) {
                return m.type === track.kind;
              });
              // Set RTCP CNAME.
              sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
                offerMediaObject: offerMediaObject
              });
              // Set RTP encodings.
              sendingRtpParameters.encodings = sdpPlanBUtils.getRtpEncodings({
                offerMediaObject: offerMediaObject,
                track: track
              });
              // Complete encodings with given values.
              if (encodings) {
                for (idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
                  if (encodings[idx]) {
                    Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
                  }
                }
              }
              // If VP8 and there is effective simulcast, add scalabilityMode to each
              // encoding.
              if (sendingRtpParameters.encodings.length > 1 && sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8') {
                _iterator = _createForOfIteratorHelper(sendingRtpParameters.encodings);
                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    encoding = _step.value;
                    encoding.scalabilityMode = 'L1T3';
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
              }
              this._remoteSdp.send({
                offerMediaObject: offerMediaObject,
                offerRtpParameters: sendingRtpParameters,
                answerRtpParameters: sendingRemoteRtpParameters,
                codecOptions: codecOptions
              });
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context6.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              localId = String(this._nextSendLocalId);
              this._nextSendLocalId++;
              rtpSender = this._pc.getSenders().find(function (s) {
                return s.track === track;
              }); // Insert into the map.
              this._mapSendLocalIdRtpSender.set(localId, rtpSender);
              return _context6.a(2, {
                localId: localId,
                rtpParameters: sendingRtpParameters,
                rtpSender: rtpSender
              });
          }
        }, _callee6, this);
      }));
      function send(_x3) {
        return _send.apply(this, arguments);
      }
      return send;
    }()
  }, {
    key: "stopSending",
    value: function () {
      var _stopSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7(localId) {
        var rtpSender, offer, answer, _t2;
        return _regenerator().w(function (_context7) {
          while (1) switch (_context7.n) {
            case 0:
              this.assertSendDirection();
              rtpSender = this._mapSendLocalIdRtpSender.get(localId);
              if (rtpSender) {
                _context7.n = 1;
                break;
              }
              throw new Error('associated RTCRtpSender not found');
            case 1:
              if (rtpSender.track) {
                this._sendStream.removeTrack(rtpSender.track);
              }
              this._mapSendLocalIdRtpSender["delete"](localId);
              _context7.n = 2;
              return this._pc.createOffer();
            case 2:
              offer = _context7.v;
              logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context7.p = 3;
              _context7.n = 4;
              return this._pc.setLocalDescription(offer);
            case 4:
              _context7.n = 7;
              break;
            case 5:
              _context7.p = 5;
              _t2 = _context7.v;
              if (!(this._sendStream.getTracks().length === 0)) {
                _context7.n = 6;
                break;
              }
              logger.warn('stopSending() | ignoring expected error due no sending tracks: %s', _t2.toString());
              return _context7.a(2);
            case 6:
              throw _t2;
            case 7:
              if (!(this._pc.signalingState === 'stable')) {
                _context7.n = 8;
                break;
              }
              return _context7.a(2);
            case 8:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context7.n = 9;
              return this._pc.setRemoteDescription(answer);
            case 9:
              return _context7.a(2);
          }
        }, _callee7, this, [[3, 5]]);
      }));
      function stopSending(_x4) {
        return _stopSending.apply(this, arguments);
      }
      return stopSending;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "pauseSending",
    value: function () {
      var _pauseSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8(localId) {
        return _regenerator().w(function (_context8) {
          while (1) switch (_context8.n) {
            case 0:
              return _context8.a(2);
          }
        }, _callee8);
      }));
      function pauseSending(_x5) {
        return _pauseSending.apply(this, arguments);
      }
      return pauseSending;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "resumeSending",
    value: function () {
      var _resumeSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee9(localId) {
        return _regenerator().w(function (_context9) {
          while (1) switch (_context9.n) {
            case 0:
              return _context9.a(2);
          }
        }, _callee9);
      }));
      function resumeSending(_x6) {
        return _resumeSending.apply(this, arguments);
      }
      return resumeSending;
    }()
  }, {
    key: "replaceTrack",
    value: function () {
      var _replaceTrack = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee0(localId, track) {
        var rtpSender, oldTrack;
        return _regenerator().w(function (_context0) {
          while (1) switch (_context0.n) {
            case 0:
              this.assertSendDirection();
              if (track) {
                logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
              } else {
                logger.debug('replaceTrack() [localId:%s, no track]', localId);
              }
              rtpSender = this._mapSendLocalIdRtpSender.get(localId);
              if (rtpSender) {
                _context0.n = 1;
                break;
              }
              throw new Error('associated RTCRtpSender not found');
            case 1:
              oldTrack = rtpSender.track;
              _context0.n = 2;
              return rtpSender.replaceTrack(track);
            case 2:
              // Remove the old track from the local stream.
              if (oldTrack) {
                this._sendStream.removeTrack(oldTrack);
              }
              // Add the new track to the local stream.
              if (track) {
                this._sendStream.addTrack(track);
              }
            case 3:
              return _context0.a(2);
          }
        }, _callee0, this);
      }));
      function replaceTrack(_x7, _x8) {
        return _replaceTrack.apply(this, arguments);
      }
      return replaceTrack;
    }()
  }, {
    key: "setMaxSpatialLayer",
    value: function () {
      var _setMaxSpatialLayer = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee1(localId, spatialLayer) {
        var rtpSender, parameters;
        return _regenerator().w(function (_context1) {
          while (1) switch (_context1.n) {
            case 0:
              this.assertSendDirection();
              logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
              rtpSender = this._mapSendLocalIdRtpSender.get(localId);
              if (rtpSender) {
                _context1.n = 1;
                break;
              }
              throw new Error('associated RTCRtpSender not found');
            case 1:
              parameters = rtpSender.getParameters();
              parameters.encodings.forEach(function (encoding, idx) {
                if (idx <= spatialLayer) {
                  encoding.active = true;
                } else {
                  encoding.active = false;
                }
              });
              _context1.n = 2;
              return rtpSender.setParameters(parameters);
            case 2:
              return _context1.a(2);
          }
        }, _callee1, this);
      }));
      function setMaxSpatialLayer(_x9, _x0) {
        return _setMaxSpatialLayer.apply(this, arguments);
      }
      return setMaxSpatialLayer;
    }()
  }, {
    key: "setRtpEncodingParameters",
    value: function () {
      var _setRtpEncodingParameters = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee10(localId, params) {
        var rtpSender, parameters;
        return _regenerator().w(function (_context10) {
          while (1) switch (_context10.n) {
            case 0:
              this.assertSendDirection();
              logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
              rtpSender = this._mapSendLocalIdRtpSender.get(localId);
              if (rtpSender) {
                _context10.n = 1;
                break;
              }
              throw new Error('associated RTCRtpSender not found');
            case 1:
              parameters = rtpSender.getParameters();
              parameters.encodings.forEach(function (encoding, idx) {
                parameters.encodings[idx] = _objectSpread(_objectSpread({}, encoding), params);
              });
              _context10.n = 2;
              return rtpSender.setParameters(parameters);
            case 2:
              return _context10.a(2);
          }
        }, _callee10, this);
      }));
      function setRtpEncodingParameters(_x1, _x10) {
        return _setRtpEncodingParameters.apply(this, arguments);
      }
      return setRtpEncodingParameters;
    }()
  }, {
    key: "getSenderStats",
    value: function () {
      var _getSenderStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee11(localId) {
        var rtpSender;
        return _regenerator().w(function (_context11) {
          while (1) switch (_context11.n) {
            case 0:
              this.assertSendDirection();
              rtpSender = this._mapSendLocalIdRtpSender.get(localId);
              if (rtpSender) {
                _context11.n = 1;
                break;
              }
              throw new Error('associated RTCRtpSender not found');
            case 1:
              return _context11.a(2, rtpSender.getStats());
          }
        }, _callee11, this);
      }));
      function getSenderStats(_x11) {
        return _getSenderStats.apply(this, arguments);
      }
      return getSenderStats;
    }()
  }, {
    key: "sendDataChannel",
    value: function () {
      var _sendDataChannel = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee12(_ref3) {
        var ordered, maxPacketLifeTime, maxRetransmits, label, protocol, options, dataChannel, offer, localSdpObject, offerMediaObject, _this$_forcedLocalDtl2, answer, sctpStreamParameters;
        return _regenerator().w(function (_context12) {
          while (1) switch (_context12.n) {
            case 0:
              ordered = _ref3.ordered, maxPacketLifeTime = _ref3.maxPacketLifeTime, maxRetransmits = _ref3.maxRetransmits, label = _ref3.label, protocol = _ref3.protocol;
              this.assertSendDirection();
              options = {
                negotiated: true,
                id: this._nextSendSctpStreamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmits: maxRetransmits,
                protocol: protocol
              };
              logger.debug('sendDataChannel() [options:%o]', options);
              dataChannel = this._pc.createDataChannel(label, options); // Increase next id.
              this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
              // If this is the first DataChannel we need to create the SDP answer with
              // m=application section.
              if (this._hasDataChannelMediaSection) {
                _context12.n = 5;
                break;
              }
              _context12.n = 1;
              return this._pc.createOffer();
            case 1:
              offer = _context12.v;
              localSdpObject = sdpTransform.parse(offer.sdp);
              offerMediaObject = localSdpObject.media.find(function (m) {
                return m.type === 'application';
              });
              if (this._transportReady) {
                _context12.n = 2;
                break;
              }
              _context12.n = 2;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl2 = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl2 !== void 0 ? _this$_forcedLocalDtl2 : 'client',
                localSdpObject: localSdpObject
              });
            case 2:
              logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context12.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              this._remoteSdp.sendSctpAssociation({
                offerMediaObject: offerMediaObject
              });
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context12.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              this._hasDataChannelMediaSection = true;
            case 5:
              sctpStreamParameters = {
                streamId: options.id,
                ordered: options.ordered,
                maxPacketLifeTime: options.maxPacketLifeTime,
                maxRetransmits: options.maxRetransmits
              };
              return _context12.a(2, {
                dataChannel: dataChannel,
                sctpStreamParameters: sctpStreamParameters
              });
          }
        }, _callee12, this);
      }));
      function sendDataChannel(_x12) {
        return _sendDataChannel.apply(this, arguments);
      }
      return sendDataChannel;
    }()
  }, {
    key: "receive",
    value: function () {
      var _receive = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee13(optionsList) {
        var _this3 = this;
        var results, _iterator2, _step2, options, trackId, kind, rtpParameters, streamId, mid, offer, answer, localSdpObject, _iterator3, _step3, _loop, _this$_forcedLocalDtl3, _iterator4, _step4, _loop2, _t3, _t4;
        return _regenerator().w(function (_context15) {
          while (1) switch (_context15.n) {
            case 0:
              this.assertRecvDirection();
              results = [];
              _iterator2 = _createForOfIteratorHelper(optionsList);
              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  options = _step2.value;
                  trackId = options.trackId, kind = options.kind, rtpParameters = options.rtpParameters, streamId = options.streamId;
                  logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
                  mid = kind;
                  this._remoteSdp.receive({
                    mid: mid,
                    kind: kind,
                    offerRtpParameters: rtpParameters,
                    streamId: streamId !== null && streamId !== void 0 ? streamId : rtpParameters.rtcp.cname,
                    trackId: trackId
                  });
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context15.n = 1;
              return this._pc.setRemoteDescription(offer);
            case 1:
              _context15.n = 2;
              return this._pc.createAnswer();
            case 2:
              answer = _context15.v;
              localSdpObject = sdpTransform.parse(answer.sdp);
              _iterator3 = _createForOfIteratorHelper(optionsList);
              _context15.p = 3;
              _loop = /*#__PURE__*/_regenerator().m(function _loop() {
                var options, kind, rtpParameters, mid, answerMediaObject;
                return _regenerator().w(function (_context13) {
                  while (1) switch (_context13.n) {
                    case 0:
                      options = _step3.value;
                      kind = options.kind, rtpParameters = options.rtpParameters;
                      mid = kind;
                      answerMediaObject = localSdpObject.media.find(function (m) {
                        return String(m.mid) === mid;
                      }); // May need to modify codec parameters in the answer based on codec
                      // parameters in the offer.
                      sdpCommonUtils.applyCodecParameters({
                        offerRtpParameters: rtpParameters,
                        answerMediaObject: answerMediaObject
                      });
                    case 1:
                      return _context13.a(2);
                  }
                }, _loop);
              });
              _iterator3.s();
            case 4:
              if ((_step3 = _iterator3.n()).done) {
                _context15.n = 6;
                break;
              }
              return _context15.d(_regeneratorValues(_loop()), 5);
            case 5:
              _context15.n = 4;
              break;
            case 6:
              _context15.n = 8;
              break;
            case 7:
              _context15.p = 7;
              _t3 = _context15.v;
              _iterator3.e(_t3);
            case 8:
              _context15.p = 8;
              _iterator3.f();
              return _context15.f(8);
            case 9:
              answer = {
                type: 'answer',
                sdp: sdpTransform.write(localSdpObject)
              };
              if (this._transportReady) {
                _context15.n = 10;
                break;
              }
              _context15.n = 10;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl3 = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl3 !== void 0 ? _this$_forcedLocalDtl3 : 'client',
                localSdpObject: localSdpObject
              });
            case 10:
              logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context15.n = 11;
              return this._pc.setLocalDescription(answer);
            case 11:
              _iterator4 = _createForOfIteratorHelper(optionsList);
              _context15.p = 12;
              _loop2 = /*#__PURE__*/_regenerator().m(function _loop2() {
                var options, kind, trackId, rtpParameters, mid, localId, rtpReceiver;
                return _regenerator().w(function (_context14) {
                  while (1) switch (_context14.n) {
                    case 0:
                      options = _step4.value;
                      kind = options.kind, trackId = options.trackId, rtpParameters = options.rtpParameters;
                      mid = kind;
                      localId = trackId;
                      rtpReceiver = _this3._pc.getReceivers().find(function (r) {
                        return r.track && r.track.id === localId;
                      });
                      if (rtpReceiver) {
                        _context14.n = 1;
                        break;
                      }
                      throw new Error('new RTCRtpReceiver not');
                    case 1:
                      // Insert into the map.
                      _this3._mapRecvLocalIdInfo.set(localId, {
                        mid: mid,
                        rtpParameters: rtpParameters,
                        rtpReceiver: rtpReceiver
                      });
                      results.push({
                        localId: localId,
                        track: rtpReceiver.track,
                        rtpReceiver: rtpReceiver
                      });
                    case 2:
                      return _context14.a(2);
                  }
                }, _loop2);
              });
              _iterator4.s();
            case 13:
              if ((_step4 = _iterator4.n()).done) {
                _context15.n = 15;
                break;
              }
              return _context15.d(_regeneratorValues(_loop2()), 14);
            case 14:
              _context15.n = 13;
              break;
            case 15:
              _context15.n = 17;
              break;
            case 16:
              _context15.p = 16;
              _t4 = _context15.v;
              _iterator4.e(_t4);
            case 17:
              _context15.p = 17;
              _iterator4.f();
              return _context15.f(17);
            case 18:
              return _context15.a(2, results);
          }
        }, _callee13, this, [[12, 16, 17, 18], [3, 7, 8, 9]]);
      }));
      function receive(_x13) {
        return _receive.apply(this, arguments);
      }
      return receive;
    }()
  }, {
    key: "stopReceiving",
    value: function () {
      var _stopReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee14(localIds) {
        var _iterator5, _step5, _this$_mapRecvLocalId, localId, _ref4, mid, rtpParameters, offer, answer;
        return _regenerator().w(function (_context16) {
          while (1) switch (_context16.n) {
            case 0:
              this.assertRecvDirection();
              _iterator5 = _createForOfIteratorHelper(localIds);
              try {
                for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                  localId = _step5.value;
                  logger.debug('stopReceiving() [localId:%s]', localId);
                  _ref4 = (_this$_mapRecvLocalId = this._mapRecvLocalIdInfo.get(localId)) !== null && _this$_mapRecvLocalId !== void 0 ? _this$_mapRecvLocalId : {}, mid = _ref4.mid, rtpParameters = _ref4.rtpParameters; // Remove from the map.
                  this._mapRecvLocalIdInfo["delete"](localId);
                  this._remoteSdp.planBStopReceiving({
                    mid: mid,
                    offerRtpParameters: rtpParameters
                  });
                }
              } catch (err) {
                _iterator5.e(err);
              } finally {
                _iterator5.f();
              }
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context16.n = 1;
              return this._pc.setRemoteDescription(offer);
            case 1:
              _context16.n = 2;
              return this._pc.createAnswer();
            case 2:
              answer = _context16.v;
              logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context16.n = 3;
              return this._pc.setLocalDescription(answer);
            case 3:
              return _context16.a(2);
          }
        }, _callee14, this);
      }));
      function stopReceiving(_x14) {
        return _stopReceiving.apply(this, arguments);
      }
      return stopReceiving;
    }()
  }, {
    key: "getReceiverStats",
    value: function () {
      var _getReceiverStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee15(localId) {
        var _this$_mapRecvLocalId2;
        var _ref5, rtpReceiver;
        return _regenerator().w(function (_context17) {
          while (1) switch (_context17.n) {
            case 0:
              this.assertRecvDirection();
              _ref5 = (_this$_mapRecvLocalId2 = this._mapRecvLocalIdInfo.get(localId)) !== null && _this$_mapRecvLocalId2 !== void 0 ? _this$_mapRecvLocalId2 : {}, rtpReceiver = _ref5.rtpReceiver;
              if (rtpReceiver) {
                _context17.n = 1;
                break;
              }
              throw new Error('associated RTCRtpReceiver not found');
            case 1:
              return _context17.a(2, rtpReceiver.getStats());
          }
        }, _callee15, this);
      }));
      function getReceiverStats(_x15) {
        return _getReceiverStats.apply(this, arguments);
      }
      return getReceiverStats;
    }()
  }, {
    key: "pauseReceiving",
    value: function () {
      var _pauseReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee16(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      localIds) {
        return _regenerator().w(function (_context18) {
          while (1) switch (_context18.n) {
            case 0:
              return _context18.a(2);
          }
        }, _callee16);
      }));
      function pauseReceiving(_x16) {
        return _pauseReceiving.apply(this, arguments);
      }
      return pauseReceiving;
    }()
  }, {
    key: "resumeReceiving",
    value: function () {
      var _resumeReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee17(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      localIds) {
        return _regenerator().w(function (_context19) {
          while (1) switch (_context19.n) {
            case 0:
              return _context19.a(2);
          }
        }, _callee17);
      }));
      function resumeReceiving(_x17) {
        return _resumeReceiving.apply(this, arguments);
      }
      return resumeReceiving;
    }()
  }, {
    key: "receiveDataChannel",
    value: function () {
      var _receiveDataChannel = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee18(_ref6) {
        var sctpStreamParameters, label, protocol, streamId, ordered, maxPacketLifeTime, maxRetransmits, options, dataChannel, offer, answer, _this$_forcedLocalDtl4, localSdpObject;
        return _regenerator().w(function (_context20) {
          while (1) switch (_context20.n) {
            case 0:
              sctpStreamParameters = _ref6.sctpStreamParameters, label = _ref6.label, protocol = _ref6.protocol;
              this.assertRecvDirection();
              streamId = sctpStreamParameters.streamId, ordered = sctpStreamParameters.ordered, maxPacketLifeTime = sctpStreamParameters.maxPacketLifeTime, maxRetransmits = sctpStreamParameters.maxRetransmits;
              options = {
                negotiated: true,
                id: streamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmits: maxRetransmits,
                protocol: protocol
              };
              logger.debug('receiveDataChannel() [options:%o]', options);
              dataChannel = this._pc.createDataChannel(label, options); // If this is the first DataChannel we need to create the SDP offer with
              // m=application section.
              if (this._hasDataChannelMediaSection) {
                _context20.n = 5;
                break;
              }
              this._remoteSdp.receiveSctpAssociation({
                oldDataChannelSpec: true
              });
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context20.n = 1;
              return this._pc.setRemoteDescription(offer);
            case 1:
              _context20.n = 2;
              return this._pc.createAnswer();
            case 2:
              answer = _context20.v;
              if (this._transportReady) {
                _context20.n = 3;
                break;
              }
              localSdpObject = sdpTransform.parse(answer.sdp);
              _context20.n = 3;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl4 = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl4 !== void 0 ? _this$_forcedLocalDtl4 : 'client',
                localSdpObject: localSdpObject
              });
            case 3:
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context20.n = 4;
              return this._pc.setLocalDescription(answer);
            case 4:
              this._hasDataChannelMediaSection = true;
            case 5:
              return _context20.a(2, {
                dataChannel: dataChannel
              });
          }
        }, _callee18, this);
      }));
      function receiveDataChannel(_x18) {
        return _receiveDataChannel.apply(this, arguments);
      }
      return receiveDataChannel;
    }()
  }, {
    key: "setupTransport",
    value: function () {
      var _setupTransport = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee19(_ref7) {
        var _this4 = this;
        var localDtlsRole, localSdpObject, dtlsParameters;
        return _regenerator().w(function (_context21) {
          while (1) switch (_context21.n) {
            case 0:
              localDtlsRole = _ref7.localDtlsRole, localSdpObject = _ref7.localSdpObject;
              if (!localSdpObject) {
                localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
              }
              // Get our local DTLS parameters.
              dtlsParameters = sdpCommonUtils.extractDtlsParameters({
                sdpObject: localSdpObject
              }); // Set our DTLS role.
              dtlsParameters.role = localDtlsRole;
              // Update the remote DTLS role in the SDP.
              this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
              // Need to tell the remote transport about our parameters.
              _context21.n = 1;
              return new Promise(function (resolve, reject) {
                _this4.safeEmit('@connect', {
                  dtlsParameters: dtlsParameters
                }, resolve, reject);
              });
            case 1:
              this._transportReady = true;
            case 2:
              return _context21.a(2);
          }
        }, _callee19, this);
      }));
      function setupTransport(_x19) {
        return _setupTransport.apply(this, arguments);
      }
      return setupTransport;
    }()
  }, {
    key: "assertSendDirection",
    value: function assertSendDirection() {
      if (this._direction !== 'send') {
        throw new Error('method can just be called for handlers with "send" direction');
      }
    }
  }, {
    key: "assertRecvDirection",
    value: function assertRecvDirection() {
      if (this._direction !== 'recv') {
        throw new Error('method can just be called for handlers with "recv" direction');
      }
    }
  }], [{
    key: "createFactory",
    value:
    /**
     * Creates a factory function.
     */
    function createFactory() {
      return function () {
        return new Safari11();
      };
    }
  }]);
}(HandlerInterface_1.HandlerInterface);
exports.Safari11 = Safari11;

},{"../Logger":39,"../ortc":68,"../utils":72,"./HandlerInterface":55,"./sdp/RemoteSdp":63,"./sdp/commonUtils":64,"./sdp/planBUtils":65,"sdp-transform":76}],59:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorValues(e) { if (null != e) { var t = e["function" == typeof Symbol && Symbol.iterator || "@@iterator"], r = 0; if (t) return t.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) return { next: function next() { return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e }; } }; } throw new TypeError(_typeof(e) + " is not iterable"); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o("next", 0), o("throw", 1), o("return", 2); } }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Safari12 = void 0;
var sdpTransform = require("sdp-transform");
var Logger_1 = require("../Logger");
var utils = require("../utils");
var ortc = require("../ortc");
var sdpCommonUtils = require("./sdp/commonUtils");
var sdpUnifiedPlanUtils = require("./sdp/unifiedPlanUtils");
var ortcUtils = require("./ortc/utils");
var errors_1 = require("../errors");
var HandlerInterface_1 = require("./HandlerInterface");
var RemoteSdp_1 = require("./sdp/RemoteSdp");
var scalabilityModes_1 = require("../scalabilityModes");
var logger = new Logger_1.Logger('Safari12');
var NAME = 'Safari12';
var SCTP_NUM_STREAMS = {
  OS: 1024,
  MIS: 1024
};
var Safari12 = /*#__PURE__*/function (_HandlerInterface_1$H) {
  function Safari12() {
    var _this;
    _classCallCheck(this, Safari12);
    _this = _callSuper(this, Safari12);
    // Closed flag.
    _defineProperty(_this, "_closed", false);
    // Handler direction.
    _defineProperty(_this, "_direction", void 0);
    // Remote SDP handler.
    _defineProperty(_this, "_remoteSdp", void 0);
    // Generic sending RTP parameters for audio and video.
    _defineProperty(_this, "_sendingRtpParametersByKind", void 0);
    // Generic sending RTP parameters for audio and video suitable for the SDP
    // remote answer.
    _defineProperty(_this, "_sendingRemoteRtpParametersByKind", void 0);
    // Initial server side DTLS role. If not 'auto', it will force the opposite
    // value in client side.
    _defineProperty(_this, "_forcedLocalDtlsRole", void 0);
    // RTCPeerConnection instance.
    _defineProperty(_this, "_pc", void 0);
    // Map of RTCTransceivers indexed by MID.
    _defineProperty(_this, "_mapMidTransceiver", new Map());
    // Local stream for sending.
    _defineProperty(_this, "_sendStream", new MediaStream());
    // Whether a DataChannel m=application section has been created.
    _defineProperty(_this, "_hasDataChannelMediaSection", false);
    // Sending DataChannel id value counter. Incremented for each new DataChannel.
    _defineProperty(_this, "_nextSendSctpStreamId", 0);
    // Got transport local and remote parameters.
    _defineProperty(_this, "_transportReady", false);
    return _this;
  }
  _inherits(Safari12, _HandlerInterface_1$H);
  return _createClass(Safari12, [{
    key: "name",
    get: function get() {
      return NAME;
    }
  }, {
    key: "close",
    value: function close() {
      logger.debug('close()');
      if (this._closed) {
        return;
      }
      this._closed = true;
      // Close RTCPeerConnection.
      if (this._pc) {
        try {
          this._pc.close();
        } catch (error) {}
      }
      this.emit('@close');
    }
  }, {
    key: "getNativeRtpCapabilities",
    value: function () {
      var _getNativeRtpCapabilities = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {
        var pc, offer, sdpObject, nativeRtpCapabilities, _t;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              logger.debug('getNativeRtpCapabilities()');
              pc = new RTCPeerConnection({
                iceServers: [],
                iceTransportPolicy: 'all',
                bundlePolicy: 'max-bundle',
                rtcpMuxPolicy: 'require'
              });
              _context.p = 1;
              pc.addTransceiver('audio');
              pc.addTransceiver('video');
              _context.n = 2;
              return pc.createOffer();
            case 2:
              offer = _context.v;
              try {
                pc.close();
              } catch (error) {}
              sdpObject = sdpTransform.parse(offer.sdp);
              nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject: sdpObject
              }); // libwebrtc supports NACK for OPUS but doesn't announce it.
              ortcUtils.addNackSupportForOpus(nativeRtpCapabilities);
              return _context.a(2, nativeRtpCapabilities);
            case 3:
              _context.p = 3;
              _t = _context.v;
              try {
                pc.close();
              } catch (error2) {}
              throw _t;
            case 4:
              return _context.a(2);
          }
        }, _callee, null, [[1, 3]]);
      }));
      function getNativeRtpCapabilities() {
        return _getNativeRtpCapabilities.apply(this, arguments);
      }
      return getNativeRtpCapabilities;
    }()
  }, {
    key: "getNativeSctpCapabilities",
    value: function () {
      var _getNativeSctpCapabilities = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2() {
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.n) {
            case 0:
              logger.debug('getNativeSctpCapabilities()');
              return _context2.a(2, {
                numStreams: SCTP_NUM_STREAMS
              });
          }
        }, _callee2);
      }));
      function getNativeSctpCapabilities() {
        return _getNativeSctpCapabilities.apply(this, arguments);
      }
      return getNativeSctpCapabilities;
    }()
  }, {
    key: "run",
    value: function run(_ref) {
      var _this2 = this;
      var direction = _ref.direction,
        iceParameters = _ref.iceParameters,
        iceCandidates = _ref.iceCandidates,
        dtlsParameters = _ref.dtlsParameters,
        sctpParameters = _ref.sctpParameters,
        iceServers = _ref.iceServers,
        iceTransportPolicy = _ref.iceTransportPolicy,
        additionalSettings = _ref.additionalSettings,
        proprietaryConstraints = _ref.proprietaryConstraints,
        extendedRtpCapabilities = _ref.extendedRtpCapabilities;
      this.assertNotClosed();
      logger.debug('run()');
      this._direction = direction;
      this._remoteSdp = new RemoteSdp_1.RemoteSdp({
        iceParameters: iceParameters,
        iceCandidates: iceCandidates,
        dtlsParameters: dtlsParameters,
        sctpParameters: sctpParameters
      });
      this._sendingRtpParametersByKind = {
        audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
        video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
      };
      this._sendingRemoteRtpParametersByKind = {
        audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
        video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)
      };
      if (dtlsParameters.role && dtlsParameters.role !== 'auto') {
        this._forcedLocalDtlsRole = dtlsParameters.role === 'server' ? 'client' : 'server';
      }
      this._pc = new RTCPeerConnection(_objectSpread({
        iceServers: iceServers !== null && iceServers !== void 0 ? iceServers : [],
        iceTransportPolicy: iceTransportPolicy !== null && iceTransportPolicy !== void 0 ? iceTransportPolicy : 'all',
        bundlePolicy: 'max-bundle',
        rtcpMuxPolicy: 'require'
      }, additionalSettings), proprietaryConstraints);
      this._pc.addEventListener('icegatheringstatechange', function () {
        _this2.emit('@icegatheringstatechange', _this2._pc.iceGatheringState);
      });
      this._pc.addEventListener('icecandidateerror', function (event) {
        _this2.emit('@icecandidateerror', event);
      });
      if (this._pc.connectionState) {
        this._pc.addEventListener('connectionstatechange', function () {
          _this2.emit('@connectionstatechange', _this2._pc.connectionState);
        });
      } else {
        this._pc.addEventListener('iceconnectionstatechange', function () {
          logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
          switch (_this2._pc.iceConnectionState) {
            case 'checking':
              {
                _this2.emit('@connectionstatechange', 'connecting');
                break;
              }
            case 'connected':
            case 'completed':
              {
                _this2.emit('@connectionstatechange', 'connected');
                break;
              }
            case 'failed':
              {
                _this2.emit('@connectionstatechange', 'failed');
                break;
              }
            case 'disconnected':
              {
                _this2.emit('@connectionstatechange', 'disconnected');
                break;
              }
            case 'closed':
              {
                _this2.emit('@connectionstatechange', 'closed');
                break;
              }
          }
        });
      }
    }
  }, {
    key: "updateIceServers",
    value: function () {
      var _updateIceServers = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(iceServers) {
        var configuration;
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.n) {
            case 0:
              this.assertNotClosed();
              logger.debug('updateIceServers()');
              configuration = this._pc.getConfiguration();
              configuration.iceServers = iceServers;
              this._pc.setConfiguration(configuration);
            case 1:
              return _context3.a(2);
          }
        }, _callee3, this);
      }));
      function updateIceServers(_x) {
        return _updateIceServers.apply(this, arguments);
      }
      return updateIceServers;
    }()
  }, {
    key: "restartIce",
    value: function () {
      var _restartIce = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(iceParameters) {
        var offer, answer, _offer, _answer;
        return _regenerator().w(function (_context4) {
          while (1) switch (_context4.n) {
            case 0:
              this.assertNotClosed();
              logger.debug('restartIce()');
              // Provide the remote SDP handler with new remote ICE parameters.
              this._remoteSdp.updateIceParameters(iceParameters);
              if (this._transportReady) {
                _context4.n = 1;
                break;
              }
              return _context4.a(2);
            case 1:
              if (!(this._direction === 'send')) {
                _context4.n = 5;
                break;
              }
              _context4.n = 2;
              return this._pc.createOffer({
                iceRestart: true
              });
            case 2:
              offer = _context4.v;
              logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context4.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context4.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              _context4.n = 8;
              break;
            case 5:
              _offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', _offer);
              _context4.n = 6;
              return this._pc.setRemoteDescription(_offer);
            case 6:
              _context4.n = 7;
              return this._pc.createAnswer();
            case 7:
              _answer = _context4.v;
              logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', _answer);
              _context4.n = 8;
              return this._pc.setLocalDescription(_answer);
            case 8:
              return _context4.a(2);
          }
        }, _callee4, this);
      }));
      function restartIce(_x2) {
        return _restartIce.apply(this, arguments);
      }
      return restartIce;
    }()
  }, {
    key: "getTransportStats",
    value: function () {
      var _getTransportStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5() {
        return _regenerator().w(function (_context5) {
          while (1) switch (_context5.n) {
            case 0:
              this.assertNotClosed();
              return _context5.a(2, this._pc.getStats());
          }
        }, _callee5, this);
      }));
      function getTransportStats() {
        return _getTransportStats.apply(this, arguments);
      }
      return getTransportStats;
    }()
  }, {
    key: "send",
    value: function () {
      var _send = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6(_ref2) {
        var track, encodings, codecOptions, codec, onRtpSender, sendingRtpParameters, sendingRemoteRtpParameters, mediaSectionIdx, transceiver, offer, localSdpObject, offerMediaObject, _this$_forcedLocalDtl, layers, localId, idx, _iterator, _step, encoding, answer;
        return _regenerator().w(function (_context6) {
          while (1) switch (_context6.n) {
            case 0:
              track = _ref2.track, encodings = _ref2.encodings, codecOptions = _ref2.codecOptions, codec = _ref2.codec, onRtpSender = _ref2.onRtpSender;
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
              sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]); // This may throw.
              sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
              sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]); // This may throw.
              sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
              mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
              transceiver = this._pc.addTransceiver(track, {
                direction: 'sendonly',
                streams: [this._sendStream]
              });
              if (onRtpSender) {
                onRtpSender(transceiver.sender);
              }
              _context6.n = 1;
              return this._pc.createOffer();
            case 1:
              offer = _context6.v;
              localSdpObject = sdpTransform.parse(offer.sdp); // @ts-expect-error --- sdpTransform.SessionDescription type doesn't
              // define extmapAllowMixed field.
              if (localSdpObject.extmapAllowMixed) {
                this._remoteSdp.setSessionExtmapAllowMixed();
              }
              if (this._transportReady) {
                _context6.n = 2;
                break;
              }
              _context6.n = 2;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl !== void 0 ? _this$_forcedLocalDtl : 'client',
                localSdpObject: localSdpObject
              });
            case 2:
              layers = (0, scalabilityModes_1.parse)((encodings !== null && encodings !== void 0 ? encodings : [{}])[0].scalabilityMode);
              if (encodings && encodings.length > 1) {
                logger.debug('send() | enabling legacy simulcast');
                localSdpObject = sdpTransform.parse(offer.sdp);
                offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
                sdpUnifiedPlanUtils.addLegacySimulcast({
                  offerMediaObject: offerMediaObject,
                  numStreams: encodings.length
                });
                offer = {
                  type: 'offer',
                  sdp: sdpTransform.write(localSdpObject)
                };
              }
              logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context6.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              // We can now get the transceiver.mid.
              localId = transceiver.mid; // Set MID.
              sendingRtpParameters.mid = localId;
              localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
              offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
              // Set RTCP CNAME.
              sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
                offerMediaObject: offerMediaObject
              });
              // Set RTP encodings.
              sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
                offerMediaObject: offerMediaObject
              });
              // Complete encodings with given values.
              if (encodings) {
                for (idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
                  if (encodings[idx]) {
                    Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
                  }
                }
              }
              // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
              // each encoding.
              if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {
                _iterator = _createForOfIteratorHelper(sendingRtpParameters.encodings);
                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    encoding = _step.value;
                    if (encoding.scalabilityMode) {
                      encoding.scalabilityMode = "L1T".concat(layers.temporalLayers);
                    } else {
                      encoding.scalabilityMode = 'L1T3';
                    }
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
              }
              this._remoteSdp.send({
                offerMediaObject: offerMediaObject,
                reuseMid: mediaSectionIdx.reuseMid,
                offerRtpParameters: sendingRtpParameters,
                answerRtpParameters: sendingRemoteRtpParameters,
                codecOptions: codecOptions
              });
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context6.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              // Store in the map.
              this._mapMidTransceiver.set(localId, transceiver);
              return _context6.a(2, {
                localId: localId,
                rtpParameters: sendingRtpParameters,
                rtpSender: transceiver.sender
              });
          }
        }, _callee6, this);
      }));
      function send(_x3) {
        return _send.apply(this, arguments);
      }
      return send;
    }()
  }, {
    key: "stopSending",
    value: function () {
      var _stopSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7(localId) {
        var transceiver, mediaSectionClosed, offer, answer;
        return _regenerator().w(function (_context7) {
          while (1) switch (_context7.n) {
            case 0:
              this.assertSendDirection();
              if (!this._closed) {
                _context7.n = 1;
                break;
              }
              return _context7.a(2);
            case 1:
              logger.debug('stopSending() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context7.n = 2;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 2:
              void transceiver.sender.replaceTrack(null);
              this._pc.removeTrack(transceiver.sender);
              mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
              if (mediaSectionClosed) {
                try {
                  transceiver.stop();
                } catch (error) {}
              }
              _context7.n = 3;
              return this._pc.createOffer();
            case 3:
              offer = _context7.v;
              logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context7.n = 4;
              return this._pc.setLocalDescription(offer);
            case 4:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context7.n = 5;
              return this._pc.setRemoteDescription(answer);
            case 5:
              this._mapMidTransceiver["delete"](localId);
            case 6:
              return _context7.a(2);
          }
        }, _callee7, this);
      }));
      function stopSending(_x4) {
        return _stopSending.apply(this, arguments);
      }
      return stopSending;
    }()
  }, {
    key: "pauseSending",
    value: function () {
      var _pauseSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8(localId) {
        var transceiver, offer, answer;
        return _regenerator().w(function (_context8) {
          while (1) switch (_context8.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('pauseSending() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context8.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              transceiver.direction = 'inactive';
              this._remoteSdp.pauseMediaSection(localId);
              _context8.n = 2;
              return this._pc.createOffer();
            case 2:
              offer = _context8.v;
              logger.debug('pauseSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context8.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('pauseSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context8.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              return _context8.a(2);
          }
        }, _callee8, this);
      }));
      function pauseSending(_x5) {
        return _pauseSending.apply(this, arguments);
      }
      return pauseSending;
    }()
  }, {
    key: "resumeSending",
    value: function () {
      var _resumeSending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee9(localId) {
        var transceiver, offer, answer;
        return _regenerator().w(function (_context9) {
          while (1) switch (_context9.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('resumeSending() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context9.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              transceiver.direction = 'sendonly';
              this._remoteSdp.resumeSendingMediaSection(localId);
              _context9.n = 2;
              return this._pc.createOffer();
            case 2:
              offer = _context9.v;
              logger.debug('resumeSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context9.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('resumeSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context9.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              return _context9.a(2);
          }
        }, _callee9, this);
      }));
      function resumeSending(_x6) {
        return _resumeSending.apply(this, arguments);
      }
      return resumeSending;
    }()
  }, {
    key: "replaceTrack",
    value: function () {
      var _replaceTrack = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee0(localId, track) {
        var transceiver;
        return _regenerator().w(function (_context0) {
          while (1) switch (_context0.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              if (track) {
                logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
              } else {
                logger.debug('replaceTrack() [localId:%s, no track]', localId);
              }
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context0.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              _context0.n = 2;
              return transceiver.sender.replaceTrack(track);
            case 2:
              return _context0.a(2);
          }
        }, _callee0, this);
      }));
      function replaceTrack(_x7, _x8) {
        return _replaceTrack.apply(this, arguments);
      }
      return replaceTrack;
    }()
  }, {
    key: "setMaxSpatialLayer",
    value: function () {
      var _setMaxSpatialLayer = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee1(localId, spatialLayer) {
        var transceiver, parameters, offer, answer;
        return _regenerator().w(function (_context1) {
          while (1) switch (_context1.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context1.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              parameters = transceiver.sender.getParameters();
              parameters.encodings.forEach(function (encoding, idx) {
                if (idx <= spatialLayer) {
                  encoding.active = true;
                } else {
                  encoding.active = false;
                }
              });
              _context1.n = 2;
              return transceiver.sender.setParameters(parameters);
            case 2:
              this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
              _context1.n = 3;
              return this._pc.createOffer();
            case 3:
              offer = _context1.v;
              logger.debug('setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context1.n = 4;
              return this._pc.setLocalDescription(offer);
            case 4:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context1.n = 5;
              return this._pc.setRemoteDescription(answer);
            case 5:
              return _context1.a(2);
          }
        }, _callee1, this);
      }));
      function setMaxSpatialLayer(_x9, _x0) {
        return _setMaxSpatialLayer.apply(this, arguments);
      }
      return setMaxSpatialLayer;
    }()
  }, {
    key: "setRtpEncodingParameters",
    value: function () {
      var _setRtpEncodingParameters = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee10(localId, params) {
        var transceiver, parameters, offer, answer;
        return _regenerator().w(function (_context10) {
          while (1) switch (_context10.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context10.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              parameters = transceiver.sender.getParameters();
              parameters.encodings.forEach(function (encoding, idx) {
                parameters.encodings[idx] = _objectSpread(_objectSpread({}, encoding), params);
              });
              _context10.n = 2;
              return transceiver.sender.setParameters(parameters);
            case 2:
              this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
              _context10.n = 3;
              return this._pc.createOffer();
            case 3:
              offer = _context10.v;
              logger.debug('setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context10.n = 4;
              return this._pc.setLocalDescription(offer);
            case 4:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context10.n = 5;
              return this._pc.setRemoteDescription(answer);
            case 5:
              return _context10.a(2);
          }
        }, _callee10, this);
      }));
      function setRtpEncodingParameters(_x1, _x10) {
        return _setRtpEncodingParameters.apply(this, arguments);
      }
      return setRtpEncodingParameters;
    }()
  }, {
    key: "getSenderStats",
    value: function () {
      var _getSenderStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee11(localId) {
        var transceiver;
        return _regenerator().w(function (_context11) {
          while (1) switch (_context11.n) {
            case 0:
              this.assertNotClosed();
              this.assertSendDirection();
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context11.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              return _context11.a(2, transceiver.sender.getStats());
          }
        }, _callee11, this);
      }));
      function getSenderStats(_x11) {
        return _getSenderStats.apply(this, arguments);
      }
      return getSenderStats;
    }()
  }, {
    key: "sendDataChannel",
    value: function () {
      var _sendDataChannel = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee12(_ref3) {
        var ordered, maxPacketLifeTime, maxRetransmits, label, protocol, options, dataChannel, offer, localSdpObject, offerMediaObject, _this$_forcedLocalDtl2, answer, sctpStreamParameters;
        return _regenerator().w(function (_context12) {
          while (1) switch (_context12.n) {
            case 0:
              ordered = _ref3.ordered, maxPacketLifeTime = _ref3.maxPacketLifeTime, maxRetransmits = _ref3.maxRetransmits, label = _ref3.label, protocol = _ref3.protocol;
              this.assertNotClosed();
              this.assertSendDirection();
              options = {
                negotiated: true,
                id: this._nextSendSctpStreamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmits: maxRetransmits,
                protocol: protocol
              };
              logger.debug('sendDataChannel() [options:%o]', options);
              dataChannel = this._pc.createDataChannel(label, options); // Increase next id.
              this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
              // If this is the first DataChannel we need to create the SDP answer with
              // m=application section.
              if (this._hasDataChannelMediaSection) {
                _context12.n = 5;
                break;
              }
              _context12.n = 1;
              return this._pc.createOffer();
            case 1:
              offer = _context12.v;
              localSdpObject = sdpTransform.parse(offer.sdp);
              offerMediaObject = localSdpObject.media.find(function (m) {
                return m.type === 'application';
              });
              if (this._transportReady) {
                _context12.n = 2;
                break;
              }
              _context12.n = 2;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl2 = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl2 !== void 0 ? _this$_forcedLocalDtl2 : 'client',
                localSdpObject: localSdpObject
              });
            case 2:
              logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context12.n = 3;
              return this._pc.setLocalDescription(offer);
            case 3:
              this._remoteSdp.sendSctpAssociation({
                offerMediaObject: offerMediaObject
              });
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context12.n = 4;
              return this._pc.setRemoteDescription(answer);
            case 4:
              this._hasDataChannelMediaSection = true;
            case 5:
              sctpStreamParameters = {
                streamId: options.id,
                ordered: options.ordered,
                maxPacketLifeTime: options.maxPacketLifeTime,
                maxRetransmits: options.maxRetransmits
              };
              return _context12.a(2, {
                dataChannel: dataChannel,
                sctpStreamParameters: sctpStreamParameters
              });
          }
        }, _callee12, this);
      }));
      function sendDataChannel(_x12) {
        return _sendDataChannel.apply(this, arguments);
      }
      return sendDataChannel;
    }()
  }, {
    key: "receive",
    value: function () {
      var _receive = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee13(optionsList) {
        var _this3 = this;
        var results, mapLocalId, _iterator2, _step2, _rtpParameters$mid, options, trackId, kind, rtpParameters, streamId, localId, offer, _iterator3, _step3, _loop, answer, localSdpObject, _iterator4, _step4, _loop2, _this$_forcedLocalDtl3, _iterator5, _step5, _loop3, _t2, _t3, _t4;
        return _regenerator().w(function (_context16) {
          while (1) switch (_context16.n) {
            case 0:
              this.assertNotClosed();
              this.assertRecvDirection();
              results = [];
              mapLocalId = new Map();
              _iterator2 = _createForOfIteratorHelper(optionsList);
              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  options = _step2.value;
                  trackId = options.trackId, kind = options.kind, rtpParameters = options.rtpParameters, streamId = options.streamId;
                  logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
                  localId = (_rtpParameters$mid = rtpParameters.mid) !== null && _rtpParameters$mid !== void 0 ? _rtpParameters$mid : String(this._mapMidTransceiver.size);
                  mapLocalId.set(trackId, localId);
                  this._remoteSdp.receive({
                    mid: localId,
                    kind: kind,
                    offerRtpParameters: rtpParameters,
                    streamId: streamId !== null && streamId !== void 0 ? streamId : rtpParameters.rtcp.cname,
                    trackId: trackId
                  });
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context16.n = 1;
              return this._pc.setRemoteDescription(offer);
            case 1:
              _iterator3 = _createForOfIteratorHelper(optionsList);
              _context16.p = 2;
              _loop = /*#__PURE__*/_regenerator().m(function _loop() {
                var options, trackId, onRtpReceiver, _localId, transceiver;
                return _regenerator().w(function (_context13) {
                  while (1) switch (_context13.n) {
                    case 0:
                      options = _step3.value;
                      trackId = options.trackId, onRtpReceiver = options.onRtpReceiver;
                      if (!onRtpReceiver) {
                        _context13.n = 2;
                        break;
                      }
                      _localId = mapLocalId.get(trackId);
                      transceiver = _this3._pc.getTransceivers().find(function (t) {
                        return t.mid === _localId;
                      });
                      if (transceiver) {
                        _context13.n = 1;
                        break;
                      }
                      throw new Error('transceiver not found');
                    case 1:
                      onRtpReceiver(transceiver.receiver);
                    case 2:
                      return _context13.a(2);
                  }
                }, _loop);
              });
              _iterator3.s();
            case 3:
              if ((_step3 = _iterator3.n()).done) {
                _context16.n = 5;
                break;
              }
              return _context16.d(_regeneratorValues(_loop()), 4);
            case 4:
              _context16.n = 3;
              break;
            case 5:
              _context16.n = 7;
              break;
            case 6:
              _context16.p = 6;
              _t2 = _context16.v;
              _iterator3.e(_t2);
            case 7:
              _context16.p = 7;
              _iterator3.f();
              return _context16.f(7);
            case 8:
              _context16.n = 9;
              return this._pc.createAnswer();
            case 9:
              answer = _context16.v;
              localSdpObject = sdpTransform.parse(answer.sdp);
              _iterator4 = _createForOfIteratorHelper(optionsList);
              _context16.p = 10;
              _loop2 = /*#__PURE__*/_regenerator().m(function _loop2() {
                var options, trackId, rtpParameters, localId, answerMediaObject;
                return _regenerator().w(function (_context14) {
                  while (1) switch (_context14.n) {
                    case 0:
                      options = _step4.value;
                      trackId = options.trackId, rtpParameters = options.rtpParameters;
                      localId = mapLocalId.get(trackId);
                      answerMediaObject = localSdpObject.media.find(function (m) {
                        return String(m.mid) === localId;
                      }); // May need to modify codec parameters in the answer based on codec
                      // parameters in the offer.
                      sdpCommonUtils.applyCodecParameters({
                        offerRtpParameters: rtpParameters,
                        answerMediaObject: answerMediaObject
                      });
                    case 1:
                      return _context14.a(2);
                  }
                }, _loop2);
              });
              _iterator4.s();
            case 11:
              if ((_step4 = _iterator4.n()).done) {
                _context16.n = 13;
                break;
              }
              return _context16.d(_regeneratorValues(_loop2()), 12);
            case 12:
              _context16.n = 11;
              break;
            case 13:
              _context16.n = 15;
              break;
            case 14:
              _context16.p = 14;
              _t3 = _context16.v;
              _iterator4.e(_t3);
            case 15:
              _context16.p = 15;
              _iterator4.f();
              return _context16.f(15);
            case 16:
              answer = {
                type: 'answer',
                sdp: sdpTransform.write(localSdpObject)
              };
              if (this._transportReady) {
                _context16.n = 17;
                break;
              }
              _context16.n = 17;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl3 = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl3 !== void 0 ? _this$_forcedLocalDtl3 : 'client',
                localSdpObject: localSdpObject
              });
            case 17:
              logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context16.n = 18;
              return this._pc.setLocalDescription(answer);
            case 18:
              _iterator5 = _createForOfIteratorHelper(optionsList);
              _context16.p = 19;
              _loop3 = /*#__PURE__*/_regenerator().m(function _loop3() {
                var options, trackId, localId, transceiver;
                return _regenerator().w(function (_context15) {
                  while (1) switch (_context15.n) {
                    case 0:
                      options = _step5.value;
                      trackId = options.trackId;
                      localId = mapLocalId.get(trackId);
                      transceiver = _this3._pc.getTransceivers().find(function (t) {
                        return t.mid === localId;
                      });
                      if (transceiver) {
                        _context15.n = 1;
                        break;
                      }
                      throw new Error('new RTCRtpTransceiver not found');
                    case 1:
                      // Store in the map.
                      _this3._mapMidTransceiver.set(localId, transceiver);
                      results.push({
                        localId: localId,
                        track: transceiver.receiver.track,
                        rtpReceiver: transceiver.receiver
                      });
                    case 2:
                      return _context15.a(2);
                  }
                }, _loop3);
              });
              _iterator5.s();
            case 20:
              if ((_step5 = _iterator5.n()).done) {
                _context16.n = 22;
                break;
              }
              return _context16.d(_regeneratorValues(_loop3()), 21);
            case 21:
              _context16.n = 20;
              break;
            case 22:
              _context16.n = 24;
              break;
            case 23:
              _context16.p = 23;
              _t4 = _context16.v;
              _iterator5.e(_t4);
            case 24:
              _context16.p = 24;
              _iterator5.f();
              return _context16.f(24);
            case 25:
              return _context16.a(2, results);
          }
        }, _callee13, this, [[19, 23, 24, 25], [10, 14, 15, 16], [2, 6, 7, 8]]);
      }));
      function receive(_x13) {
        return _receive.apply(this, arguments);
      }
      return receive;
    }()
  }, {
    key: "stopReceiving",
    value: function () {
      var _stopReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee14(localIds) {
        var _iterator6, _step6, localId, transceiver, offer, answer, _iterator7, _step7, _localId2, _t5;
        return _regenerator().w(function (_context17) {
          while (1) switch (_context17.n) {
            case 0:
              this.assertRecvDirection();
              if (!this._closed) {
                _context17.n = 1;
                break;
              }
              return _context17.a(2);
            case 1:
              _iterator6 = _createForOfIteratorHelper(localIds);
              _context17.p = 2;
              _iterator6.s();
            case 3:
              if ((_step6 = _iterator6.n()).done) {
                _context17.n = 6;
                break;
              }
              localId = _step6.value;
              logger.debug('stopReceiving() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context17.n = 4;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 4:
              this._remoteSdp.closeMediaSection(transceiver.mid);
            case 5:
              _context17.n = 3;
              break;
            case 6:
              _context17.n = 8;
              break;
            case 7:
              _context17.p = 7;
              _t5 = _context17.v;
              _iterator6.e(_t5);
            case 8:
              _context17.p = 8;
              _iterator6.f();
              return _context17.f(8);
            case 9:
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context17.n = 10;
              return this._pc.setRemoteDescription(offer);
            case 10:
              _context17.n = 11;
              return this._pc.createAnswer();
            case 11:
              answer = _context17.v;
              logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context17.n = 12;
              return this._pc.setLocalDescription(answer);
            case 12:
              _iterator7 = _createForOfIteratorHelper(localIds);
              try {
                for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                  _localId2 = _step7.value;
                  this._mapMidTransceiver["delete"](_localId2);
                }
              } catch (err) {
                _iterator7.e(err);
              } finally {
                _iterator7.f();
              }
            case 13:
              return _context17.a(2);
          }
        }, _callee14, this, [[2, 7, 8, 9]]);
      }));
      function stopReceiving(_x14) {
        return _stopReceiving.apply(this, arguments);
      }
      return stopReceiving;
    }()
  }, {
    key: "pauseReceiving",
    value: function () {
      var _pauseReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee15(localIds) {
        var _iterator8, _step8, localId, transceiver, offer, answer, _t6;
        return _regenerator().w(function (_context18) {
          while (1) switch (_context18.n) {
            case 0:
              this.assertNotClosed();
              this.assertRecvDirection();
              _iterator8 = _createForOfIteratorHelper(localIds);
              _context18.p = 1;
              _iterator8.s();
            case 2:
              if ((_step8 = _iterator8.n()).done) {
                _context18.n = 5;
                break;
              }
              localId = _step8.value;
              logger.debug('pauseReceiving() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context18.n = 3;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 3:
              transceiver.direction = 'inactive';
              this._remoteSdp.pauseMediaSection(localId);
            case 4:
              _context18.n = 2;
              break;
            case 5:
              _context18.n = 7;
              break;
            case 6:
              _context18.p = 6;
              _t6 = _context18.v;
              _iterator8.e(_t6);
            case 7:
              _context18.p = 7;
              _iterator8.f();
              return _context18.f(7);
            case 8:
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context18.n = 9;
              return this._pc.setRemoteDescription(offer);
            case 9:
              _context18.n = 10;
              return this._pc.createAnswer();
            case 10:
              answer = _context18.v;
              logger.debug('pauseReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context18.n = 11;
              return this._pc.setLocalDescription(answer);
            case 11:
              return _context18.a(2);
          }
        }, _callee15, this, [[1, 6, 7, 8]]);
      }));
      function pauseReceiving(_x15) {
        return _pauseReceiving.apply(this, arguments);
      }
      return pauseReceiving;
    }()
  }, {
    key: "resumeReceiving",
    value: function () {
      var _resumeReceiving = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee16(localIds) {
        var _iterator9, _step9, localId, transceiver, offer, answer, _t7;
        return _regenerator().w(function (_context19) {
          while (1) switch (_context19.n) {
            case 0:
              this.assertNotClosed();
              this.assertRecvDirection();
              _iterator9 = _createForOfIteratorHelper(localIds);
              _context19.p = 1;
              _iterator9.s();
            case 2:
              if ((_step9 = _iterator9.n()).done) {
                _context19.n = 5;
                break;
              }
              localId = _step9.value;
              logger.debug('resumeReceiving() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context19.n = 3;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 3:
              transceiver.direction = 'recvonly';
              this._remoteSdp.resumeReceivingMediaSection(localId);
            case 4:
              _context19.n = 2;
              break;
            case 5:
              _context19.n = 7;
              break;
            case 6:
              _context19.p = 6;
              _t7 = _context19.v;
              _iterator9.e(_t7);
            case 7:
              _context19.p = 7;
              _iterator9.f();
              return _context19.f(7);
            case 8:
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context19.n = 9;
              return this._pc.setRemoteDescription(offer);
            case 9:
              _context19.n = 10;
              return this._pc.createAnswer();
            case 10:
              answer = _context19.v;
              logger.debug('resumeReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context19.n = 11;
              return this._pc.setLocalDescription(answer);
            case 11:
              return _context19.a(2);
          }
        }, _callee16, this, [[1, 6, 7, 8]]);
      }));
      function resumeReceiving(_x16) {
        return _resumeReceiving.apply(this, arguments);
      }
      return resumeReceiving;
    }()
  }, {
    key: "getReceiverStats",
    value: function () {
      var _getReceiverStats = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee17(localId) {
        var transceiver;
        return _regenerator().w(function (_context20) {
          while (1) switch (_context20.n) {
            case 0:
              this.assertNotClosed();
              this.assertRecvDirection();
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context20.n = 1;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 1:
              return _context20.a(2, transceiver.receiver.getStats());
          }
        }, _callee17, this);
      }));
      function getReceiverStats(_x17) {
        return _getReceiverStats.apply(this, arguments);
      }
      return getReceiverStats;
    }()
  }, {
    key: "receiveDataChannel",
    value: function () {
      var _receiveDataChannel = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee18(_ref4) {
        var sctpStreamParameters, label, protocol, streamId, ordered, maxPacketLifeTime, maxRetransmits, options, dataChannel, offer, answer, _this$_forcedLocalDtl4, localSdpObject;
        return _regenerator().w(function (_context21) {
          while (1) switch (_context21.n) {
            case 0:
              sctpStreamParameters = _ref4.sctpStreamParameters, label = _ref4.label, protocol = _ref4.protocol;
              this.assertNotClosed();
              this.assertRecvDirection();
              streamId = sctpStreamParameters.streamId, ordered = sctpStreamParameters.ordered, maxPacketLifeTime = sctpStreamParameters.maxPacketLifeTime, maxRetransmits = sctpStreamParameters.maxRetransmits;
              options = {
                negotiated: true,
                id: streamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmits: maxRetransmits,
                protocol: protocol
              };
              logger.debug('receiveDataChannel() [options:%o]', options);
              dataChannel = this._pc.createDataChannel(label, options); // If this is the first DataChannel we need to create the SDP offer with
              // m=application section.
              if (this._hasDataChannelMediaSection) {
                _context21.n = 5;
                break;
              }
              this._remoteSdp.receiveSctpAssociation();
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context21.n = 1;
              return this._pc.setRemoteDescription(offer);
            case 1:
              _context21.n = 2;
              return this._pc.createAnswer();
            case 2:
              answer = _context21.v;
              if (this._transportReady) {
                _context21.n = 3;
                break;
              }
              localSdpObject = sdpTransform.parse(answer.sdp);
              _context21.n = 3;
              return this.setupTransport({
                localDtlsRole: (_this$_forcedLocalDtl4 = this._forcedLocalDtlsRole) !== null && _this$_forcedLocalDtl4 !== void 0 ? _this$_forcedLocalDtl4 : 'client',
                localSdpObject: localSdpObject
              });
            case 3:
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context21.n = 4;
              return this._pc.setLocalDescription(answer);
            case 4:
              this._hasDataChannelMediaSection = true;
            case 5:
              return _context21.a(2, {
                dataChannel: dataChannel
              });
          }
        }, _callee18, this);
      }));
      function receiveDataChannel(_x18) {
        return _receiveDataChannel.apply(this, arguments);
      }
      return receiveDataChannel;
    }()
  }, {
    key: "setupTransport",
    value: function () {
      var _setupTransport = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee19(_ref5) {
        var _this4 = this;
        var localDtlsRole, localSdpObject, dtlsParameters;
        return _regenerator().w(function (_context22) {
          while (1) switch (_context22.n) {
            case 0:
              localDtlsRole = _ref5.localDtlsRole, localSdpObject = _ref5.localSdpObject;
              if (!localSdpObject) {
                localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
              }
              // Get our local DTLS parameters.
              dtlsParameters = sdpCommonUtils.extractDtlsParameters({
                sdpObject: localSdpObject
              }); // Set our DTLS role.
              dtlsParameters.role = localDtlsRole;
              // Update the remote DTLS role in the SDP.
              this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
              // Need to tell the remote transport about our parameters.
              _context22.n = 1;
              return new Promise(function (resolve, reject) {
                _this4.safeEmit('@connect', {
                  dtlsParameters: dtlsParameters
                }, resolve, reject);
              });
            case 1:
              this._transportReady = true;
            case 2:
              return _context22.a(2);
          }
        }, _callee19, this);
      }));
      function setupTransport(_x19) {
        return _setupTransport.apply(this, arguments);
      }
      return setupTransport;
    }()
  }, {
    key: "assertNotClosed",
    value: function assertNotClosed() {
      if (this._closed) {
        throw new errors_1.InvalidStateError('method called in a closed handler');
      }
    }
  }, {
    key: "assertSendDirection",
    value: function assertSendDirection() {
      if (this._direction !== 'send') {
        throw new Error('method can just be called for handlers with "send" direction');
      }
    }
  }, {
    key: "assertRecvDirection",
    value: function assertRecvDirection() {
      if (this._direction !== 'recv') {
        throw new Error('method can just be called for handlers with "recv" direction');
      }
    }
  }], [{
    key: "createFactory",
    value:
    /**
     * Creates a factory function.
     */
    function createFactory() {
      return function () {
        return new Safari12();
      };
    }
  }]);
}(HandlerInterface_1.HandlerInterface);
exports.Safari12 = Safari12;

},{"../Logger":39,"../errors":45,"../ortc":68,"../scalabilityModes":69,"../utils":72,"./HandlerInterface":55,"./ortc/utils":61,"./sdp/RemoteSdp":63,"./sdp/commonUtils":64,"./sdp/unifiedPlanUtils":66,"sdp-transform":76}],60:[function(require,module,exports){
"use strict";

function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getCapabilities = getCapabilities;
exports.mangleRtpParameters = mangleRtpParameters;
var utils = require("../../utils");
/**
 * Normalize ORTC based Edge's RTCRtpReceiver.getCapabilities() to produce a full
 * compliant ORTC RTCRtpCapabilities.
 */
function getCapabilities() {
  var _caps$codecs;
  var nativeCaps = RTCRtpReceiver.getCapabilities();
  var caps = utils.clone(nativeCaps);
  var _iterator = _createForOfIteratorHelper((_caps$codecs = caps.codecs) !== null && _caps$codecs !== void 0 ? _caps$codecs : []),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _codec$mimeType, _codec$rtcpFeedback;
      var codec = _step.value;
      // Rename numChannels to channels.
      // @ts-expect-error --- On purpose.
      codec.channels = codec.numChannels;
      // @ts-expect-error --- On purpose.
      delete codec.numChannels;
      // Add mimeType.
      // @ts-expect-error --- On purpose (due to codec.name).
      codec.mimeType = (_codec$mimeType = codec.mimeType) !== null && _codec$mimeType !== void 0 ? _codec$mimeType : "".concat(codec.kind, "/").concat(codec.name);
      // NOTE: Edge sets some numeric parameters as string rather than number. Fix them.
      if (codec.parameters) {
        var parameters = codec.parameters;
        if (parameters.apt) {
          parameters.apt = Number(parameters.apt);
        }
        if (parameters['packetization-mode']) {
          parameters['packetization-mode'] = Number(parameters['packetization-mode']);
        }
      }
      // Delete emty parameter String in rtcpFeedback.
      var _iterator2 = _createForOfIteratorHelper((_codec$rtcpFeedback = codec.rtcpFeedback) !== null && _codec$rtcpFeedback !== void 0 ? _codec$rtcpFeedback : []),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var feedback = _step2.value;
          if (!feedback.parameter) {
            feedback.parameter = '';
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return caps;
}
/**
 * Generate RTCRtpParameters as ORTC based Edge likes.
 */
function mangleRtpParameters(rtpParameters) {
  var params = utils.clone(rtpParameters);
  // Rename mid to muxId.
  if (params.mid) {
    // @ts-expect-error --- On purpose (due to muxId).
    params.muxId = params.mid;
    delete params.mid;
  }
  var _iterator3 = _createForOfIteratorHelper(params.codecs),
    _step3;
  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var codec = _step3.value;
      // Rename channels to numChannels.
      if (codec.channels) {
        // @ts-expect-error --- On purpose.
        codec.numChannels = codec.channels;
        delete codec.channels;
      }
      // Add codec.name (requried by Edge).
      // @ts-expect-error --- On purpose (due to name).
      if (codec.mimeType && !codec.name) {
        // @ts-expect-error --- On purpose (due to name).
        codec.name = codec.mimeType.split('/')[1];
      }
      // Remove mimeType.
      // @ts-expect-error --- Removing mandatory field.
      delete codec.mimeType;
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
  return params;
}

},{"../../utils":72}],61:[function(require,module,exports){
"use strict";

function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addNackSupportForOpus = addNackSupportForOpus;
/**
 * This function adds RTCP NACK support for OPUS codec in given capabilities.
 */
function addNackSupportForOpus(rtpCapabilities) {
  var _rtpCapabilities$code;
  var _iterator = _createForOfIteratorHelper((_rtpCapabilities$code = rtpCapabilities.codecs) !== null && _rtpCapabilities$code !== void 0 ? _rtpCapabilities$code : []),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _codec$rtcpFeedback;
      var codec = _step.value;
      if ((codec.mimeType.toLowerCase() === 'audio/opus' || codec.mimeType.toLowerCase() === 'audio/multiopus') && !((_codec$rtcpFeedback = codec.rtcpFeedback) !== null && _codec$rtcpFeedback !== void 0 && _codec$rtcpFeedback.some(function (fb) {
        return fb.type === 'nack' && !fb.parameter;
      }))) {
        if (!codec.rtcpFeedback) {
          codec.rtcpFeedback = [];
        }
        codec.rtcpFeedback.push({
          type: 'nack'
        });
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}

},{}],62:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OfferMediaSection = exports.AnswerMediaSection = exports.MediaSection = void 0;
var sdpTransform = require("sdp-transform");
var utils = require("../../utils");
var MediaSection = /*#__PURE__*/function () {
  function MediaSection(_ref) {
    var iceParameters = _ref.iceParameters,
      iceCandidates = _ref.iceCandidates,
      dtlsParameters = _ref.dtlsParameters,
      _ref$planB = _ref.planB,
      planB = _ref$planB === void 0 ? false : _ref$planB;
    _classCallCheck(this, MediaSection);
    // SDP media object.
    _defineProperty(this, "_mediaObject", void 0);
    // Whether this is Plan-B SDP.
    _defineProperty(this, "_planB", void 0);
    this._mediaObject = {};
    this._planB = planB;
    if (iceParameters) {
      this.setIceParameters(iceParameters);
    }
    if (iceCandidates) {
      this._mediaObject.candidates = [];
      var _iterator = _createForOfIteratorHelper(iceCandidates),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _candidate$address;
          var candidate = _step.value;
          var candidateObject = {};
          // mediasoup does mandates rtcp-mux so candidates component is always
          // RTP (1).
          candidateObject.component = 1;
          candidateObject.foundation = candidate.foundation;
          // Be ready for new candidate.address field in mediasoup server side
          // field and keep backward compatibility with deprecated candidate.ip.
          candidateObject.ip = (_candidate$address = candidate.address) !== null && _candidate$address !== void 0 ? _candidate$address : candidate.ip;
          candidateObject.port = candidate.port;
          candidateObject.priority = candidate.priority;
          candidateObject.transport = candidate.protocol;
          candidateObject.type = candidate.type;
          if (candidate.tcpType) {
            candidateObject.tcptype = candidate.tcpType;
          }
          this._mediaObject.candidates.push(candidateObject);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      this._mediaObject.endOfCandidates = 'end-of-candidates';
      this._mediaObject.iceOptions = 'renomination';
    }
    if (dtlsParameters) {
      this.setDtlsRole(dtlsParameters.role);
    }
  }
  return _createClass(MediaSection, [{
    key: "mid",
    get: function get() {
      return String(this._mediaObject.mid);
    }
  }, {
    key: "closed",
    get: function get() {
      return this._mediaObject.port === 0;
    }
  }, {
    key: "getObject",
    value: function getObject() {
      return this._mediaObject;
    }
  }, {
    key: "setIceParameters",
    value: function setIceParameters(iceParameters) {
      this._mediaObject.iceUfrag = iceParameters.usernameFragment;
      this._mediaObject.icePwd = iceParameters.password;
    }
  }, {
    key: "pause",
    value: function pause() {
      this._mediaObject.direction = 'inactive';
    }
  }, {
    key: "disable",
    value: function disable() {
      this.pause();
      delete this._mediaObject.ext;
      delete this._mediaObject.ssrcs;
      delete this._mediaObject.ssrcGroups;
      delete this._mediaObject.simulcast;
      delete this._mediaObject.simulcast_03;
      delete this._mediaObject.rids;
      delete this._mediaObject.extmapAllowMixed;
    }
  }, {
    key: "close",
    value: function close() {
      this.disable();
      this._mediaObject.port = 0;
    }
  }]);
}();
exports.MediaSection = MediaSection;
var AnswerMediaSection = /*#__PURE__*/function (_MediaSection2) {
  function AnswerMediaSection(_ref2) {
    var _this;
    var iceParameters = _ref2.iceParameters,
      iceCandidates = _ref2.iceCandidates,
      dtlsParameters = _ref2.dtlsParameters,
      sctpParameters = _ref2.sctpParameters,
      plainRtpParameters = _ref2.plainRtpParameters,
      _ref2$planB = _ref2.planB,
      planB = _ref2$planB === void 0 ? false : _ref2$planB,
      offerMediaObject = _ref2.offerMediaObject,
      offerRtpParameters = _ref2.offerRtpParameters,
      answerRtpParameters = _ref2.answerRtpParameters,
      codecOptions = _ref2.codecOptions;
    _classCallCheck(this, AnswerMediaSection);
    _this = _callSuper(this, AnswerMediaSection, [{
      iceParameters: iceParameters,
      iceCandidates: iceCandidates,
      dtlsParameters: dtlsParameters,
      planB: planB
    }]);
    _this._mediaObject.mid = String(offerMediaObject.mid);
    _this._mediaObject.type = offerMediaObject.type;
    _this._mediaObject.protocol = offerMediaObject.protocol;
    if (!plainRtpParameters) {
      _this._mediaObject.connection = {
        ip: '127.0.0.1',
        version: 4
      };
      _this._mediaObject.port = 7;
    } else {
      _this._mediaObject.connection = {
        ip: plainRtpParameters.ip,
        version: plainRtpParameters.ipVersion
      };
      _this._mediaObject.port = plainRtpParameters.port;
    }
    switch (offerMediaObject.type) {
      case 'audio':
      case 'video':
        {
          _this._mediaObject.direction = 'recvonly';
          _this._mediaObject.rtp = [];
          _this._mediaObject.rtcpFb = [];
          _this._mediaObject.fmtp = [];
          var _iterator2 = _createForOfIteratorHelper(answerRtpParameters.codecs),
            _step2;
          try {
            var _loop = function _loop() {
              var _utils$clone, _utils$clone2;
              var codec = _step2.value;
              var rtp = {
                payload: codec.payloadType,
                codec: getCodecName(codec),
                rate: codec.clockRate
              };
              if (codec.channels > 1) {
                rtp.encoding = codec.channels;
              }
              _this._mediaObject.rtp.push(rtp);
              var codecParameters = (_utils$clone = utils.clone(codec.parameters)) !== null && _utils$clone !== void 0 ? _utils$clone : {};
              var codecRtcpFeedback = (_utils$clone2 = utils.clone(codec.rtcpFeedback)) !== null && _utils$clone2 !== void 0 ? _utils$clone2 : [];
              if (codecOptions) {
                var opusStereo = codecOptions.opusStereo,
                  opusFec = codecOptions.opusFec,
                  opusDtx = codecOptions.opusDtx,
                  opusMaxPlaybackRate = codecOptions.opusMaxPlaybackRate,
                  opusMaxAverageBitrate = codecOptions.opusMaxAverageBitrate,
                  opusPtime = codecOptions.opusPtime,
                  opusNack = codecOptions.opusNack,
                  videoGoogleStartBitrate = codecOptions.videoGoogleStartBitrate,
                  videoGoogleMaxBitrate = codecOptions.videoGoogleMaxBitrate,
                  videoGoogleMinBitrate = codecOptions.videoGoogleMinBitrate;
                var offerCodec = offerRtpParameters.codecs.find(function (c) {
                  return c.payloadType === codec.payloadType;
                });
                switch (codec.mimeType.toLowerCase()) {
                  case 'audio/opus':
                  case 'audio/multiopus':
                    {
                      if (opusStereo !== undefined) {
                        offerCodec.parameters['sprop-stereo'] = opusStereo ? 1 : 0;
                        codecParameters.stereo = opusStereo ? 1 : 0;
                      }
                      if (opusFec !== undefined) {
                        offerCodec.parameters.useinbandfec = opusFec ? 1 : 0;
                        codecParameters.useinbandfec = opusFec ? 1 : 0;
                      }
                      if (opusDtx !== undefined) {
                        offerCodec.parameters.usedtx = opusDtx ? 1 : 0;
                        codecParameters.usedtx = opusDtx ? 1 : 0;
                      }
                      if (opusMaxPlaybackRate !== undefined) {
                        codecParameters.maxplaybackrate = opusMaxPlaybackRate;
                      }
                      if (opusMaxAverageBitrate !== undefined) {
                        codecParameters.maxaveragebitrate = opusMaxAverageBitrate;
                      }
                      if (opusPtime !== undefined) {
                        offerCodec.parameters.ptime = opusPtime;
                        codecParameters.ptime = opusPtime;
                      }
                      // If opusNack is not set, we must remove NACK support for OPUS.
                      // Otherwise it would be enabled for those handlers that artificially
                      // announce it in their RTP capabilities.
                      if (!opusNack) {
                        offerCodec.rtcpFeedback = offerCodec.rtcpFeedback.filter(function (fb) {
                          return fb.type !== 'nack' || fb.parameter;
                        });
                        codecRtcpFeedback = codecRtcpFeedback.filter(function (fb) {
                          return fb.type !== 'nack' || fb.parameter;
                        });
                      }
                      break;
                    }
                  case 'video/vp8':
                  case 'video/vp9':
                  case 'video/h264':
                  case 'video/h265':
                  case 'video/av1':
                    {
                      if (videoGoogleStartBitrate !== undefined) {
                        codecParameters['x-google-start-bitrate'] = videoGoogleStartBitrate;
                      }
                      if (videoGoogleMaxBitrate !== undefined) {
                        codecParameters['x-google-max-bitrate'] = videoGoogleMaxBitrate;
                      }
                      if (videoGoogleMinBitrate !== undefined) {
                        codecParameters['x-google-min-bitrate'] = videoGoogleMinBitrate;
                      }
                      break;
                    }
                }
              }
              var fmtp = {
                payload: codec.payloadType,
                config: ''
              };
              for (var _i = 0, _Object$keys = Object.keys(codecParameters); _i < _Object$keys.length; _i++) {
                var key = _Object$keys[_i];
                if (fmtp.config) {
                  fmtp.config += ';';
                }
                fmtp.config += "".concat(key, "=").concat(codecParameters[key]);
              }
              if (fmtp.config) {
                _this._mediaObject.fmtp.push(fmtp);
              }
              var _iterator6 = _createForOfIteratorHelper(codecRtcpFeedback),
                _step6;
              try {
                for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                  var fb = _step6.value;
                  _this._mediaObject.rtcpFb.push({
                    payload: codec.payloadType,
                    type: fb.type,
                    subtype: fb.parameter
                  });
                }
              } catch (err) {
                _iterator6.e(err);
              } finally {
                _iterator6.f();
              }
            };
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              _loop();
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
          _this._mediaObject.payloads = answerRtpParameters.codecs.map(function (codec) {
            return codec.payloadType;
          }).join(' ');
          _this._mediaObject.ext = [];
          var _iterator3 = _createForOfIteratorHelper(answerRtpParameters.headerExtensions),
            _step3;
          try {
            var _loop2 = function _loop2() {
              var _offerMediaObject$ext;
              var ext = _step3.value;
              // Don't add a header extension if not present in the offer.
              var found = ((_offerMediaObject$ext = offerMediaObject.ext) !== null && _offerMediaObject$ext !== void 0 ? _offerMediaObject$ext : []).some(function (localExt) {
                return localExt.uri === ext.uri;
              });
              if (!found) {
                return 1; // continue
              }
              _this._mediaObject.ext.push({
                uri: ext.uri,
                value: ext.id
              });
            };
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              if (_loop2()) continue;
            }
            // Allow both 1 byte and 2 bytes length header extensions since
            // mediasoup can receive both at any time.
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
          if (offerMediaObject.extmapAllowMixed === 'extmap-allow-mixed') {
            _this._mediaObject.extmapAllowMixed = 'extmap-allow-mixed';
          }
          // Simulcast.
          if (offerMediaObject.simulcast) {
            var _offerMediaObject$rid;
            _this._mediaObject.simulcast = {
              dir1: 'recv',
              list1: offerMediaObject.simulcast.list1
            };
            _this._mediaObject.rids = [];
            var _iterator4 = _createForOfIteratorHelper((_offerMediaObject$rid = offerMediaObject.rids) !== null && _offerMediaObject$rid !== void 0 ? _offerMediaObject$rid : []),
              _step4;
            try {
              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                var rid = _step4.value;
                if (rid.direction !== 'send') {
                  continue;
                }
                _this._mediaObject.rids.push({
                  id: rid.id,
                  direction: 'recv'
                });
              }
            } catch (err) {
              _iterator4.e(err);
            } finally {
              _iterator4.f();
            }
          }
          // Simulcast (draft version 03).
          else if (offerMediaObject.simulcast_03) {
            var _offerMediaObject$rid2;
            _this._mediaObject.simulcast_03 = {
              value: offerMediaObject.simulcast_03.value.replace(/send/g, 'recv')
            };
            _this._mediaObject.rids = [];
            var _iterator5 = _createForOfIteratorHelper((_offerMediaObject$rid2 = offerMediaObject.rids) !== null && _offerMediaObject$rid2 !== void 0 ? _offerMediaObject$rid2 : []),
              _step5;
            try {
              for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                var _rid = _step5.value;
                if (_rid.direction !== 'send') {
                  continue;
                }
                _this._mediaObject.rids.push({
                  id: _rid.id,
                  direction: 'recv'
                });
              }
            } catch (err) {
              _iterator5.e(err);
            } finally {
              _iterator5.f();
            }
          }
          _this._mediaObject.rtcpMux = 'rtcp-mux';
          _this._mediaObject.rtcpRsize = 'rtcp-rsize';
          if (_this._planB && _this._mediaObject.type === 'video') {
            _this._mediaObject.xGoogleFlag = 'conference';
          }
          break;
        }
      case 'application':
        {
          // New spec.
          if (typeof offerMediaObject.sctpPort === 'number') {
            _this._mediaObject.payloads = 'webrtc-datachannel';
            _this._mediaObject.sctpPort = sctpParameters.port;
            _this._mediaObject.maxMessageSize = sctpParameters.maxMessageSize;
          }
          // Old spec.
          else if (offerMediaObject.sctpmap) {
            _this._mediaObject.payloads = sctpParameters.port;
            _this._mediaObject.sctpmap = {
              app: 'webrtc-datachannel',
              sctpmapNumber: sctpParameters.port,
              maxMessageSize: sctpParameters.maxMessageSize
            };
          }
          break;
        }
    }
    return _this;
  }
  _inherits(AnswerMediaSection, _MediaSection2);
  return _createClass(AnswerMediaSection, [{
    key: "setDtlsRole",
    value: function setDtlsRole(role) {
      switch (role) {
        case 'client':
          {
            this._mediaObject.setup = 'active';
            break;
          }
        case 'server':
          {
            this._mediaObject.setup = 'passive';
            break;
          }
        case 'auto':
          {
            this._mediaObject.setup = 'actpass';
            break;
          }
      }
    }
  }, {
    key: "resume",
    value: function resume() {
      this._mediaObject.direction = 'recvonly';
    }
  }, {
    key: "muxSimulcastStreams",
    value: function muxSimulcastStreams(encodings) {
      var _this$_mediaObject$si;
      if (!((_this$_mediaObject$si = this._mediaObject.simulcast) !== null && _this$_mediaObject$si !== void 0 && _this$_mediaObject$si.list1)) {
        return;
      }
      var layers = {};
      var _iterator7 = _createForOfIteratorHelper(encodings),
        _step7;
      try {
        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
          var encoding = _step7.value;
          if (encoding.rid) {
            layers[encoding.rid] = encoding;
          }
        }
      } catch (err) {
        _iterator7.e(err);
      } finally {
        _iterator7.f();
      }
      var raw = this._mediaObject.simulcast.list1;
      var simulcastStreams = sdpTransform.parseSimulcastStreamList(raw);
      var _iterator8 = _createForOfIteratorHelper(simulcastStreams),
        _step8;
      try {
        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
          var simulcastStream = _step8.value;
          var _iterator9 = _createForOfIteratorHelper(simulcastStream),
            _step9;
          try {
            for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
              var _layers$simulcastForm;
              var simulcastFormat = _step9.value;
              simulcastFormat.paused = !((_layers$simulcastForm = layers[simulcastFormat.scid]) !== null && _layers$simulcastForm !== void 0 && _layers$simulcastForm.active);
            }
          } catch (err) {
            _iterator9.e(err);
          } finally {
            _iterator9.f();
          }
        }
      } catch (err) {
        _iterator8.e(err);
      } finally {
        _iterator8.f();
      }
      this._mediaObject.simulcast.list1 = simulcastStreams.map(function (simulcastFormats) {
        return simulcastFormats.map(function (f) {
          return "".concat(f.paused ? '~' : '').concat(f.scid);
        }).join(',');
      }).join(';');
    }
  }]);
}(MediaSection);
exports.AnswerMediaSection = AnswerMediaSection;
var OfferMediaSection = /*#__PURE__*/function (_MediaSection3) {
  function OfferMediaSection(_ref3) {
    var _this2;
    var iceParameters = _ref3.iceParameters,
      iceCandidates = _ref3.iceCandidates,
      dtlsParameters = _ref3.dtlsParameters,
      sctpParameters = _ref3.sctpParameters,
      plainRtpParameters = _ref3.plainRtpParameters,
      _ref3$planB = _ref3.planB,
      planB = _ref3$planB === void 0 ? false : _ref3$planB,
      mid = _ref3.mid,
      kind = _ref3.kind,
      offerRtpParameters = _ref3.offerRtpParameters,
      streamId = _ref3.streamId,
      trackId = _ref3.trackId,
      _ref3$oldDataChannelS = _ref3.oldDataChannelSpec,
      oldDataChannelSpec = _ref3$oldDataChannelS === void 0 ? false : _ref3$oldDataChannelS;
    _classCallCheck(this, OfferMediaSection);
    _this2 = _callSuper(this, OfferMediaSection, [{
      iceParameters: iceParameters,
      iceCandidates: iceCandidates,
      dtlsParameters: dtlsParameters,
      planB: planB
    }]);
    _this2._mediaObject.mid = String(mid);
    _this2._mediaObject.type = kind;
    if (!plainRtpParameters) {
      _this2._mediaObject.connection = {
        ip: '127.0.0.1',
        version: 4
      };
      if (!sctpParameters) {
        _this2._mediaObject.protocol = 'UDP/TLS/RTP/SAVPF';
      } else {
        _this2._mediaObject.protocol = 'UDP/DTLS/SCTP';
      }
      _this2._mediaObject.port = 7;
    } else {
      _this2._mediaObject.connection = {
        ip: plainRtpParameters.ip,
        version: plainRtpParameters.ipVersion
      };
      _this2._mediaObject.protocol = 'RTP/AVP';
      _this2._mediaObject.port = plainRtpParameters.port;
    }
    // Allow both 1 byte and 2 bytes length header extensions since
    // mediasoup can send both at any time.
    _this2._mediaObject.extmapAllowMixed = 'extmap-allow-mixed';
    switch (kind) {
      case 'audio':
      case 'video':
        {
          var _encoding$rtx;
          _this2._mediaObject.direction = 'sendonly';
          _this2._mediaObject.rtp = [];
          _this2._mediaObject.rtcpFb = [];
          _this2._mediaObject.fmtp = [];
          if (!_this2._planB) {
            _this2._mediaObject.msid = "".concat(streamId !== null && streamId !== void 0 ? streamId : '-', " ").concat(trackId);
          }
          var _iterator0 = _createForOfIteratorHelper(offerRtpParameters.codecs),
            _step0;
          try {
            for (_iterator0.s(); !(_step0 = _iterator0.n()).done;) {
              var codec = _step0.value;
              var rtp = {
                payload: codec.payloadType,
                codec: getCodecName(codec),
                rate: codec.clockRate
              };
              if (codec.channels > 1) {
                rtp.encoding = codec.channels;
              }
              _this2._mediaObject.rtp.push(rtp);
              var fmtp = {
                payload: codec.payloadType,
                config: ''
              };
              for (var _i2 = 0, _Object$keys2 = Object.keys(codec.parameters); _i2 < _Object$keys2.length; _i2++) {
                var key = _Object$keys2[_i2];
                if (fmtp.config) {
                  fmtp.config += ';';
                }
                fmtp.config += "".concat(key, "=").concat(codec.parameters[key]);
              }
              if (fmtp.config) {
                _this2._mediaObject.fmtp.push(fmtp);
              }
              var _iterator10 = _createForOfIteratorHelper(codec.rtcpFeedback),
                _step10;
              try {
                for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
                  var fb = _step10.value;
                  _this2._mediaObject.rtcpFb.push({
                    payload: codec.payloadType,
                    type: fb.type,
                    subtype: fb.parameter
                  });
                }
              } catch (err) {
                _iterator10.e(err);
              } finally {
                _iterator10.f();
              }
            }
          } catch (err) {
            _iterator0.e(err);
          } finally {
            _iterator0.f();
          }
          _this2._mediaObject.payloads = offerRtpParameters.codecs.map(function (codec) {
            return codec.payloadType;
          }).join(' ');
          _this2._mediaObject.ext = [];
          var _iterator1 = _createForOfIteratorHelper(offerRtpParameters.headerExtensions),
            _step1;
          try {
            for (_iterator1.s(); !(_step1 = _iterator1.n()).done;) {
              var ext = _step1.value;
              _this2._mediaObject.ext.push({
                uri: ext.uri,
                value: ext.id
              });
            }
          } catch (err) {
            _iterator1.e(err);
          } finally {
            _iterator1.f();
          }
          _this2._mediaObject.rtcpMux = 'rtcp-mux';
          _this2._mediaObject.rtcpRsize = 'rtcp-rsize';
          var encoding = offerRtpParameters.encodings[0];
          var ssrc = encoding.ssrc;
          var rtxSsrc = (_encoding$rtx = encoding.rtx) === null || _encoding$rtx === void 0 ? void 0 : _encoding$rtx.ssrc;
          _this2._mediaObject.ssrcs = [];
          _this2._mediaObject.ssrcGroups = [];
          if (offerRtpParameters.rtcp.cname) {
            _this2._mediaObject.ssrcs.push({
              id: ssrc,
              attribute: 'cname',
              value: offerRtpParameters.rtcp.cname
            });
          }
          if (_this2._planB) {
            _this2._mediaObject.ssrcs.push({
              id: ssrc,
              attribute: 'msid',
              value: "".concat(streamId !== null && streamId !== void 0 ? streamId : '-', " ").concat(trackId)
            });
          }
          if (rtxSsrc) {
            if (offerRtpParameters.rtcp.cname) {
              _this2._mediaObject.ssrcs.push({
                id: rtxSsrc,
                attribute: 'cname',
                value: offerRtpParameters.rtcp.cname
              });
            }
            if (_this2._planB) {
              _this2._mediaObject.ssrcs.push({
                id: rtxSsrc,
                attribute: 'msid',
                value: "".concat(streamId !== null && streamId !== void 0 ? streamId : '-', " ").concat(trackId)
              });
            }
            // Associate original and retransmission SSRCs.
            _this2._mediaObject.ssrcGroups.push({
              semantics: 'FID',
              ssrcs: "".concat(ssrc, " ").concat(rtxSsrc)
            });
          }
          break;
        }
      case 'application':
        {
          // New spec.
          if (!oldDataChannelSpec) {
            _this2._mediaObject.payloads = 'webrtc-datachannel';
            _this2._mediaObject.sctpPort = sctpParameters.port;
            _this2._mediaObject.maxMessageSize = sctpParameters.maxMessageSize;
          }
          // Old spec.
          else {
            _this2._mediaObject.payloads = sctpParameters.port;
            _this2._mediaObject.sctpmap = {
              app: 'webrtc-datachannel',
              sctpmapNumber: sctpParameters.port,
              maxMessageSize: sctpParameters.maxMessageSize
            };
          }
          break;
        }
    }
    return _this2;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _inherits(OfferMediaSection, _MediaSection3);
  return _createClass(OfferMediaSection, [{
    key: "setDtlsRole",
    value: function setDtlsRole(role) {
      // Always 'actpass'.
      this._mediaObject.setup = 'actpass';
    }
  }, {
    key: "resume",
    value: function resume() {
      this._mediaObject.direction = 'sendonly';
    }
  }, {
    key: "planBReceive",
    value: function planBReceive(_ref4) {
      var _encoding$rtx2,
        _this3 = this;
      var offerRtpParameters = _ref4.offerRtpParameters,
        streamId = _ref4.streamId,
        trackId = _ref4.trackId;
      var encoding = offerRtpParameters.encodings[0];
      var ssrc = encoding.ssrc;
      var rtxSsrc = (_encoding$rtx2 = encoding.rtx) === null || _encoding$rtx2 === void 0 ? void 0 : _encoding$rtx2.ssrc;
      var payloads = this._mediaObject.payloads.split(' ');
      var _iterator11 = _createForOfIteratorHelper(offerRtpParameters.codecs),
        _step11;
      try {
        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
          var codec = _step11.value;
          if (payloads.includes(String(codec.payloadType))) {
            continue;
          }
          var rtp = {
            payload: codec.payloadType,
            codec: getCodecName(codec),
            rate: codec.clockRate
          };
          if (codec.channels > 1) {
            rtp.encoding = codec.channels;
          }
          this._mediaObject.rtp.push(rtp);
          var fmtp = {
            payload: codec.payloadType,
            config: ''
          };
          for (var _i3 = 0, _Object$keys3 = Object.keys(codec.parameters); _i3 < _Object$keys3.length; _i3++) {
            var key = _Object$keys3[_i3];
            if (fmtp.config) {
              fmtp.config += ';';
            }
            fmtp.config += "".concat(key, "=").concat(codec.parameters[key]);
          }
          if (fmtp.config) {
            this._mediaObject.fmtp.push(fmtp);
          }
          var _iterator12 = _createForOfIteratorHelper(codec.rtcpFeedback),
            _step12;
          try {
            for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
              var fb = _step12.value;
              this._mediaObject.rtcpFb.push({
                payload: codec.payloadType,
                type: fb.type,
                subtype: fb.parameter
              });
            }
          } catch (err) {
            _iterator12.e(err);
          } finally {
            _iterator12.f();
          }
        }
      } catch (err) {
        _iterator11.e(err);
      } finally {
        _iterator11.f();
      }
      this._mediaObject.payloads += " ".concat(offerRtpParameters.codecs.filter(function (codec) {
        return !_this3._mediaObject.payloads.includes(codec.payloadType);
      }).map(function (codec) {
        return codec.payloadType;
      }).join(' '));
      this._mediaObject.payloads = this._mediaObject.payloads.trim();
      if (offerRtpParameters.rtcp.cname) {
        this._mediaObject.ssrcs.push({
          id: ssrc,
          attribute: 'cname',
          value: offerRtpParameters.rtcp.cname
        });
      }
      this._mediaObject.ssrcs.push({
        id: ssrc,
        attribute: 'msid',
        value: "".concat(streamId !== null && streamId !== void 0 ? streamId : '-', " ").concat(trackId)
      });
      if (rtxSsrc) {
        if (offerRtpParameters.rtcp.cname) {
          this._mediaObject.ssrcs.push({
            id: rtxSsrc,
            attribute: 'cname',
            value: offerRtpParameters.rtcp.cname
          });
        }
        this._mediaObject.ssrcs.push({
          id: rtxSsrc,
          attribute: 'msid',
          value: "".concat(streamId !== null && streamId !== void 0 ? streamId : '-', " ").concat(trackId)
        });
        // Associate original and retransmission SSRCs.
        this._mediaObject.ssrcGroups.push({
          semantics: 'FID',
          ssrcs: "".concat(ssrc, " ").concat(rtxSsrc)
        });
      }
    }
  }, {
    key: "planBStopReceiving",
    value: function planBStopReceiving(_ref5) {
      var _encoding$rtx3;
      var offerRtpParameters = _ref5.offerRtpParameters;
      var encoding = offerRtpParameters.encodings[0];
      var ssrc = encoding.ssrc;
      var rtxSsrc = (_encoding$rtx3 = encoding.rtx) === null || _encoding$rtx3 === void 0 ? void 0 : _encoding$rtx3.ssrc;
      this._mediaObject.ssrcs = this._mediaObject.ssrcs.filter(function (s) {
        return s.id !== ssrc && s.id !== rtxSsrc;
      });
      if (rtxSsrc) {
        this._mediaObject.ssrcGroups = this._mediaObject.ssrcGroups.filter(function (group) {
          return group.ssrcs !== "".concat(ssrc, " ").concat(rtxSsrc);
        });
      }
    }
  }]);
}(MediaSection);
exports.OfferMediaSection = OfferMediaSection;
function getCodecName(codec) {
  var MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');
  var mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);
  if (!mimeTypeMatch) {
    throw new TypeError('invalid codec.mimeType');
  }
  return mimeTypeMatch[2];
}

},{"../../utils":72,"sdp-transform":76}],63:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RemoteSdp = void 0;
var sdpTransform = require("sdp-transform");
var Logger_1 = require("../../Logger");
var MediaSection_1 = require("./MediaSection");
var DD_CODECS = ['av1', 'h264'];
var logger = new Logger_1.Logger('RemoteSdp');
var RemoteSdp = /*#__PURE__*/function () {
  function RemoteSdp(_ref) {
    var iceParameters = _ref.iceParameters,
      iceCandidates = _ref.iceCandidates,
      dtlsParameters = _ref.dtlsParameters,
      sctpParameters = _ref.sctpParameters,
      plainRtpParameters = _ref.plainRtpParameters,
      _ref$planB = _ref.planB,
      planB = _ref$planB === void 0 ? false : _ref$planB;
    _classCallCheck(this, RemoteSdp);
    // Remote ICE parameters.
    _defineProperty(this, "_iceParameters", void 0);
    // Remote ICE candidates.
    _defineProperty(this, "_iceCandidates", void 0);
    // Remote DTLS parameters.
    _defineProperty(this, "_dtlsParameters", void 0);
    // Remote SCTP parameters.
    _defineProperty(this, "_sctpParameters", void 0);
    // Parameters for plain RTP (no SRTP nor DTLS no BUNDLE).
    _defineProperty(this, "_plainRtpParameters", void 0);
    // Whether this is Plan-B SDP.
    _defineProperty(this, "_planB", void 0);
    // MediaSection instances with same order as in the SDP.
    _defineProperty(this, "_mediaSections", []);
    // MediaSection indices indexed by MID.
    _defineProperty(this, "_midToIndex", new Map());
    // First MID.
    _defineProperty(this, "_firstMid", void 0);
    // SDP object.
    _defineProperty(this, "_sdpObject", void 0);
    this._iceParameters = iceParameters;
    this._iceCandidates = iceCandidates;
    this._dtlsParameters = dtlsParameters;
    this._sctpParameters = sctpParameters;
    this._plainRtpParameters = plainRtpParameters;
    this._planB = planB;
    this._sdpObject = {
      version: 0,
      origin: {
        address: '0.0.0.0',
        ipVer: 4,
        netType: 'IN',
        sessionId: 10000,
        sessionVersion: 0,
        username: 'mediasoup-client'
      },
      name: '-',
      timing: {
        start: 0,
        stop: 0
      },
      media: []
    };
    // If ICE parameters are given, add ICE-Lite indicator.
    if (iceParameters !== null && iceParameters !== void 0 && iceParameters.iceLite) {
      this._sdpObject.icelite = 'ice-lite';
    }
    // If DTLS parameters are given, assume WebRTC and BUNDLE.
    if (dtlsParameters) {
      this._sdpObject.msidSemantic = {
        semantic: 'WMS',
        token: '*'
      };
      // NOTE: We take the latest fingerprint.
      var numFingerprints = this._dtlsParameters.fingerprints.length;
      this._sdpObject.fingerprint = {
        type: dtlsParameters.fingerprints[numFingerprints - 1].algorithm,
        hash: dtlsParameters.fingerprints[numFingerprints - 1].value
      };
      this._sdpObject.groups = [{
        type: 'BUNDLE',
        mids: ''
      }];
    }
    // If there are plain RPT parameters, override SDP origin.
    if (plainRtpParameters) {
      this._sdpObject.origin.address = plainRtpParameters.ip;
      this._sdpObject.origin.ipVer = plainRtpParameters.ipVersion;
    }
  }
  return _createClass(RemoteSdp, [{
    key: "updateIceParameters",
    value: function updateIceParameters(iceParameters) {
      logger.debug('updateIceParameters() [iceParameters:%o]', iceParameters);
      this._iceParameters = iceParameters;
      this._sdpObject.icelite = iceParameters.iceLite ? 'ice-lite' : undefined;
      var _iterator = _createForOfIteratorHelper(this._mediaSections),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var mediaSection = _step.value;
          mediaSection.setIceParameters(iceParameters);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }, {
    key: "updateDtlsRole",
    value: function updateDtlsRole(role) {
      logger.debug('updateDtlsRole() [role:%s]', role);
      this._dtlsParameters.role = role;
      var _iterator2 = _createForOfIteratorHelper(this._mediaSections),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var mediaSection = _step2.value;
          mediaSection.setDtlsRole(role);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
    /**
     * Set session level a=extmap-allow-mixed attibute.
     */
  }, {
    key: "setSessionExtmapAllowMixed",
    value: function setSessionExtmapAllowMixed() {
      logger.debug('setSessionExtmapAllowMixed()');
      this._sdpObject.extmapAllowMixed = 'extmap-allow-mixed';
    }
  }, {
    key: "getNextMediaSectionIdx",
    value: function getNextMediaSectionIdx() {
      // If a closed media section is found, return its index.
      for (var idx = 0; idx < this._mediaSections.length; ++idx) {
        var mediaSection = this._mediaSections[idx];
        if (mediaSection.closed) {
          return {
            idx: idx,
            reuseMid: mediaSection.mid
          };
        }
      }
      // If no closed media section is found, return next one.
      return {
        idx: this._mediaSections.length
      };
    }
  }, {
    key: "send",
    value: function send(_ref2) {
      var offerMediaObject = _ref2.offerMediaObject,
        reuseMid = _ref2.reuseMid,
        offerRtpParameters = _ref2.offerRtpParameters,
        answerRtpParameters = _ref2.answerRtpParameters,
        codecOptions = _ref2.codecOptions;
      var mediaSection = new MediaSection_1.AnswerMediaSection({
        iceParameters: this._iceParameters,
        iceCandidates: this._iceCandidates,
        dtlsParameters: this._dtlsParameters,
        plainRtpParameters: this._plainRtpParameters,
        planB: this._planB,
        offerMediaObject: offerMediaObject,
        offerRtpParameters: offerRtpParameters,
        answerRtpParameters: answerRtpParameters,
        codecOptions: codecOptions
      });
      var mediaObject = mediaSection.getObject();
      // Remove Dependency Descriptor extension unless there is support for
      // the codec in mediasoup.
      // @ts-expect-error --- mediaObject type is 'any'.
      var ddCodec = mediaObject.rtp.find(function (rtp) {
        return DD_CODECS.includes(rtp.codec.toLowerCase());
      });
      if (!ddCodec) {
        // @ts-expect-error --- mediaObject type is 'any'.
        mediaObject.ext = mediaObject.ext.filter(function (extmap) {
          return extmap.uri !== 'https://aomediacodec.github.io/av1-rtp-spec/#dependency-descriptor-rtp-header-extension';
        });
      }
      // Unified-Plan with closed media section replacement.
      if (reuseMid) {
        this._replaceMediaSection(mediaSection, reuseMid);
      }
      // Unified-Plan or Plan-B with different media kind.
      else if (!this._midToIndex.has(mediaSection.mid)) {
        this._addMediaSection(mediaSection);
      }
      // Plan-B with same media kind.
      else {
        this._replaceMediaSection(mediaSection);
      }
    }
  }, {
    key: "receive",
    value: function receive(_ref3) {
      var mid = _ref3.mid,
        kind = _ref3.kind,
        offerRtpParameters = _ref3.offerRtpParameters,
        streamId = _ref3.streamId,
        trackId = _ref3.trackId;
      var idx = this._midToIndex.get(mid);
      var mediaSection;
      if (idx !== undefined) {
        mediaSection = this._mediaSections[idx];
      }
      // Allow both 1 byte and 2 bytes length header extensions since
      // mediasoup can send both at any time.
      this.setSessionExtmapAllowMixed();
      // Unified-Plan or different media kind.
      if (!mediaSection) {
        mediaSection = new MediaSection_1.OfferMediaSection({
          iceParameters: this._iceParameters,
          iceCandidates: this._iceCandidates,
          dtlsParameters: this._dtlsParameters,
          plainRtpParameters: this._plainRtpParameters,
          planB: this._planB,
          mid: mid,
          kind: kind,
          offerRtpParameters: offerRtpParameters,
          streamId: streamId,
          trackId: trackId
        });
        // Let's try to recycle a closed media section (if any).
        // NOTE: Yes, we can recycle a closed m=audio section with a new m=video.
        var oldMediaSection = this._mediaSections.find(function (m) {
          return m.closed;
        });
        if (oldMediaSection) {
          this._replaceMediaSection(mediaSection, oldMediaSection.mid);
        } else {
          this._addMediaSection(mediaSection);
        }
      }
      // Plan-B.
      else {
        mediaSection.planBReceive({
          offerRtpParameters: offerRtpParameters,
          streamId: streamId,
          trackId: trackId
        });
        this._replaceMediaSection(mediaSection);
      }
    }
  }, {
    key: "pauseMediaSection",
    value: function pauseMediaSection(mid) {
      var mediaSection = this._findMediaSection(mid);
      mediaSection.pause();
    }
  }, {
    key: "resumeSendingMediaSection",
    value: function resumeSendingMediaSection(mid) {
      var mediaSection = this._findMediaSection(mid);
      mediaSection.resume();
    }
  }, {
    key: "resumeReceivingMediaSection",
    value: function resumeReceivingMediaSection(mid) {
      var mediaSection = this._findMediaSection(mid);
      mediaSection.resume();
    }
  }, {
    key: "disableMediaSection",
    value: function disableMediaSection(mid) {
      var mediaSection = this._findMediaSection(mid);
      mediaSection.disable();
    }
    /**
     * Closes media section. Returns true if the given MID corresponds to a m
     * section that has been indeed closed. False otherwise.
     *
     * NOTE: Closing the first m section is a pain since it invalidates the bundled
     * transport, so instead closing it we just disable it.
     */
  }, {
    key: "closeMediaSection",
    value: function closeMediaSection(mid) {
      var mediaSection = this._findMediaSection(mid);
      // NOTE: Closing the first m section is a pain since it invalidates the
      // bundled transport, so let's avoid it.
      if (mid === this._firstMid) {
        logger.debug('closeMediaSection() | cannot close first media section, disabling it instead [mid:%s]', mid);
        this.disableMediaSection(mid);
        return false;
      }
      mediaSection.close();
      // Regenerate BUNDLE mids.
      this._regenerateBundleMids();
      return true;
    }
  }, {
    key: "muxMediaSectionSimulcast",
    value: function muxMediaSectionSimulcast(mid, encodings) {
      var mediaSection = this._findMediaSection(mid);
      mediaSection.muxSimulcastStreams(encodings);
      this._replaceMediaSection(mediaSection);
    }
  }, {
    key: "planBStopReceiving",
    value: function planBStopReceiving(_ref4) {
      var mid = _ref4.mid,
        offerRtpParameters = _ref4.offerRtpParameters;
      var mediaSection = this._findMediaSection(mid);
      mediaSection.planBStopReceiving({
        offerRtpParameters: offerRtpParameters
      });
      this._replaceMediaSection(mediaSection);
    }
  }, {
    key: "sendSctpAssociation",
    value: function sendSctpAssociation(_ref5) {
      var offerMediaObject = _ref5.offerMediaObject;
      var mediaSection = new MediaSection_1.AnswerMediaSection({
        iceParameters: this._iceParameters,
        iceCandidates: this._iceCandidates,
        dtlsParameters: this._dtlsParameters,
        sctpParameters: this._sctpParameters,
        plainRtpParameters: this._plainRtpParameters,
        offerMediaObject: offerMediaObject
      });
      this._addMediaSection(mediaSection);
    }
  }, {
    key: "receiveSctpAssociation",
    value: function receiveSctpAssociation() {
      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref6$oldDataChannelS = _ref6.oldDataChannelSpec,
        oldDataChannelSpec = _ref6$oldDataChannelS === void 0 ? false : _ref6$oldDataChannelS;
      var mediaSection = new MediaSection_1.OfferMediaSection({
        iceParameters: this._iceParameters,
        iceCandidates: this._iceCandidates,
        dtlsParameters: this._dtlsParameters,
        sctpParameters: this._sctpParameters,
        plainRtpParameters: this._plainRtpParameters,
        mid: 'datachannel',
        kind: 'application',
        oldDataChannelSpec: oldDataChannelSpec
      });
      this._addMediaSection(mediaSection);
    }
  }, {
    key: "getSdp",
    value: function getSdp() {
      // Increase SDP version.
      this._sdpObject.origin.sessionVersion++;
      return sdpTransform.write(this._sdpObject);
    }
  }, {
    key: "_addMediaSection",
    value: function _addMediaSection(newMediaSection) {
      if (!this._firstMid) {
        this._firstMid = newMediaSection.mid;
      }
      // Add to the vector.
      this._mediaSections.push(newMediaSection);
      // Add to the map.
      this._midToIndex.set(newMediaSection.mid, this._mediaSections.length - 1);
      // Add to the SDP object.
      this._sdpObject.media.push(newMediaSection.getObject());
      // Regenerate BUNDLE mids.
      this._regenerateBundleMids();
    }
  }, {
    key: "_replaceMediaSection",
    value: function _replaceMediaSection(newMediaSection, reuseMid) {
      // Store it in the map.
      if (typeof reuseMid === 'string') {
        var idx = this._midToIndex.get(reuseMid);
        if (idx === undefined) {
          throw new Error("no media section found for reuseMid '".concat(reuseMid, "'"));
        }
        var oldMediaSection = this._mediaSections[idx];
        // Replace the index in the vector with the new media section.
        this._mediaSections[idx] = newMediaSection;
        // Update the map.
        this._midToIndex["delete"](oldMediaSection.mid);
        this._midToIndex.set(newMediaSection.mid, idx);
        // Update the SDP object.
        this._sdpObject.media[idx] = newMediaSection.getObject();
        // Regenerate BUNDLE mids.
        this._regenerateBundleMids();
      } else {
        var _idx = this._midToIndex.get(newMediaSection.mid);
        if (_idx === undefined) {
          throw new Error("no media section found with mid '".concat(newMediaSection.mid, "'"));
        }
        // Replace the index in the vector with the new media section.
        this._mediaSections[_idx] = newMediaSection;
        // Update the SDP object.
        this._sdpObject.media[_idx] = newMediaSection.getObject();
      }
    }
  }, {
    key: "_findMediaSection",
    value: function _findMediaSection(mid) {
      var idx = this._midToIndex.get(mid);
      if (idx === undefined) {
        throw new Error("no media section found with mid '".concat(mid, "'"));
      }
      return this._mediaSections[idx];
    }
  }, {
    key: "_regenerateBundleMids",
    value: function _regenerateBundleMids() {
      if (!this._dtlsParameters) {
        return;
      }
      this._sdpObject.groups[0].mids = this._mediaSections.filter(function (mediaSection) {
        return !mediaSection.closed;
      }).map(function (mediaSection) {
        return mediaSection.mid;
      }).join(' ');
    }
  }]);
}();
exports.RemoteSdp = RemoteSdp;

},{"../../Logger":39,"./MediaSection":62,"sdp-transform":76}],64:[function(require,module,exports){
"use strict";

function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractRtpCapabilities = extractRtpCapabilities;
exports.extractDtlsParameters = extractDtlsParameters;
exports.getCname = getCname;
exports.applyCodecParameters = applyCodecParameters;
var sdpTransform = require("sdp-transform");
/**
 * This function must be called with an SDP with 1 m=audio and 1 m=video
 * sections.
 */
function extractRtpCapabilities(_ref) {
  var sdpObject = _ref.sdpObject;
  // Map of RtpCodecParameters indexed by payload type.
  var codecsMap = new Map();
  // Array of RtpHeaderExtensions.
  var headerExtensions = [];
  // Whether a m=audio/video section has been already found.
  var gotAudio = false;
  var gotVideo = false;
  var _iterator = _createForOfIteratorHelper(sdpObject.media),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _m$fmtp, _m$rtcpFb, _m$ext;
      var m = _step.value;
      var kind = m.type;
      switch (kind) {
        case 'audio':
          {
            if (gotAudio) {
              continue;
            }
            gotAudio = true;
            break;
          }
        case 'video':
          {
            if (gotVideo) {
              continue;
            }
            gotVideo = true;
            break;
          }
        default:
          {
            continue;
          }
      }
      // Get codecs.
      var _iterator2 = _createForOfIteratorHelper(m.rtp),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var rtp = _step2.value;
          var codec = {
            kind: kind,
            mimeType: "".concat(kind, "/").concat(rtp.codec),
            preferredPayloadType: rtp.payload,
            clockRate: rtp.rate,
            channels: rtp.encoding,
            parameters: {},
            rtcpFeedback: []
          };
          codecsMap.set(codec.preferredPayloadType, codec);
        }
        // Get codec parameters.
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      var _iterator3 = _createForOfIteratorHelper((_m$fmtp = m.fmtp) !== null && _m$fmtp !== void 0 ? _m$fmtp : []),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var fmtp = _step3.value;
          var parameters = sdpTransform.parseParams(fmtp.config);
          var _codec = codecsMap.get(fmtp.payload);
          if (!_codec) {
            continue;
          }
          // Specials case to convert parameter value to string.
          if (parameters !== null && parameters !== void 0 && parameters.hasOwnProperty('profile-level-id')) {
            parameters['profile-level-id'] = String(parameters['profile-level-id']);
          }
          _codec.parameters = parameters;
        }
        // Get RTCP feedback for each codec.
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      var _iterator4 = _createForOfIteratorHelper((_m$rtcpFb = m.rtcpFb) !== null && _m$rtcpFb !== void 0 ? _m$rtcpFb : []),
        _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var fb = _step4.value;
          var feedback = {
            type: fb.type,
            parameter: fb.subtype
          };
          if (!feedback.parameter) {
            delete feedback.parameter;
          }
          // rtcp-fb payload is not '*', so just apply it to its corresponding
          // codec.
          if (fb.payload !== '*') {
            var _codec2 = codecsMap.get(fb.payload);
            if (!_codec2) {
              continue;
            }
            _codec2.rtcpFeedback.push(feedback);
          }
          // If rtcp-fb payload is '*' it must be applied to all codecs with same
          // kind (with some exceptions such as RTX codec).
          else {
            var _iterator6 = _createForOfIteratorHelper(codecsMap.values()),
              _step6;
            try {
              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                var _codec3 = _step6.value;
                if (_codec3.kind === kind && !/.+\/rtx$/i.test(_codec3.mimeType)) {
                  _codec3.rtcpFeedback.push(feedback);
                }
              }
            } catch (err) {
              _iterator6.e(err);
            } finally {
              _iterator6.f();
            }
          }
        }
        // Get RTP header extensions.
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
      var _iterator5 = _createForOfIteratorHelper((_m$ext = m.ext) !== null && _m$ext !== void 0 ? _m$ext : []),
        _step5;
      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var ext = _step5.value;
          // Ignore encrypted extensions (not yet supported in mediasoup).
          if (ext['encrypt-uri']) {
            continue;
          }
          var headerExtension = {
            kind: kind,
            uri: ext.uri,
            preferredId: ext.value
          };
          headerExtensions.push(headerExtension);
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  var rtpCapabilities = {
    codecs: Array.from(codecsMap.values()),
    headerExtensions: headerExtensions
  };
  return rtpCapabilities;
}
function extractDtlsParameters(_ref2) {
  var sdpObject = _ref2.sdpObject;
  var setup = sdpObject.setup;
  var fingerprint = sdpObject.fingerprint;
  if (!setup || !fingerprint) {
    var _sdpObject$media;
    var mediaObject = ((_sdpObject$media = sdpObject.media) !== null && _sdpObject$media !== void 0 ? _sdpObject$media : []).find(function (m) {
      return m.port !== 0;
    });
    if (mediaObject) {
      setup !== null && setup !== void 0 ? setup : setup = mediaObject.setup;
      fingerprint !== null && fingerprint !== void 0 ? fingerprint : fingerprint = mediaObject.fingerprint;
    }
  }
  if (!setup) {
    throw new Error('no a=setup found at SDP session or media level');
  } else if (!fingerprint) {
    throw new Error('no a=fingerprint found at SDP session or media level');
  }
  var role;
  switch (setup) {
    case 'active':
      {
        role = 'client';
        break;
      }
    case 'passive':
      {
        role = 'server';
        break;
      }
    case 'actpass':
      {
        role = 'auto';
        break;
      }
  }
  var dtlsParameters = {
    role: role,
    fingerprints: [{
      algorithm: fingerprint.type,
      value: fingerprint.hash
    }]
  };
  return dtlsParameters;
}
function getCname(_ref3) {
  var _offerMediaObject$ssr;
  var offerMediaObject = _ref3.offerMediaObject;
  var ssrcCnameLine = ((_offerMediaObject$ssr = offerMediaObject.ssrcs) !== null && _offerMediaObject$ssr !== void 0 ? _offerMediaObject$ssr : []).find(function (line) {
    return line.attribute === 'cname';
  });
  if (!ssrcCnameLine) {
    return '';
  }
  return ssrcCnameLine.value;
}
/**
 * Apply codec parameters in the given SDP m= section answer based on the
 * given RTP parameters of an offer.
 */
function applyCodecParameters(_ref4) {
  var offerRtpParameters = _ref4.offerRtpParameters,
    answerMediaObject = _ref4.answerMediaObject;
  var _iterator7 = _createForOfIteratorHelper(offerRtpParameters.codecs),
    _step7;
  try {
    var _loop = function _loop() {
        var _answerMediaObject$rt, _answerMediaObject$fm;
        var codec = _step7.value;
        var mimeType = codec.mimeType.toLowerCase();
        // Avoid parsing codec parameters for unhandled codecs.
        if (mimeType !== 'audio/opus') {
          return 0; // continue
        }
        var rtp = ((_answerMediaObject$rt = answerMediaObject.rtp) !== null && _answerMediaObject$rt !== void 0 ? _answerMediaObject$rt : []).find(function (r) {
          return r.payload === codec.payloadType;
        });
        if (!rtp) {
          return 0; // continue
        }
        // Just in case.
        answerMediaObject.fmtp = (_answerMediaObject$fm = answerMediaObject.fmtp) !== null && _answerMediaObject$fm !== void 0 ? _answerMediaObject$fm : [];
        var fmtp = answerMediaObject.fmtp.find(function (f) {
          return f.payload === codec.payloadType;
        });
        if (!fmtp) {
          fmtp = {
            payload: codec.payloadType,
            config: ''
          };
          answerMediaObject.fmtp.push(fmtp);
        }
        var parameters = sdpTransform.parseParams(fmtp.config);
        switch (mimeType) {
          case 'audio/opus':
            {
              var spropStereo = codec.parameters['sprop-stereo'];
              if (spropStereo !== undefined) {
                parameters['stereo'] = Number(spropStereo) ? 1 : 0;
              }
              break;
            }
        }
        // Write the codec fmtp.config back.
        fmtp.config = '';
        for (var _i = 0, _Object$keys = Object.keys(parameters); _i < _Object$keys.length; _i++) {
          var key = _Object$keys[_i];
          if (fmtp.config) {
            fmtp.config += ';';
          }
          fmtp.config += "".concat(key, "=").concat(parameters[key]);
        }
      },
      _ret;
    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
      _ret = _loop();
      if (_ret === 0) continue;
    }
  } catch (err) {
    _iterator7.e(err);
  } finally {
    _iterator7.f();
  }
}

},{"sdp-transform":76}],65:[function(require,module,exports){
"use strict";

function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getRtpEncodings = getRtpEncodings;
exports.addLegacySimulcast = addLegacySimulcast;
function getRtpEncodings(_ref) {
  var _offerMediaObject$ssr, _offerMediaObject$ssr2;
  var offerMediaObject = _ref.offerMediaObject,
    track = _ref.track;
  // First media SSRC (or the only one).
  var firstSsrc;
  var ssrcs = new Set();
  var _iterator = _createForOfIteratorHelper((_offerMediaObject$ssr = offerMediaObject.ssrcs) !== null && _offerMediaObject$ssr !== void 0 ? _offerMediaObject$ssr : []),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var line = _step.value;
      if (line.attribute !== 'msid') {
        continue;
      }
      var trackId = line.value.split(' ')[1];
      if (trackId === track.id) {
        var ssrc = line.id;
        ssrcs.add(ssrc);
        if (!firstSsrc) {
          firstSsrc = ssrc;
        }
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  if (ssrcs.size === 0) {
    throw new Error("a=ssrc line with msid information not found [track.id:".concat(track.id, "]"));
  }
  var ssrcToRtxSsrc = new Map();
  // First assume RTX is used.
  var _iterator2 = _createForOfIteratorHelper((_offerMediaObject$ssr2 = offerMediaObject.ssrcGroups) !== null && _offerMediaObject$ssr2 !== void 0 ? _offerMediaObject$ssr2 : []),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var _line = _step2.value;
      if (_line.semantics !== 'FID') {
        continue;
      }
      var _line$ssrcs$split = _line.ssrcs.split(/\s+/),
        _line$ssrcs$split2 = _slicedToArray(_line$ssrcs$split, 2),
        _ssrc = _line$ssrcs$split2[0],
        rtxSsrc = _line$ssrcs$split2[1];
      _ssrc = Number(_ssrc);
      rtxSsrc = Number(rtxSsrc);
      if (ssrcs.has(_ssrc)) {
        // Remove both the SSRC and RTX SSRC from the set so later we know that they
        // are already handled.
        ssrcs["delete"](_ssrc);
        ssrcs["delete"](rtxSsrc);
        // Add to the map.
        ssrcToRtxSsrc.set(_ssrc, rtxSsrc);
      }
    }
    // If the set of SSRCs is not empty it means that RTX is not being used, so take
    // media SSRCs from there.
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  var _iterator3 = _createForOfIteratorHelper(ssrcs),
    _step3;
  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var _ssrc2 = _step3.value;
      // Add to the map.
      ssrcToRtxSsrc.set(_ssrc2, null);
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
  var encodings = [];
  var _iterator4 = _createForOfIteratorHelper(ssrcToRtxSsrc),
    _step4;
  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var _step4$value = _slicedToArray(_step4.value, 2),
        _ssrc3 = _step4$value[0],
        _rtxSsrc = _step4$value[1];
      var encoding = {
        ssrc: _ssrc3
      };
      if (_rtxSsrc) {
        encoding.rtx = {
          ssrc: _rtxSsrc
        };
      }
      encodings.push(encoding);
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }
  return encodings;
}
/**
 * Adds multi-ssrc based simulcast into the given SDP media section offer.
 */
function addLegacySimulcast(_ref2) {
  var _offerMediaObject$ssr3, _offerMediaObject$ssr4, _offerMediaObject$ssr5, _offerMediaObject$ssr6;
  var offerMediaObject = _ref2.offerMediaObject,
    track = _ref2.track,
    numStreams = _ref2.numStreams;
  if (numStreams <= 1) {
    throw new TypeError('numStreams must be greater than 1');
  }
  var firstSsrc;
  var firstRtxSsrc;
  var streamId;
  // Get the SSRC.
  var ssrcMsidLine = ((_offerMediaObject$ssr3 = offerMediaObject.ssrcs) !== null && _offerMediaObject$ssr3 !== void 0 ? _offerMediaObject$ssr3 : []).find(function (line) {
    if (line.attribute !== 'msid') {
      return false;
    }
    var trackId = line.value.split(' ')[1];
    if (trackId === track.id) {
      firstSsrc = line.id;
      streamId = line.value.split(' ')[0];
      return true;
    } else {
      return false;
    }
  });
  if (!ssrcMsidLine) {
    throw new Error("a=ssrc line with msid information not found [track.id:".concat(track.id, "]"));
  }
  // Get the SSRC for RTX.
  ((_offerMediaObject$ssr4 = offerMediaObject.ssrcGroups) !== null && _offerMediaObject$ssr4 !== void 0 ? _offerMediaObject$ssr4 : []).some(function (line) {
    if (line.semantics !== 'FID') {
      return false;
    }
    var ssrcs = line.ssrcs.split(/\s+/);
    if (Number(ssrcs[0]) === firstSsrc) {
      firstRtxSsrc = Number(ssrcs[1]);
      return true;
    } else {
      return false;
    }
  });
  var ssrcCnameLine = offerMediaObject.ssrcs.find(function (line) {
    return line.attribute === 'cname' && line.id === firstSsrc;
  });
  if (!ssrcCnameLine) {
    throw new Error("a=ssrc line with cname information not found [track.id:".concat(track.id, "]"));
  }
  var cname = ssrcCnameLine.value;
  var ssrcs = [];
  var rtxSsrcs = [];
  for (var i = 0; i < numStreams; ++i) {
    ssrcs.push(firstSsrc + i);
    if (firstRtxSsrc) {
      rtxSsrcs.push(firstRtxSsrc + i);
    }
  }
  offerMediaObject.ssrcGroups = (_offerMediaObject$ssr5 = offerMediaObject.ssrcGroups) !== null && _offerMediaObject$ssr5 !== void 0 ? _offerMediaObject$ssr5 : [];
  offerMediaObject.ssrcs = (_offerMediaObject$ssr6 = offerMediaObject.ssrcs) !== null && _offerMediaObject$ssr6 !== void 0 ? _offerMediaObject$ssr6 : [];
  offerMediaObject.ssrcGroups.push({
    semantics: 'SIM',
    ssrcs: ssrcs.join(' ')
  });
  for (var _i = 0, _ssrcs = ssrcs; _i < _ssrcs.length; _i++) {
    var ssrc = _ssrcs[_i];
    offerMediaObject.ssrcs.push({
      id: ssrc,
      attribute: 'cname',
      value: cname
    });
    offerMediaObject.ssrcs.push({
      id: ssrc,
      attribute: 'msid',
      value: "".concat(streamId, " ").concat(track.id)
    });
  }
  for (var _i2 = 0; _i2 < rtxSsrcs.length; ++_i2) {
    var _ssrc4 = ssrcs[_i2];
    var rtxSsrc = rtxSsrcs[_i2];
    offerMediaObject.ssrcs.push({
      id: rtxSsrc,
      attribute: 'cname',
      value: cname
    });
    offerMediaObject.ssrcs.push({
      id: rtxSsrc,
      attribute: 'msid',
      value: "".concat(streamId, " ").concat(track.id)
    });
    offerMediaObject.ssrcGroups.push({
      semantics: 'FID',
      ssrcs: "".concat(_ssrc4, " ").concat(rtxSsrc)
    });
  }
}

},{}],66:[function(require,module,exports){
"use strict";

function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getRtpEncodings = getRtpEncodings;
exports.addLegacySimulcast = addLegacySimulcast;
function getRtpEncodings(_ref) {
  var _offerMediaObject$ssr, _offerMediaObject$ssr2;
  var offerMediaObject = _ref.offerMediaObject;
  var ssrcs = new Set();
  var _iterator = _createForOfIteratorHelper((_offerMediaObject$ssr = offerMediaObject.ssrcs) !== null && _offerMediaObject$ssr !== void 0 ? _offerMediaObject$ssr : []),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var line = _step.value;
      var ssrc = line.id;
      ssrcs.add(ssrc);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  if (ssrcs.size === 0) {
    throw new Error('no a=ssrc lines found');
  }
  var ssrcToRtxSsrc = new Map();
  // First assume RTX is used.
  var _iterator2 = _createForOfIteratorHelper((_offerMediaObject$ssr2 = offerMediaObject.ssrcGroups) !== null && _offerMediaObject$ssr2 !== void 0 ? _offerMediaObject$ssr2 : []),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var _line = _step2.value;
      if (_line.semantics !== 'FID') {
        continue;
      }
      var _line$ssrcs$split = _line.ssrcs.split(/\s+/),
        _line$ssrcs$split2 = _slicedToArray(_line$ssrcs$split, 2),
        _ssrc = _line$ssrcs$split2[0],
        rtxSsrc = _line$ssrcs$split2[1];
      _ssrc = Number(_ssrc);
      rtxSsrc = Number(rtxSsrc);
      if (ssrcs.has(_ssrc)) {
        // Remove both the SSRC and RTX SSRC from the set so later we know
        // that they are already handled.
        ssrcs["delete"](_ssrc);
        ssrcs["delete"](rtxSsrc);
        // Add to the map.
        ssrcToRtxSsrc.set(_ssrc, rtxSsrc);
      }
    }
    // If the set of SSRCs is not empty it means that RTX is not being used, so
    // take media SSRCs from there.
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  var _iterator3 = _createForOfIteratorHelper(ssrcs),
    _step3;
  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var _ssrc2 = _step3.value;
      // Add to the map.
      ssrcToRtxSsrc.set(_ssrc2, null);
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
  var encodings = [];
  var _iterator4 = _createForOfIteratorHelper(ssrcToRtxSsrc),
    _step4;
  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var _step4$value = _slicedToArray(_step4.value, 2),
        _ssrc3 = _step4$value[0],
        _rtxSsrc = _step4$value[1];
      var encoding = {
        ssrc: _ssrc3
      };
      if (_rtxSsrc) {
        encoding.rtx = {
          ssrc: _rtxSsrc
        };
      }
      encodings.push(encoding);
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }
  return encodings;
}
/**
 * Adds multi-ssrc based simulcast into the given SDP media section offer.
 */
function addLegacySimulcast(_ref2) {
  var _offerMediaObject$ssr3, _offerMediaObject$ssr4;
  var offerMediaObject = _ref2.offerMediaObject,
    numStreams = _ref2.numStreams;
  if (numStreams <= 1) {
    throw new TypeError('numStreams must be greater than 1');
  }
  // Get the SSRC.
  var ssrcMsidLine = ((_offerMediaObject$ssr3 = offerMediaObject.ssrcs) !== null && _offerMediaObject$ssr3 !== void 0 ? _offerMediaObject$ssr3 : []).find(function (line) {
    return line.attribute === 'msid';
  });
  if (!ssrcMsidLine) {
    throw new Error('a=ssrc line with msid information not found');
  }
  var _ssrcMsidLine$value$s = ssrcMsidLine.value.split(' '),
    _ssrcMsidLine$value$s2 = _slicedToArray(_ssrcMsidLine$value$s, 2),
    streamId = _ssrcMsidLine$value$s2[0],
    trackId = _ssrcMsidLine$value$s2[1];
  var firstSsrc = Number(ssrcMsidLine.id);
  var firstRtxSsrc;
  // Get the SSRC for RTX.
  ((_offerMediaObject$ssr4 = offerMediaObject.ssrcGroups) !== null && _offerMediaObject$ssr4 !== void 0 ? _offerMediaObject$ssr4 : []).some(function (line) {
    if (line.semantics !== 'FID') {
      return false;
    }
    var ssrcs = line.ssrcs.split(/\s+/);
    if (Number(ssrcs[0]) === firstSsrc) {
      firstRtxSsrc = Number(ssrcs[1]);
      return true;
    } else {
      return false;
    }
  });
  var ssrcCnameLine = offerMediaObject.ssrcs.find(function (line) {
    return line.attribute === 'cname';
  });
  if (!ssrcCnameLine) {
    throw new Error('a=ssrc line with cname information not found');
  }
  var cname = ssrcCnameLine.value;
  var ssrcs = [];
  var rtxSsrcs = [];
  for (var i = 0; i < numStreams; ++i) {
    ssrcs.push(firstSsrc + i);
    if (firstRtxSsrc) {
      rtxSsrcs.push(firstRtxSsrc + i);
    }
  }
  offerMediaObject.ssrcGroups = [];
  offerMediaObject.ssrcs = [];
  offerMediaObject.ssrcGroups.push({
    semantics: 'SIM',
    ssrcs: ssrcs.join(' ')
  });
  for (var _i = 0, _ssrcs = ssrcs; _i < _ssrcs.length; _i++) {
    var ssrc = _ssrcs[_i];
    offerMediaObject.ssrcs.push({
      id: ssrc,
      attribute: 'cname',
      value: cname
    });
    offerMediaObject.ssrcs.push({
      id: ssrc,
      attribute: 'msid',
      value: "".concat(streamId, " ").concat(trackId)
    });
  }
  for (var _i2 = 0; _i2 < rtxSsrcs.length; ++_i2) {
    var _ssrc4 = ssrcs[_i2];
    var rtxSsrc = rtxSsrcs[_i2];
    offerMediaObject.ssrcs.push({
      id: rtxSsrc,
      attribute: 'cname',
      value: cname
    });
    offerMediaObject.ssrcs.push({
      id: rtxSsrc,
      attribute: 'msid',
      value: "".concat(streamId, " ").concat(trackId)
    });
    offerMediaObject.ssrcGroups.push({
      semantics: 'FID',
      ssrcs: "".concat(_ssrc4, " ").concat(rtxSsrc)
    });
  }
}

},{}],67:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.debug = exports.testFakeParameters = exports.FakeHandler = exports.ortc = exports.parseScalabilityMode = exports.detectDeviceAsync = exports.detectDevice = exports.Device = exports.version = exports.types = void 0;
var debug_1 = require("debug");
exports.debug = debug_1["default"];
/**
 * Expose all types.
 */
exports.types = require("./types");
/**
 * Expose mediasoup-client version.
 */
exports.version = '3.12.4';
/**
 * Expose Device class and device detector helpers.
 */
var Device_1 = require("./Device");
Object.defineProperty(exports, "Device", {
  enumerable: true,
  get: function get() {
    return Device_1.Device;
  }
});
Object.defineProperty(exports, "detectDevice", {
  enumerable: true,
  get: function get() {
    return Device_1.detectDevice;
  }
});
Object.defineProperty(exports, "detectDeviceAsync", {
  enumerable: true,
  get: function get() {
    return Device_1.detectDeviceAsync;
  }
});
/**
 * Expose parseScalabilityMode() function.
 */
var scalabilityModes_1 = require("./scalabilityModes");
Object.defineProperty(exports, "parseScalabilityMode", {
  enumerable: true,
  get: function get() {
    return scalabilityModes_1.parse;
  }
});
/**
 * Expose all ORTC functions.
 */
exports.ortc = require("./ortc");
/**
 * Expose FakeHandler.
 */
var FakeHandler_1 = require("./handlers/FakeHandler");
Object.defineProperty(exports, "FakeHandler", {
  enumerable: true,
  get: function get() {
    return FakeHandler_1.FakeHandler;
  }
});
/**
 * Expose test/fakeParameters utils.
 */
exports.testFakeParameters = require("./test/fakeParameters");

},{"./Device":38,"./handlers/FakeHandler":52,"./ortc":68,"./scalabilityModes":69,"./test/fakeParameters":70,"./types":71,"debug":6}],68:[function(require,module,exports){
"use strict";

function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validateRtpCapabilities = validateRtpCapabilities;
exports.validateRtpParameters = validateRtpParameters;
exports.validateSctpStreamParameters = validateSctpStreamParameters;
exports.validateSctpCapabilities = validateSctpCapabilities;
exports.getExtendedRtpCapabilities = getExtendedRtpCapabilities;
exports.getRecvRtpCapabilities = getRecvRtpCapabilities;
exports.getSendingRtpParameters = getSendingRtpParameters;
exports.getSendingRemoteRtpParameters = getSendingRemoteRtpParameters;
exports.reduceCodecs = reduceCodecs;
exports.generateProbatorRtpParameters = generateProbatorRtpParameters;
exports.canSend = canSend;
exports.canReceive = canReceive;
var h264 = require("h264-profile-level-id");
var utils = require("./utils");
var RTP_PROBATOR_MID = 'probator';
var RTP_PROBATOR_SSRC = 1234;
var RTP_PROBATOR_CODEC_PAYLOAD_TYPE = 127;
/**
 * Validates RtpCapabilities. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtpCapabilities(caps) {
  if (_typeof(caps) !== 'object') {
    throw new TypeError('caps is not an object');
  }
  // codecs is optional. If unset, fill with an empty array.
  if (caps.codecs && !Array.isArray(caps.codecs)) {
    throw new TypeError('caps.codecs is not an array');
  } else if (!caps.codecs) {
    caps.codecs = [];
  }
  var _iterator = _createForOfIteratorHelper(caps.codecs),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var codec = _step.value;
      validateRtpCodecCapability(codec);
    }
    // headerExtensions is optional. If unset, fill with an empty array.
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  if (caps.headerExtensions && !Array.isArray(caps.headerExtensions)) {
    throw new TypeError('caps.headerExtensions is not an array');
  } else if (!caps.headerExtensions) {
    caps.headerExtensions = [];
  }
  var _iterator2 = _createForOfIteratorHelper(caps.headerExtensions),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var ext = _step2.value;
      validateRtpHeaderExtension(ext);
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
}
/**
 * Validates RtpParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtpParameters(params) {
  if (_typeof(params) !== 'object') {
    throw new TypeError('params is not an object');
  }
  // mid is optional.
  if (params.mid && typeof params.mid !== 'string') {
    throw new TypeError('params.mid is not a string');
  }
  // codecs is mandatory.
  if (!Array.isArray(params.codecs)) {
    throw new TypeError('missing params.codecs');
  }
  var _iterator3 = _createForOfIteratorHelper(params.codecs),
    _step3;
  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var codec = _step3.value;
      validateRtpCodecParameters(codec);
    }
    // headerExtensions is optional. If unset, fill with an empty array.
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
  if (params.headerExtensions && !Array.isArray(params.headerExtensions)) {
    throw new TypeError('params.headerExtensions is not an array');
  } else if (!params.headerExtensions) {
    params.headerExtensions = [];
  }
  var _iterator4 = _createForOfIteratorHelper(params.headerExtensions),
    _step4;
  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var ext = _step4.value;
      validateRtpHeaderExtensionParameters(ext);
    }
    // encodings is optional. If unset, fill with an empty array.
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }
  if (params.encodings && !Array.isArray(params.encodings)) {
    throw new TypeError('params.encodings is not an array');
  } else if (!params.encodings) {
    params.encodings = [];
  }
  var _iterator5 = _createForOfIteratorHelper(params.encodings),
    _step5;
  try {
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
      var encoding = _step5.value;
      validateRtpEncodingParameters(encoding);
    }
    // rtcp is optional. If unset, fill with an empty object.
  } catch (err) {
    _iterator5.e(err);
  } finally {
    _iterator5.f();
  }
  if (params.rtcp && _typeof(params.rtcp) !== 'object') {
    throw new TypeError('params.rtcp is not an object');
  } else if (!params.rtcp) {
    params.rtcp = {};
  }
  validateRtcpParameters(params.rtcp);
}
/**
 * Validates SctpStreamParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateSctpStreamParameters(params) {
  if (_typeof(params) !== 'object') {
    throw new TypeError('params is not an object');
  }
  // streamId is mandatory.
  if (typeof params.streamId !== 'number') {
    throw new TypeError('missing params.streamId');
  }
  // ordered is optional.
  var orderedGiven = false;
  if (typeof params.ordered === 'boolean') {
    orderedGiven = true;
  } else {
    params.ordered = true;
  }
  // maxPacketLifeTime is optional.
  if (params.maxPacketLifeTime && typeof params.maxPacketLifeTime !== 'number') {
    throw new TypeError('invalid params.maxPacketLifeTime');
  }
  // maxRetransmits is optional.
  if (params.maxRetransmits && typeof params.maxRetransmits !== 'number') {
    throw new TypeError('invalid params.maxRetransmits');
  }
  if (params.maxPacketLifeTime && params.maxRetransmits) {
    throw new TypeError('cannot provide both maxPacketLifeTime and maxRetransmits');
  }
  if (orderedGiven && params.ordered && (params.maxPacketLifeTime || params.maxRetransmits)) {
    throw new TypeError('cannot be ordered with maxPacketLifeTime or maxRetransmits');
  } else if (!orderedGiven && (params.maxPacketLifeTime || params.maxRetransmits)) {
    params.ordered = false;
  }
  // label is optional.
  if (params.label && typeof params.label !== 'string') {
    throw new TypeError('invalid params.label');
  }
  // protocol is optional.
  if (params.protocol && typeof params.protocol !== 'string') {
    throw new TypeError('invalid params.protocol');
  }
}
/**
 * Validates SctpCapabilities. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateSctpCapabilities(caps) {
  if (_typeof(caps) !== 'object') {
    throw new TypeError('caps is not an object');
  }
  // numStreams is mandatory.
  if (!caps.numStreams || _typeof(caps.numStreams) !== 'object') {
    throw new TypeError('missing caps.numStreams');
  }
  validateNumSctpStreams(caps.numStreams);
}
/**
 * Generate extended RTP capabilities for sending and receiving.
 *
 * Resulting codecs keep order preferrred by local or remote capabilities
 * depending on `preferLocalCodecsOrder`.
 */
function getExtendedRtpCapabilities(localCaps, remoteCaps, preferLocalCodecsOrder) {
  var extendedRtpCapabilities = {
    codecs: [],
    headerExtensions: []
  };
  // Match media codecs and keep the order preferred by local capabilities.
  if (preferLocalCodecsOrder) {
    var _localCaps$codecs;
    var _iterator6 = _createForOfIteratorHelper((_localCaps$codecs = localCaps.codecs) !== null && _localCaps$codecs !== void 0 ? _localCaps$codecs : []),
      _step6;
    try {
      var _loop = function _loop() {
          var _remoteCaps$codecs;
          var localCodec = _step6.value;
          if (isRtxCodec(localCodec)) {
            return 0; // continue
          }
          var matchingRemoteCodec = ((_remoteCaps$codecs = remoteCaps.codecs) !== null && _remoteCaps$codecs !== void 0 ? _remoteCaps$codecs : []).find(function (remoteCodec) {
            return matchCodecs(remoteCodec, localCodec, {
              strict: true,
              modify: true
            });
          });
          if (!matchingRemoteCodec) {
            return 0; // continue
          }
          var extendedCodec = {
            mimeType: localCodec.mimeType,
            kind: localCodec.kind,
            clockRate: localCodec.clockRate,
            channels: localCodec.channels,
            localPayloadType: localCodec.preferredPayloadType,
            localRtxPayloadType: undefined,
            remotePayloadType: matchingRemoteCodec.preferredPayloadType,
            remoteRtxPayloadType: undefined,
            localParameters: localCodec.parameters,
            remoteParameters: matchingRemoteCodec.parameters,
            rtcpFeedback: reduceRtcpFeedback(localCodec, matchingRemoteCodec)
          };
          extendedRtpCapabilities.codecs.push(extendedCodec);
        },
        _ret;
      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
        _ret = _loop();
        if (_ret === 0) continue;
      }
    } catch (err) {
      _iterator6.e(err);
    } finally {
      _iterator6.f();
    }
  }
  // Match media codecs and keep the order preferred by remote capabilities.
  else {
    var _remoteCaps$codecs2;
    var _iterator7 = _createForOfIteratorHelper((_remoteCaps$codecs2 = remoteCaps.codecs) !== null && _remoteCaps$codecs2 !== void 0 ? _remoteCaps$codecs2 : []),
      _step7;
    try {
      var _loop2 = function _loop2() {
          var _localCaps$codecs2;
          var remoteCodec = _step7.value;
          if (isRtxCodec(remoteCodec)) {
            return 0; // continue
          }
          var matchingLocalCodec = ((_localCaps$codecs2 = localCaps.codecs) !== null && _localCaps$codecs2 !== void 0 ? _localCaps$codecs2 : []).find(function (localCodec) {
            return matchCodecs(localCodec, remoteCodec, {
              strict: true,
              modify: true
            });
          });
          if (!matchingLocalCodec) {
            return 0; // continue
          }
          var extendedCodec = {
            mimeType: matchingLocalCodec.mimeType,
            kind: matchingLocalCodec.kind,
            clockRate: matchingLocalCodec.clockRate,
            channels: matchingLocalCodec.channels,
            localPayloadType: matchingLocalCodec.preferredPayloadType,
            localRtxPayloadType: undefined,
            remotePayloadType: remoteCodec.preferredPayloadType,
            remoteRtxPayloadType: undefined,
            localParameters: matchingLocalCodec.parameters,
            remoteParameters: remoteCodec.parameters,
            rtcpFeedback: reduceRtcpFeedback(matchingLocalCodec, remoteCodec)
          };
          extendedRtpCapabilities.codecs.push(extendedCodec);
        },
        _ret2;
      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
        _ret2 = _loop2();
        if (_ret2 === 0) continue;
      }
    } catch (err) {
      _iterator7.e(err);
    } finally {
      _iterator7.f();
    }
  }
  // Match RTX codecs.
  var _iterator8 = _createForOfIteratorHelper(extendedRtpCapabilities.codecs),
    _step8;
  try {
    var _loop3 = function _loop3() {
      var extendedCodec = _step8.value;
      var matchingLocalRtxCodec = localCaps.codecs.find(function (localCodec) {
        return isRtxCodec(localCodec) && localCodec.parameters.apt === extendedCodec.localPayloadType;
      });
      var matchingRemoteRtxCodec = remoteCaps.codecs.find(function (remoteCodec) {
        return isRtxCodec(remoteCodec) && remoteCodec.parameters.apt === extendedCodec.remotePayloadType;
      });
      if (matchingLocalRtxCodec && matchingRemoteRtxCodec) {
        extendedCodec.localRtxPayloadType = matchingLocalRtxCodec.preferredPayloadType;
        extendedCodec.remoteRtxPayloadType = matchingRemoteRtxCodec.preferredPayloadType;
      }
    };
    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
      _loop3();
    }
    // Match header extensions.
  } catch (err) {
    _iterator8.e(err);
  } finally {
    _iterator8.f();
  }
  var _iterator9 = _createForOfIteratorHelper(remoteCaps.headerExtensions),
    _step9;
  try {
    var _loop4 = function _loop4() {
      var remoteExt = _step9.value;
      var matchingLocalExt = localCaps.headerExtensions.find(function (localExt) {
        return matchHeaderExtensions(localExt, remoteExt);
      });
      if (!matchingLocalExt) {
        return 1; // continue
      }
      var extendedExt = {
        kind: remoteExt.kind,
        uri: remoteExt.uri,
        sendId: matchingLocalExt.preferredId,
        recvId: remoteExt.preferredId,
        encrypt: matchingLocalExt.preferredEncrypt,
        direction: 'sendrecv'
      };
      switch (remoteExt.direction) {
        case 'sendrecv':
          {
            extendedExt.direction = 'sendrecv';
            break;
          }
        case 'recvonly':
          {
            extendedExt.direction = 'sendonly';
            break;
          }
        case 'sendonly':
          {
            extendedExt.direction = 'recvonly';
            break;
          }
        case 'inactive':
          {
            extendedExt.direction = 'inactive';
            break;
          }
      }
      extendedRtpCapabilities.headerExtensions.push(extendedExt);
    };
    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
      if (_loop4()) continue;
    }
  } catch (err) {
    _iterator9.e(err);
  } finally {
    _iterator9.f();
  }
  return extendedRtpCapabilities;
}
/**
 * Generate RTP capabilities for receiving media based on the given extended
 * RTP capabilities.
 */
function getRecvRtpCapabilities(extendedRtpCapabilities) {
  var rtpCapabilities = {
    codecs: [],
    headerExtensions: []
  };
  var _iterator0 = _createForOfIteratorHelper(extendedRtpCapabilities.codecs),
    _step0;
  try {
    for (_iterator0.s(); !(_step0 = _iterator0.n()).done;) {
      var extendedCodec = _step0.value;
      var codec = {
        mimeType: extendedCodec.mimeType,
        kind: extendedCodec.kind,
        preferredPayloadType: extendedCodec.remotePayloadType,
        clockRate: extendedCodec.clockRate,
        channels: extendedCodec.channels,
        parameters: extendedCodec.localParameters,
        rtcpFeedback: extendedCodec.rtcpFeedback
      };
      rtpCapabilities.codecs.push(codec);
      // Add RTX codec.
      if (!extendedCodec.remoteRtxPayloadType) {
        continue;
      }
      var rtxCodec = {
        mimeType: "".concat(extendedCodec.kind, "/rtx"),
        kind: extendedCodec.kind,
        preferredPayloadType: extendedCodec.remoteRtxPayloadType,
        clockRate: extendedCodec.clockRate,
        parameters: {
          apt: extendedCodec.remotePayloadType
        },
        rtcpFeedback: []
      };
      rtpCapabilities.codecs.push(rtxCodec);
      // TODO: In the future, we need to add FEC, CN, etc, codecs.
    }
  } catch (err) {
    _iterator0.e(err);
  } finally {
    _iterator0.f();
  }
  var _iterator1 = _createForOfIteratorHelper(extendedRtpCapabilities.headerExtensions),
    _step1;
  try {
    for (_iterator1.s(); !(_step1 = _iterator1.n()).done;) {
      var extendedExtension = _step1.value;
      // Ignore RTP extensions not valid for receiving.
      if (extendedExtension.direction !== 'sendrecv' && extendedExtension.direction !== 'recvonly') {
        continue;
      }
      var ext = {
        kind: extendedExtension.kind,
        uri: extendedExtension.uri,
        preferredId: extendedExtension.recvId,
        preferredEncrypt: extendedExtension.encrypt,
        direction: extendedExtension.direction
      };
      rtpCapabilities.headerExtensions.push(ext);
    }
  } catch (err) {
    _iterator1.e(err);
  } finally {
    _iterator1.f();
  }
  return rtpCapabilities;
}
/**
 * Generate RTP parameters of the given kind for sending media.
 * NOTE: mid, encodings and rtcp fields are left empty.
 */
function getSendingRtpParameters(kind, extendedRtpCapabilities) {
  var rtpParameters = {
    mid: undefined,
    codecs: [],
    headerExtensions: [],
    encodings: [],
    rtcp: {}
  };
  var _iterator10 = _createForOfIteratorHelper(extendedRtpCapabilities.codecs),
    _step10;
  try {
    for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
      var extendedCodec = _step10.value;
      if (extendedCodec.kind !== kind) {
        continue;
      }
      var codec = {
        mimeType: extendedCodec.mimeType,
        payloadType: extendedCodec.localPayloadType,
        clockRate: extendedCodec.clockRate,
        channels: extendedCodec.channels,
        parameters: extendedCodec.localParameters,
        rtcpFeedback: extendedCodec.rtcpFeedback
      };
      rtpParameters.codecs.push(codec);
      // Add RTX codec.
      if (extendedCodec.localRtxPayloadType) {
        var rtxCodec = {
          mimeType: "".concat(extendedCodec.kind, "/rtx"),
          payloadType: extendedCodec.localRtxPayloadType,
          clockRate: extendedCodec.clockRate,
          parameters: {
            apt: extendedCodec.localPayloadType
          },
          rtcpFeedback: []
        };
        rtpParameters.codecs.push(rtxCodec);
      }
    }
  } catch (err) {
    _iterator10.e(err);
  } finally {
    _iterator10.f();
  }
  var _iterator11 = _createForOfIteratorHelper(extendedRtpCapabilities.headerExtensions),
    _step11;
  try {
    for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
      var extendedExtension = _step11.value;
      // Ignore RTP extensions of a different kind and those not valid for sending.
      if (extendedExtension.kind && extendedExtension.kind !== kind || extendedExtension.direction !== 'sendrecv' && extendedExtension.direction !== 'sendonly') {
        continue;
      }
      var ext = {
        uri: extendedExtension.uri,
        id: extendedExtension.sendId,
        encrypt: extendedExtension.encrypt,
        parameters: {}
      };
      rtpParameters.headerExtensions.push(ext);
    }
  } catch (err) {
    _iterator11.e(err);
  } finally {
    _iterator11.f();
  }
  return rtpParameters;
}
/**
 * Generate RTP parameters of the given kind suitable for the remote SDP answer.
 */
function getSendingRemoteRtpParameters(kind, extendedRtpCapabilities) {
  var rtpParameters = {
    mid: undefined,
    codecs: [],
    headerExtensions: [],
    encodings: [],
    rtcp: {}
  };
  var _iterator12 = _createForOfIteratorHelper(extendedRtpCapabilities.codecs),
    _step12;
  try {
    for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
      var extendedCodec = _step12.value;
      if (extendedCodec.kind !== kind) {
        continue;
      }
      var _codec3 = {
        mimeType: extendedCodec.mimeType,
        payloadType: extendedCodec.localPayloadType,
        clockRate: extendedCodec.clockRate,
        channels: extendedCodec.channels,
        parameters: extendedCodec.remoteParameters,
        rtcpFeedback: extendedCodec.rtcpFeedback
      };
      rtpParameters.codecs.push(_codec3);
      // Add RTX codec.
      if (extendedCodec.localRtxPayloadType) {
        var rtxCodec = {
          mimeType: "".concat(extendedCodec.kind, "/rtx"),
          payloadType: extendedCodec.localRtxPayloadType,
          clockRate: extendedCodec.clockRate,
          parameters: {
            apt: extendedCodec.localPayloadType
          },
          rtcpFeedback: []
        };
        rtpParameters.codecs.push(rtxCodec);
      }
    }
  } catch (err) {
    _iterator12.e(err);
  } finally {
    _iterator12.f();
  }
  var _iterator13 = _createForOfIteratorHelper(extendedRtpCapabilities.headerExtensions),
    _step13;
  try {
    for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
      var extendedExtension = _step13.value;
      // Ignore RTP extensions of a different kind and those not valid for sending.
      if (extendedExtension.kind && extendedExtension.kind !== kind || extendedExtension.direction !== 'sendrecv' && extendedExtension.direction !== 'sendonly') {
        continue;
      }
      var ext = {
        uri: extendedExtension.uri,
        id: extendedExtension.sendId,
        encrypt: extendedExtension.encrypt,
        parameters: {}
      };
      rtpParameters.headerExtensions.push(ext);
    }
    // Reduce codecs' RTCP feedback. Use Transport-CC if available, REMB otherwise.
  } catch (err) {
    _iterator13.e(err);
  } finally {
    _iterator13.f();
  }
  if (rtpParameters.headerExtensions.some(function (ext) {
    return ext.uri === 'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01';
  })) {
    var _iterator14 = _createForOfIteratorHelper(rtpParameters.codecs),
      _step14;
    try {
      for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
        var _codec$rtcpFeedback;
        var codec = _step14.value;
        codec.rtcpFeedback = ((_codec$rtcpFeedback = codec.rtcpFeedback) !== null && _codec$rtcpFeedback !== void 0 ? _codec$rtcpFeedback : []).filter(function (fb) {
          return fb.type !== 'goog-remb';
        });
      }
    } catch (err) {
      _iterator14.e(err);
    } finally {
      _iterator14.f();
    }
  } else if (rtpParameters.headerExtensions.some(function (ext) {
    return ext.uri === 'http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time';
  })) {
    var _iterator15 = _createForOfIteratorHelper(rtpParameters.codecs),
      _step15;
    try {
      for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
        var _codec$rtcpFeedback2;
        var _codec = _step15.value;
        _codec.rtcpFeedback = ((_codec$rtcpFeedback2 = _codec.rtcpFeedback) !== null && _codec$rtcpFeedback2 !== void 0 ? _codec$rtcpFeedback2 : []).filter(function (fb) {
          return fb.type !== 'transport-cc';
        });
      }
    } catch (err) {
      _iterator15.e(err);
    } finally {
      _iterator15.f();
    }
  } else {
    var _iterator16 = _createForOfIteratorHelper(rtpParameters.codecs),
      _step16;
    try {
      for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
        var _codec2$rtcpFeedback;
        var _codec2 = _step16.value;
        _codec2.rtcpFeedback = ((_codec2$rtcpFeedback = _codec2.rtcpFeedback) !== null && _codec2$rtcpFeedback !== void 0 ? _codec2$rtcpFeedback : []).filter(function (fb) {
          return fb.type !== 'transport-cc' && fb.type !== 'goog-remb';
        });
      }
    } catch (err) {
      _iterator16.e(err);
    } finally {
      _iterator16.f();
    }
  }
  return rtpParameters;
}
/**
 * Reduce given codecs by returning an array of codecs "compatible" with the
 * given capability codec. If no capability codec is given, take the first
 * one(s).
 *
 * Given codecs must be generated by ortc.getSendingRtpParameters() or
 * ortc.getSendingRemoteRtpParameters().
 *
 * The returned array of codecs also include a RTX codec if available.
 */
function reduceCodecs(codecs, capCodec) {
  var filteredCodecs = [];
  // If no capability codec is given, take the first one (and RTX).
  if (!capCodec) {
    filteredCodecs.push(codecs[0]);
    if (isRtxCodec(codecs[1])) {
      filteredCodecs.push(codecs[1]);
    }
  }
  // Otherwise look for a compatible set of codecs.
  else {
    for (var idx = 0; idx < codecs.length; ++idx) {
      if (matchCodecs(codecs[idx], capCodec, {
        strict: true
      })) {
        filteredCodecs.push(codecs[idx]);
        if (isRtxCodec(codecs[idx + 1])) {
          filteredCodecs.push(codecs[idx + 1]);
        }
        break;
      }
    }
    if (filteredCodecs.length === 0) {
      throw new TypeError('no matching codec found');
    }
  }
  return filteredCodecs;
}
/**
 * Create RTP parameters for a Consumer for the RTP probator.
 */
function generateProbatorRtpParameters(videoRtpParameters) {
  // Clone given reference video RTP parameters.
  videoRtpParameters = utils.clone(videoRtpParameters);
  // This may throw.
  validateRtpParameters(videoRtpParameters);
  var rtpParameters = {
    mid: RTP_PROBATOR_MID,
    codecs: [],
    headerExtensions: [],
    encodings: [{
      ssrc: RTP_PROBATOR_SSRC
    }],
    rtcp: {
      cname: 'probator'
    }
  };
  rtpParameters.codecs.push(videoRtpParameters.codecs[0]);
  rtpParameters.codecs[0].payloadType = RTP_PROBATOR_CODEC_PAYLOAD_TYPE;
  rtpParameters.headerExtensions = videoRtpParameters.headerExtensions;
  return rtpParameters;
}
/**
 * Whether media can be sent based on the given RTP capabilities.
 */
function canSend(kind, extendedRtpCapabilities) {
  return extendedRtpCapabilities.codecs.some(function (codec) {
    return codec.kind === kind;
  });
}
/**
 * Whether the given RTP parameters can be received with the given RTP
 * capabilities.
 */
function canReceive(rtpParameters, extendedRtpCapabilities) {
  // This may throw.
  validateRtpParameters(rtpParameters);
  if (rtpParameters.codecs.length === 0) {
    return false;
  }
  var firstMediaCodec = rtpParameters.codecs[0];
  return extendedRtpCapabilities.codecs.some(function (codec) {
    return codec.remotePayloadType === firstMediaCodec.payloadType;
  });
}
/**
 * Validates RtpCodecCapability. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtpCodecCapability(codec) {
  var MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');
  if (_typeof(codec) !== 'object') {
    throw new TypeError('codec is not an object');
  }
  // mimeType is mandatory.
  if (!codec.mimeType || typeof codec.mimeType !== 'string') {
    throw new TypeError('missing codec.mimeType');
  }
  var mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);
  if (!mimeTypeMatch) {
    throw new TypeError('invalid codec.mimeType');
  }
  // Just override kind with media component of mimeType.
  codec.kind = mimeTypeMatch[1].toLowerCase();
  // preferredPayloadType is optional.
  if (codec.preferredPayloadType && typeof codec.preferredPayloadType !== 'number') {
    throw new TypeError('invalid codec.preferredPayloadType');
  }
  // clockRate is mandatory.
  if (typeof codec.clockRate !== 'number') {
    throw new TypeError('missing codec.clockRate');
  }
  // channels is optional. If unset, set it to 1 (just if audio).
  if (codec.kind === 'audio') {
    if (typeof codec.channels !== 'number') {
      codec.channels = 1;
    }
  } else {
    delete codec.channels;
  }
  // parameters is optional. If unset, set it to an empty object.
  if (!codec.parameters || _typeof(codec.parameters) !== 'object') {
    codec.parameters = {};
  }
  for (var _i = 0, _Object$keys = Object.keys(codec.parameters); _i < _Object$keys.length; _i++) {
    var key = _Object$keys[_i];
    var value = codec.parameters[key];
    if (value === undefined) {
      codec.parameters[key] = '';
      value = '';
    }
    if (typeof value !== 'string' && typeof value !== 'number') {
      throw new TypeError("invalid codec parameter [key:".concat(key, "s, value:").concat(value, "]"));
    }
    // Specific parameters validation.
    if (key === 'apt') {
      if (typeof value !== 'number') {
        throw new TypeError('invalid codec apt parameter');
      }
    }
  }
  // rtcpFeedback is optional. If unset, set it to an empty array.
  if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback)) {
    codec.rtcpFeedback = [];
  }
  var _iterator17 = _createForOfIteratorHelper(codec.rtcpFeedback),
    _step17;
  try {
    for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
      var fb = _step17.value;
      validateRtcpFeedback(fb);
    }
  } catch (err) {
    _iterator17.e(err);
  } finally {
    _iterator17.f();
  }
}
/**
 * Validates RtcpFeedback. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtcpFeedback(fb) {
  if (_typeof(fb) !== 'object') {
    throw new TypeError('fb is not an object');
  }
  // type is mandatory.
  if (!fb.type || typeof fb.type !== 'string') {
    throw new TypeError('missing fb.type');
  }
  // parameter is optional. If unset set it to an empty string.
  if (!fb.parameter || typeof fb.parameter !== 'string') {
    fb.parameter = '';
  }
}
/**
 * Validates RtpHeaderExtension. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtpHeaderExtension(ext) {
  if (_typeof(ext) !== 'object') {
    throw new TypeError('ext is not an object');
  }
  // kind is mandatory.
  if (ext.kind !== 'audio' && ext.kind !== 'video') {
    throw new TypeError('invalid ext.kind');
  }
  // uri is mandatory.
  if (!ext.uri || typeof ext.uri !== 'string') {
    throw new TypeError('missing ext.uri');
  }
  // preferredId is mandatory.
  if (typeof ext.preferredId !== 'number') {
    throw new TypeError('missing ext.preferredId');
  }
  // preferredEncrypt is optional. If unset set it to false.
  if (ext.preferredEncrypt && typeof ext.preferredEncrypt !== 'boolean') {
    throw new TypeError('invalid ext.preferredEncrypt');
  } else if (!ext.preferredEncrypt) {
    ext.preferredEncrypt = false;
  }
  // direction is optional. If unset set it to sendrecv.
  if (ext.direction && typeof ext.direction !== 'string') {
    throw new TypeError('invalid ext.direction');
  } else if (!ext.direction) {
    ext.direction = 'sendrecv';
  }
}
/**
 * Validates RtpCodecParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtpCodecParameters(codec) {
  var MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');
  if (_typeof(codec) !== 'object') {
    throw new TypeError('codec is not an object');
  }
  // mimeType is mandatory.
  if (!codec.mimeType || typeof codec.mimeType !== 'string') {
    throw new TypeError('missing codec.mimeType');
  }
  var mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);
  if (!mimeTypeMatch) {
    throw new TypeError('invalid codec.mimeType');
  }
  // payloadType is mandatory.
  if (typeof codec.payloadType !== 'number') {
    throw new TypeError('missing codec.payloadType');
  }
  // clockRate is mandatory.
  if (typeof codec.clockRate !== 'number') {
    throw new TypeError('missing codec.clockRate');
  }
  var kind = mimeTypeMatch[1].toLowerCase();
  // channels is optional. If unset, set it to 1 (just if audio).
  if (kind === 'audio') {
    if (typeof codec.channels !== 'number') {
      codec.channels = 1;
    }
  } else {
    delete codec.channels;
  }
  // parameters is optional. If unset, set it to an empty object.
  if (!codec.parameters || _typeof(codec.parameters) !== 'object') {
    codec.parameters = {};
  }
  for (var _i2 = 0, _Object$keys2 = Object.keys(codec.parameters); _i2 < _Object$keys2.length; _i2++) {
    var key = _Object$keys2[_i2];
    var value = codec.parameters[key];
    if (value === undefined) {
      codec.parameters[key] = '';
      value = '';
    }
    if (typeof value !== 'string' && typeof value !== 'number') {
      throw new TypeError("invalid codec parameter [key:".concat(key, "s, value:").concat(value, "]"));
    }
    // Specific parameters validation.
    if (key === 'apt') {
      if (typeof value !== 'number') {
        throw new TypeError('invalid codec apt parameter');
      }
    }
  }
  // rtcpFeedback is optional. If unset, set it to an empty array.
  if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback)) {
    codec.rtcpFeedback = [];
  }
  var _iterator18 = _createForOfIteratorHelper(codec.rtcpFeedback),
    _step18;
  try {
    for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {
      var fb = _step18.value;
      validateRtcpFeedback(fb);
    }
  } catch (err) {
    _iterator18.e(err);
  } finally {
    _iterator18.f();
  }
}
/**
 * Validates RtpHeaderExtensionParameteters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtpHeaderExtensionParameters(ext) {
  if (_typeof(ext) !== 'object') {
    throw new TypeError('ext is not an object');
  }
  // uri is mandatory.
  if (!ext.uri || typeof ext.uri !== 'string') {
    throw new TypeError('missing ext.uri');
  }
  // id is mandatory.
  if (typeof ext.id !== 'number') {
    throw new TypeError('missing ext.id');
  }
  // encrypt is optional. If unset set it to false.
  if (ext.encrypt && typeof ext.encrypt !== 'boolean') {
    throw new TypeError('invalid ext.encrypt');
  } else if (!ext.encrypt) {
    ext.encrypt = false;
  }
  // parameters is optional. If unset, set it to an empty object.
  if (!ext.parameters || _typeof(ext.parameters) !== 'object') {
    ext.parameters = {};
  }
  for (var _i3 = 0, _Object$keys3 = Object.keys(ext.parameters); _i3 < _Object$keys3.length; _i3++) {
    var key = _Object$keys3[_i3];
    var value = ext.parameters[key];
    if (value === undefined) {
      ext.parameters[key] = '';
      value = '';
    }
    if (typeof value !== 'string' && typeof value !== 'number') {
      throw new TypeError('invalid header extension parameter');
    }
  }
}
/**
 * Validates RtpEncodingParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtpEncodingParameters(encoding) {
  if (_typeof(encoding) !== 'object') {
    throw new TypeError('encoding is not an object');
  }
  // ssrc is optional.
  if (encoding.ssrc && typeof encoding.ssrc !== 'number') {
    throw new TypeError('invalid encoding.ssrc');
  }
  // rid is optional.
  if (encoding.rid && typeof encoding.rid !== 'string') {
    throw new TypeError('invalid encoding.rid');
  }
  // rtx is optional.
  if (encoding.rtx && _typeof(encoding.rtx) !== 'object') {
    throw new TypeError('invalid encoding.rtx');
  } else if (encoding.rtx) {
    // RTX ssrc is mandatory if rtx is present.
    if (typeof encoding.rtx.ssrc !== 'number') {
      throw new TypeError('missing encoding.rtx.ssrc');
    }
  }
  // dtx is optional. If unset set it to false.
  if (!encoding.dtx || typeof encoding.dtx !== 'boolean') {
    encoding.dtx = false;
  }
  // scalabilityMode is optional.
  if (encoding.scalabilityMode && typeof encoding.scalabilityMode !== 'string') {
    throw new TypeError('invalid encoding.scalabilityMode');
  }
}
/**
 * Validates RtcpParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtcpParameters(rtcp) {
  if (_typeof(rtcp) !== 'object') {
    throw new TypeError('rtcp is not an object');
  }
  // cname is optional.
  if (rtcp.cname && typeof rtcp.cname !== 'string') {
    throw new TypeError('invalid rtcp.cname');
  }
  // reducedSize is optional. If unset set it to true.
  if (!rtcp.reducedSize || typeof rtcp.reducedSize !== 'boolean') {
    rtcp.reducedSize = true;
  }
}
/**
 * Validates NumSctpStreams. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateNumSctpStreams(numStreams) {
  if (_typeof(numStreams) !== 'object') {
    throw new TypeError('numStreams is not an object');
  }
  // OS is mandatory.
  if (typeof numStreams.OS !== 'number') {
    throw new TypeError('missing numStreams.OS');
  }
  // MIS is mandatory.
  if (typeof numStreams.MIS !== 'number') {
    throw new TypeError('missing numStreams.MIS');
  }
}
function isRtxCodec(codec) {
  if (!codec) {
    return false;
  }
  return /.+\/rtx$/i.test(codec.mimeType);
}
function matchCodecs(aCodec, bCodec) {
  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
    _ref$strict = _ref.strict,
    strict = _ref$strict === void 0 ? false : _ref$strict,
    _ref$modify = _ref.modify,
    modify = _ref$modify === void 0 ? false : _ref$modify;
  var aMimeType = aCodec.mimeType.toLowerCase();
  var bMimeType = bCodec.mimeType.toLowerCase();
  if (aMimeType !== bMimeType) {
    return false;
  }
  if (aCodec.clockRate !== bCodec.clockRate) {
    return false;
  }
  if (aCodec.channels !== bCodec.channels) {
    return false;
  }
  // Per codec special checks.
  switch (aMimeType) {
    case 'video/h264':
      {
        if (strict) {
          var _aCodec$parameters$pa, _bCodec$parameters$pa;
          var aPacketizationMode = (_aCodec$parameters$pa = aCodec.parameters['packetization-mode']) !== null && _aCodec$parameters$pa !== void 0 ? _aCodec$parameters$pa : 0;
          var bPacketizationMode = (_bCodec$parameters$pa = bCodec.parameters['packetization-mode']) !== null && _bCodec$parameters$pa !== void 0 ? _bCodec$parameters$pa : 0;
          if (aPacketizationMode !== bPacketizationMode) {
            return false;
          }
          if (!h264.isSameProfile(aCodec.parameters, bCodec.parameters)) {
            return false;
          }
          var selectedProfileLevelId;
          try {
            selectedProfileLevelId = h264.generateProfileLevelIdStringForAnswer(aCodec.parameters, bCodec.parameters);
          } catch (error) {
            return false;
          }
          if (modify) {
            if (selectedProfileLevelId) {
              aCodec.parameters['profile-level-id'] = selectedProfileLevelId;
              bCodec.parameters['profile-level-id'] = selectedProfileLevelId;
            } else {
              delete aCodec.parameters['profile-level-id'];
              delete bCodec.parameters['profile-level-id'];
            }
          }
        }
        break;
      }
    case 'video/vp9':
      {
        if (strict) {
          var _aCodec$parameters$pr, _bCodec$parameters$pr;
          var aProfileId = (_aCodec$parameters$pr = aCodec.parameters['profile-id']) !== null && _aCodec$parameters$pr !== void 0 ? _aCodec$parameters$pr : 0;
          var bProfileId = (_bCodec$parameters$pr = bCodec.parameters['profile-id']) !== null && _bCodec$parameters$pr !== void 0 ? _bCodec$parameters$pr : 0;
          if (aProfileId !== bProfileId) {
            return false;
          }
        }
        break;
      }
  }
  return true;
}
function matchHeaderExtensions(aExt, bExt) {
  if (aExt.kind && bExt.kind && aExt.kind !== bExt.kind) {
    return false;
  }
  if (aExt.uri !== bExt.uri) {
    return false;
  }
  return true;
}
function reduceRtcpFeedback(codecA, codecB) {
  var _codecA$rtcpFeedback;
  var reducedRtcpFeedback = [];
  var _iterator19 = _createForOfIteratorHelper((_codecA$rtcpFeedback = codecA.rtcpFeedback) !== null && _codecA$rtcpFeedback !== void 0 ? _codecA$rtcpFeedback : []),
    _step19;
  try {
    var _loop5 = function _loop5() {
      var _codecB$rtcpFeedback;
      var aFb = _step19.value;
      var matchingBFb = ((_codecB$rtcpFeedback = codecB.rtcpFeedback) !== null && _codecB$rtcpFeedback !== void 0 ? _codecB$rtcpFeedback : []).find(function (bFb) {
        return bFb.type === aFb.type && (bFb.parameter === aFb.parameter || !bFb.parameter && !aFb.parameter);
      });
      if (matchingBFb) {
        reducedRtcpFeedback.push(matchingBFb);
      }
    };
    for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {
      _loop5();
    }
  } catch (err) {
    _iterator19.e(err);
  } finally {
    _iterator19.f();
  }
  return reducedRtcpFeedback;
}

},{"./utils":72,"h264-profile-level-id":34}],69:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parse = parse;
var ScalabilityModeRegex = new RegExp('^[LS]([1-9]\\d{0,1})T([1-9]\\d{0,1})');
function parse(scalabilityMode) {
  var match = ScalabilityModeRegex.exec(scalabilityMode !== null && scalabilityMode !== void 0 ? scalabilityMode : '');
  if (match) {
    return {
      spatialLayers: Number(match[1]),
      temporalLayers: Number(match[2])
    };
  } else {
    return {
      spatialLayers: 1,
      temporalLayers: 1
    };
  }
}

},{}],70:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateRouterRtpCapabilities = generateRouterRtpCapabilities;
exports.generateNativeRtpCapabilities = generateNativeRtpCapabilities;
exports.generateNativeSctpCapabilities = generateNativeSctpCapabilities;
exports.generateLocalDtlsParameters = generateLocalDtlsParameters;
exports.generateTransportRemoteParameters = generateTransportRemoteParameters;
exports.generateProducerRemoteParameters = generateProducerRemoteParameters;
exports.generateConsumerRemoteParameters = generateConsumerRemoteParameters;
exports.generateDataProducerRemoteParameters = generateDataProducerRemoteParameters;
exports.generateDataConsumerRemoteParameters = generateDataConsumerRemoteParameters;
var utils = require("../utils");
function generateFakeUuid() {
  return String(utils.generateRandomNumber());
}
function generateRouterRtpCapabilities() {
  return utils.deepFreeze({
    codecs: [{
      mimeType: 'audio/opus',
      kind: 'audio',
      preferredPayloadType: 100,
      clockRate: 48000,
      channels: 2,
      rtcpFeedback: [{
        type: 'transport-cc'
      }],
      parameters: {
        useinbandfec: 1,
        foo: 'bar'
      }
    }, {
      mimeType: 'video/VP8',
      kind: 'video',
      preferredPayloadType: 101,
      clockRate: 90000,
      rtcpFeedback: [{
        type: 'nack'
      }, {
        type: 'nack',
        parameter: 'pli'
      }, {
        type: 'ccm',
        parameter: 'fir'
      }, {
        type: 'goog-remb'
      }, {
        type: 'transport-cc'
      }],
      parameters: {
        'x-google-start-bitrate': 1500
      }
    }, {
      mimeType: 'video/rtx',
      kind: 'video',
      preferredPayloadType: 102,
      clockRate: 90000,
      rtcpFeedback: [],
      parameters: {
        apt: 101
      }
    }, {
      mimeType: 'video/H264',
      kind: 'video',
      preferredPayloadType: 103,
      clockRate: 90000,
      rtcpFeedback: [{
        type: 'nack'
      }, {
        type: 'nack',
        parameter: 'pli'
      }, {
        type: 'ccm',
        parameter: 'fir'
      }, {
        type: 'goog-remb'
      }, {
        type: 'transport-cc'
      }],
      parameters: {
        'level-asymmetry-allowed': 1,
        'packetization-mode': 1,
        'profile-level-id': '42e01f'
      }
    }, {
      mimeType: 'video/rtx',
      kind: 'video',
      preferredPayloadType: 104,
      clockRate: 90000,
      rtcpFeedback: [],
      parameters: {
        apt: 103
      }
    }, {
      mimeType: 'video/VP9',
      kind: 'video',
      preferredPayloadType: 105,
      clockRate: 90000,
      rtcpFeedback: [{
        type: 'nack'
      }, {
        type: 'nack',
        parameter: 'pli'
      }, {
        type: 'ccm',
        parameter: 'fir'
      }, {
        type: 'goog-remb'
      }, {
        type: 'transport-cc'
      }],
      parameters: {
        'profile-id': 0,
        'x-google-start-bitrate': 1500
      }
    }, {
      mimeType: 'video/rtx',
      kind: 'video',
      preferredPayloadType: 106,
      clockRate: 90000,
      rtcpFeedback: [],
      parameters: {
        apt: 105
      }
    }],
    headerExtensions: [{
      kind: 'audio',
      uri: 'urn:ietf:params:rtp-hdrext:sdes:mid',
      preferredId: 1,
      preferredEncrypt: false,
      direction: 'sendrecv'
    }, {
      kind: 'video',
      uri: 'urn:ietf:params:rtp-hdrext:sdes:mid',
      preferredId: 1,
      preferredEncrypt: false,
      direction: 'sendrecv'
    }, {
      kind: 'video',
      uri: 'urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id',
      preferredId: 2,
      preferredEncrypt: false,
      direction: 'recvonly'
    }, {
      kind: 'video',
      uri: 'urn:ietf:params:rtp-hdrext:sdes:repaired-rtp-stream-id',
      preferredId: 3,
      preferredEncrypt: false,
      direction: 'recvonly'
    }, {
      kind: 'audio',
      uri: 'http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time',
      preferredId: 4,
      preferredEncrypt: false,
      direction: 'sendrecv'
    }, {
      kind: 'video',
      uri: 'http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time',
      preferredId: 4,
      preferredEncrypt: false,
      direction: 'sendrecv'
    }, {
      kind: 'audio',
      uri: 'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01',
      preferredId: 5,
      preferredEncrypt: false,
      direction: 'recvonly'
    }, {
      kind: 'video',
      uri: 'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01',
      preferredId: 5,
      preferredEncrypt: false,
      direction: 'sendrecv'
    }, {
      kind: 'video',
      uri: 'http://tools.ietf.org/html/draft-ietf-avtext-framemarking-07',
      preferredId: 6,
      preferredEncrypt: false,
      direction: 'sendrecv'
    }, {
      kind: 'video',
      uri: 'urn:ietf:params:rtp-hdrext:framemarking',
      preferredId: 7,
      preferredEncrypt: false,
      direction: 'sendrecv'
    }, {
      kind: 'audio',
      uri: 'urn:ietf:params:rtp-hdrext:ssrc-audio-level',
      preferredId: 10,
      preferredEncrypt: false,
      direction: 'sendrecv'
    }, {
      kind: 'video',
      uri: 'urn:3gpp:video-orientation',
      preferredId: 11,
      preferredEncrypt: false,
      direction: 'sendrecv'
    }, {
      kind: 'video',
      uri: 'urn:ietf:params:rtp-hdrext:toffset',
      preferredId: 12,
      preferredEncrypt: false,
      direction: 'sendrecv'
    }]
  });
}
function generateNativeRtpCapabilities() {
  return utils.deepFreeze({
    codecs: [{
      mimeType: 'audio/opus',
      kind: 'audio',
      preferredPayloadType: 111,
      clockRate: 48000,
      channels: 2,
      rtcpFeedback: [{
        type: 'transport-cc'
      }],
      parameters: {
        minptime: 10,
        useinbandfec: 1
      }
    }, {
      mimeType: 'audio/ISAC',
      kind: 'audio',
      preferredPayloadType: 103,
      clockRate: 16000,
      channels: 1,
      rtcpFeedback: [{
        type: 'transport-cc'
      }],
      parameters: {}
    }, {
      mimeType: 'audio/CN',
      kind: 'audio',
      preferredPayloadType: 106,
      clockRate: 32000,
      channels: 1,
      rtcpFeedback: [{
        type: 'transport-cc'
      }],
      parameters: {}
    }, {
      mimeType: 'video/VP8',
      kind: 'video',
      preferredPayloadType: 96,
      clockRate: 90000,
      rtcpFeedback: [{
        type: 'goog-remb'
      }, {
        type: 'transport-cc'
      }, {
        type: 'ccm',
        parameter: 'fir'
      }, {
        type: 'nack'
      }, {
        type: 'nack',
        parameter: 'pli'
      }],
      parameters: {
        baz: '1234abcd'
      }
    }, {
      mimeType: 'video/rtx',
      kind: 'video',
      preferredPayloadType: 97,
      clockRate: 90000,
      rtcpFeedback: [],
      parameters: {
        apt: 96
      }
    }, {
      mimeType: 'video/VP9',
      kind: 'video',
      preferredPayloadType: 98,
      clockRate: 90000,
      rtcpFeedback: [{
        type: 'goog-remb'
      }, {
        type: 'transport-cc'
      }, {
        type: 'ccm',
        parameter: 'fir'
      }, {
        type: 'nack'
      }, {
        type: 'nack',
        parameter: 'pli'
      }],
      parameters: {
        'profile-id': 0
      }
    }, {
      mimeType: 'video/rtx',
      kind: 'video',
      preferredPayloadType: 99,
      clockRate: 90000,
      rtcpFeedback: [],
      parameters: {
        apt: 98
      }
    }],
    headerExtensions: [{
      kind: 'audio',
      uri: 'urn:ietf:params:rtp-hdrext:sdes:mid',
      preferredId: 1
    }, {
      kind: 'video',
      uri: 'urn:ietf:params:rtp-hdrext:sdes:mid',
      preferredId: 1
    }, {
      kind: 'video',
      uri: 'urn:ietf:params:rtp-hdrext:toffset',
      preferredId: 2
    }, {
      kind: 'video',
      uri: 'http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time',
      preferredId: 3
    }, {
      kind: 'video',
      uri: 'urn:3gpp:video-orientation',
      preferredId: 4
    }, {
      kind: 'video',
      uri: 'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01',
      preferredId: 5
    }, {
      kind: 'video',
      uri: 'http://www.webrtc.org/experiments/rtp-hdrext/playout-delay',
      preferredId: 6
    }, {
      kind: 'video',
      // @ts-expect-error --- ON purpose.
      uri: 'http://www.webrtc.org/experiments/rtp-hdrext/video-content-type',
      preferredId: 7
    }, {
      kind: 'video',
      // @ts-expect-error --- ON purpose.
      uri: 'http://www.webrtc.org/experiments/rtp-hdrext/video-timing',
      preferredId: 8
    }, {
      kind: 'audio',
      uri: 'urn:ietf:params:rtp-hdrext:ssrc-audio-level',
      preferredId: 10
    }]
  });
}
function generateNativeSctpCapabilities() {
  return utils.deepFreeze({
    numStreams: {
      OS: 2048,
      MIS: 2048
    }
  });
}
function generateLocalDtlsParameters() {
  return utils.deepFreeze({
    fingerprints: [{
      algorithm: 'sha-256',
      value: '82:5A:68:3D:36:C3:0A:DE:AF:E7:32:43:D2:88:83:57:AC:2D:65:E5:80:C4:B6:FB:AF:1A:A0:21:9F:6D:0C:AD'
    }],
    role: 'auto'
  });
}
function generateTransportRemoteParameters() {
  return {
    id: generateFakeUuid(),
    iceParameters: utils.deepFreeze({
      iceLite: true,
      password: 'yku5ej8nvfaor28lvtrabcx0wkrpkztz',
      usernameFragment: 'h3hk1iz6qqlnqlne'
    }),
    iceCandidates: utils.deepFreeze([{
      foundation: 'udpcandidate',
      address: '9.9.9.9',
      ip: '9.9.9.9',
      port: 40533,
      priority: 1078862079,
      protocol: 'udp',
      type: 'host',
      tcpType: 'passive'
    }, {
      foundation: 'udpcandidate',
      address: '9.9.9.9',
      ip: '9:9:9:9:9:9',
      port: 41333,
      priority: 1078862089,
      protocol: 'udp',
      type: 'host',
      tcpType: 'passive'
    }]),
    dtlsParameters: utils.deepFreeze({
      fingerprints: [{
        algorithm: 'sha-256',
        value: 'A9:F4:E0:D2:74:D3:0F:D9:CA:A5:2F:9F:7F:47:FA:F0:C4:72:DD:73:49:D0:3B:14:90:20:51:30:1B:90:8E:71'
      }, {
        algorithm: 'sha-384',
        value: '03:D9:0B:87:13:98:F6:6D:BC:FC:92:2E:39:D4:E1:97:32:61:30:56:84:70:81:6E:D1:82:97:EA:D9:C1:21:0F:6B:C5:E7:7F:E1:97:0C:17:97:6E:CF:B3:EF:2E:74:B0'
      }, {
        algorithm: 'sha-512',
        value: '84:27:A4:28:A4:73:AF:43:02:2A:44:68:FF:2F:29:5C:3B:11:9A:60:F4:A8:F0:F5:AC:A0:E3:49:3E:B1:34:53:A9:85:CE:51:9B:ED:87:5E:B8:F4:8E:3D:FA:20:51:B8:96:EE:DA:56:DC:2F:5C:62:79:15:23:E0:21:82:2B:2C'
      }],
      role: 'auto'
    }),
    sctpParameters: utils.deepFreeze({
      port: 5000,
      OS: 2048,
      MIS: 2048,
      maxMessageSize: 2000000
    })
  };
}
function generateProducerRemoteParameters() {
  return utils.deepFreeze({
    id: generateFakeUuid()
  });
}
function generateConsumerRemoteParameters() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
    id = _ref.id,
    codecMimeType = _ref.codecMimeType;
  switch (codecMimeType) {
    case 'audio/opus':
      {
        return {
          id: id !== null && id !== void 0 ? id : generateFakeUuid(),
          producerId: generateFakeUuid(),
          kind: 'audio',
          rtpParameters: utils.deepFreeze({
            codecs: [{
              mimeType: 'audio/opus',
              payloadType: 100,
              clockRate: 48000,
              channels: 2,
              rtcpFeedback: [{
                type: 'transport-cc'
              }],
              parameters: {
                useinbandfec: 1,
                foo: 'bar'
              }
            }],
            encodings: [{
              ssrc: 46687003
            }],
            headerExtensions: [{
              uri: 'urn:ietf:params:rtp-hdrext:sdes:mid',
              id: 1
            }, {
              uri: 'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01',
              id: 5
            }, {
              uri: 'urn:ietf:params:rtp-hdrext:ssrc-audio-level',
              id: 10
            }],
            rtcp: {
              cname: 'wB4Ql4lrsxYLjzuN',
              reducedSize: true,
              mux: true
            }
          })
        };
      }
    case 'audio/ISAC':
      {
        return {
          id: id !== null && id !== void 0 ? id : generateFakeUuid(),
          producerId: generateFakeUuid(),
          kind: 'audio',
          rtpParameters: utils.deepFreeze({
            codecs: [{
              mimeType: 'audio/ISAC',
              payloadType: 111,
              clockRate: 16000,
              channels: 1,
              rtcpFeedback: [{
                type: 'transport-cc'
              }],
              parameters: {}
            }],
            encodings: [{
              ssrc: 46687004
            }],
            headerExtensions: [{
              uri: 'urn:ietf:params:rtp-hdrext:sdes:mid',
              id: 1
            }, {
              uri: 'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01',
              id: 5
            }],
            rtcp: {
              cname: 'wB4Ql4lrsxYLjzuN',
              reducedSize: true,
              mux: true
            }
          })
        };
      }
    case 'video/VP8':
      {
        return {
          id: id !== null && id !== void 0 ? id : generateFakeUuid(),
          producerId: generateFakeUuid(),
          kind: 'video',
          rtpParameters: utils.deepFreeze({
            codecs: [{
              mimeType: 'video/VP8',
              payloadType: 101,
              clockRate: 90000,
              rtcpFeedback: [{
                type: 'nack'
              }, {
                type: 'nack',
                parameter: 'pli'
              }, {
                type: 'ccm',
                parameter: 'fir'
              }, {
                type: 'goog-remb'
              }, {
                type: 'transport-cc'
              }],
              parameters: {
                'x-google-start-bitrate': 1500
              }
            }, {
              mimeType: 'video/rtx',
              payloadType: 102,
              clockRate: 90000,
              rtcpFeedback: [],
              parameters: {
                apt: 101
              }
            }],
            encodings: [{
              ssrc: 99991111,
              rtx: {
                ssrc: 99991112
              }
            }],
            headerExtensions: [{
              uri: 'urn:ietf:params:rtp-hdrext:sdes:mid',
              id: 1
            }, {
              uri: 'http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time',
              id: 4
            }, {
              uri: 'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01',
              id: 5
            }, {
              uri: 'urn:3gpp:video-orientation',
              id: 11
            }, {
              uri: 'urn:ietf:params:rtp-hdrext:toffset',
              id: 12
            }],
            rtcp: {
              cname: 'wB4Ql4lrsxYLjzuN',
              reducedSize: true,
              mux: true
            }
          })
        };
      }
    case 'video/H264':
      {
        return {
          id: id !== null && id !== void 0 ? id : generateFakeUuid(),
          producerId: generateFakeUuid(),
          kind: 'video',
          rtpParameters: utils.deepFreeze({
            codecs: [{
              mimeType: 'video/H264',
              payloadType: 103,
              clockRate: 90000,
              rtcpFeedback: [{
                type: 'nack'
              }, {
                type: 'nack',
                parameter: 'pli'
              }, {
                type: 'ccm',
                parameter: 'fir'
              }, {
                type: 'goog-remb'
              }, {
                type: 'transport-cc'
              }],
              parameters: {
                'level-asymmetry-allowed': 1,
                'packetization-mode': 1,
                'profile-level-id': '42e01f'
              }
            }, {
              mimeType: 'video/rtx',
              payloadType: 104,
              clockRate: 90000,
              rtcpFeedback: [],
              parameters: {
                apt: 103
              }
            }],
            encodings: [{
              ssrc: 99991113,
              rtx: {
                ssrc: 99991114
              }
            }],
            headerExtensions: [{
              uri: 'urn:ietf:params:rtp-hdrext:sdes:mid',
              id: 1
            }, {
              uri: 'http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time',
              id: 4
            }, {
              uri: 'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01',
              id: 5
            }, {
              uri: 'urn:3gpp:video-orientation',
              id: 11
            }, {
              uri: 'urn:ietf:params:rtp-hdrext:toffset',
              id: 12
            }],
            rtcp: {
              cname: 'wB4Ql4lrsxYLjzuN',
              reducedSize: true,
              mux: true
            }
          })
        };
      }
    default:
      {
        throw new TypeError("unknown codecMimeType '".concat(codecMimeType, "'"));
      }
  }
}
function generateDataProducerRemoteParameters() {
  return utils.deepFreeze({
    id: generateFakeUuid()
  });
}
function generateDataConsumerRemoteParameters() {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
    id = _ref2.id;
  return {
    id: id !== null && id !== void 0 ? id : generateFakeUuid(),
    dataProducerId: generateFakeUuid(),
    sctpStreamParameters: utils.deepFreeze({
      streamId: 666,
      maxPacketLifeTime: 5000,
      maxRetransmits: undefined
    })
  };
}

},{"../utils":72}],71:[function(require,module,exports){
"use strict";

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __exportStar = void 0 && (void 0).__exportStar || function (m, exports) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
__exportStar(require("./Device"), exports);
__exportStar(require("./Transport"), exports);
__exportStar(require("./Producer"), exports);
__exportStar(require("./Consumer"), exports);
__exportStar(require("./DataProducer"), exports);
__exportStar(require("./DataConsumer"), exports);
__exportStar(require("./RtpParameters"), exports);
__exportStar(require("./SctpParameters"), exports);
__exportStar(require("./handlers/HandlerInterface"), exports);
__exportStar(require("./errors"), exports);

},{"./Consumer":35,"./DataConsumer":36,"./DataProducer":37,"./Device":38,"./Producer":40,"./RtpParameters":41,"./SctpParameters":42,"./Transport":43,"./errors":45,"./handlers/HandlerInterface":55}],72:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clone = clone;
exports.generateRandomNumber = generateRandomNumber;
exports.deepFreeze = deepFreeze;
/**
 * Clones the given value.
 */
function clone(value) {
  if (value === undefined) {
    return undefined;
  } else if (Number.isNaN(value)) {
    return NaN;
  } else if (typeof structuredClone === 'function') {
    // Available in Node >= 18.
    return structuredClone(value);
  } else {
    return JSON.parse(JSON.stringify(value));
  }
}
/**
 * Generates a random positive integer.
 */
function generateRandomNumber() {
  return Math.round(Math.random() * 10000000);
}
/**
 * Make an object or array recursively immutable.
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze.
 */
function deepFreeze(object) {
  // Retrieve the property names defined on object.
  var propNames = Reflect.ownKeys(object);
  // Freeze properties before freezing self.
  var _iterator = _createForOfIteratorHelper(propNames),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var name = _step.value;
      var value = object[name];
      if (value && _typeof(value) === 'object' || typeof value === 'function') {
        deepFreeze(value);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return Object.freeze(object);
}

},{}],73:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {};
  var type = _typeof(val);
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options["long"] ? fmtLong(val) : fmtShort(val);
  }
  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

},{}],74:[function(require,module,exports){
"use strict";

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}
(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  }
  // if setTimeout wasn't available but was latter defined
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  }
  // if clearTimeout wasn't available but was latter defined
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
};

// v8 likes predictible objects
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};
function noop() {}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function (name) {
  return [];
};
process.binding = function (name) {
  throw new Error('process.binding is not supported');
};
process.cwd = function () {
  return '/';
};
process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};
process.umask = function () {
  return 0;
};

},{}],75:[function(require,module,exports){
"use strict";

var grammar = module.exports = {
  v: [{
    name: 'version',
    reg: /^(\d*)$/
  }],
  o: [{
    // o=- 20518 0 IN IP4 203.0.113.1
    // NB: sessionId will be a String in most cases because it is huge
    name: 'origin',
    reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
    names: ['username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address'],
    format: '%s %s %d %s IP%d %s'
  }],
  // default parsing of these only (though some of these feel outdated)
  s: [{
    name: 'name'
  }],
  i: [{
    name: 'description'
  }],
  u: [{
    name: 'uri'
  }],
  e: [{
    name: 'email'
  }],
  p: [{
    name: 'phone'
  }],
  z: [{
    name: 'timezones'
  }],
  // TODO: this one can actually be parsed properly...
  r: [{
    name: 'repeats'
  }],
  // TODO: this one can also be parsed properly
  // k: [{}], // outdated thing ignored
  t: [{
    // t=0 0
    name: 'timing',
    reg: /^(\d*) (\d*)/,
    names: ['start', 'stop'],
    format: '%d %d'
  }],
  c: [{
    // c=IN IP4 10.47.197.26
    name: 'connection',
    reg: /^IN IP(\d) (\S*)/,
    names: ['version', 'ip'],
    format: 'IN IP%d %s'
  }],
  b: [{
    // b=AS:4000
    push: 'bandwidth',
    reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
    names: ['type', 'limit'],
    format: '%s:%s'
  }],
  m: [{
    // m=video 51744 RTP/AVP 126 97 98 34 31
    // NB: special - pushes to session
    // TODO: rtp/fmtp should be filtered by the payloads found here?
    reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/,
    names: ['type', 'port', 'protocol', 'payloads'],
    format: '%s %d %s %s'
  }],
  a: [{
    // a=rtpmap:110 opus/48000/2
    push: 'rtp',
    reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
    names: ['payload', 'codec', 'rate', 'encoding'],
    format: function format(o) {
      return o.encoding ? 'rtpmap:%d %s/%s/%s' : o.rate ? 'rtpmap:%d %s/%s' : 'rtpmap:%d %s';
    }
  }, {
    // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000
    // a=fmtp:111 minptime=10; useinbandfec=1
    push: 'fmtp',
    reg: /^fmtp:(\d*) ([\S| ]*)/,
    names: ['payload', 'config'],
    format: 'fmtp:%d %s'
  }, {
    // a=control:streamid=0
    name: 'control',
    reg: /^control:(.*)/,
    format: 'control:%s'
  }, {
    // a=rtcp:65179 IN IP4 193.84.77.194
    name: 'rtcp',
    reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
    names: ['port', 'netType', 'ipVer', 'address'],
    format: function format(o) {
      return o.address != null ? 'rtcp:%d %s IP%d %s' : 'rtcp:%d';
    }
  }, {
    // a=rtcp-fb:98 trr-int 100
    push: 'rtcpFbTrrInt',
    reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
    names: ['payload', 'value'],
    format: 'rtcp-fb:%s trr-int %d'
  }, {
    // a=rtcp-fb:98 nack rpsi
    push: 'rtcpFb',
    reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
    names: ['payload', 'type', 'subtype'],
    format: function format(o) {
      return o.subtype != null ? 'rtcp-fb:%s %s %s' : 'rtcp-fb:%s %s';
    }
  }, {
    // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
    // a=extmap:1/recvonly URI-gps-string
    // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24
    push: 'ext',
    reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/,
    names: ['value', 'direction', 'encrypt-uri', 'uri', 'config'],
    format: function format(o) {
      return 'extmap:%d' + (o.direction ? '/%s' : '%v') + (o['encrypt-uri'] ? ' %s' : '%v') + ' %s' + (o.config ? ' %s' : '');
    }
  }, {
    // a=extmap-allow-mixed
    name: 'extmapAllowMixed',
    reg: /^(extmap-allow-mixed)/
  }, {
    // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32
    push: 'crypto',
    reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
    names: ['id', 'suite', 'config', 'sessionConfig'],
    format: function format(o) {
      return o.sessionConfig != null ? 'crypto:%d %s %s %s' : 'crypto:%d %s %s';
    }
  }, {
    // a=setup:actpass
    name: 'setup',
    reg: /^setup:(\w*)/,
    format: 'setup:%s'
  }, {
    // a=connection:new
    name: 'connectionType',
    reg: /^connection:(new|existing)/,
    format: 'connection:%s'
  }, {
    // a=mid:1
    name: 'mid',
    reg: /^mid:([^\s]*)/,
    format: 'mid:%s'
  }, {
    // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a
    name: 'msid',
    reg: /^msid:(.*)/,
    format: 'msid:%s'
  }, {
    // a=ptime:20
    name: 'ptime',
    reg: /^ptime:(\d*(?:\.\d*)*)/,
    format: 'ptime:%d'
  }, {
    // a=maxptime:60
    name: 'maxptime',
    reg: /^maxptime:(\d*(?:\.\d*)*)/,
    format: 'maxptime:%d'
  }, {
    // a=sendrecv
    name: 'direction',
    reg: /^(sendrecv|recvonly|sendonly|inactive)/
  }, {
    // a=ice-lite
    name: 'icelite',
    reg: /^(ice-lite)/
  }, {
    // a=ice-ufrag:F7gI
    name: 'iceUfrag',
    reg: /^ice-ufrag:(\S*)/,
    format: 'ice-ufrag:%s'
  }, {
    // a=ice-pwd:x9cml/YzichV2+XlhiMu8g
    name: 'icePwd',
    reg: /^ice-pwd:(\S*)/,
    format: 'ice-pwd:%s'
  }, {
    // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33
    name: 'fingerprint',
    reg: /^fingerprint:(\S*) (\S*)/,
    names: ['type', 'hash'],
    format: 'fingerprint:%s %s'
  }, {
    // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host
    // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10
    // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10
    // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10
    // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10
    push: 'candidates',
    reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
    names: ['foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'tcptype', 'generation', 'network-id', 'network-cost'],
    format: function format(o) {
      var str = 'candidate:%s %d %s %d %s %d typ %s';
      str += o.raddr != null ? ' raddr %s rport %d' : '%v%v';

      // NB: candidate has three optional chunks, so %void middles one if it's missing
      str += o.tcptype != null ? ' tcptype %s' : '%v';
      if (o.generation != null) {
        str += ' generation %d';
      }
      str += o['network-id'] != null ? ' network-id %d' : '%v';
      str += o['network-cost'] != null ? ' network-cost %d' : '%v';
      return str;
    }
  }, {
    // a=end-of-candidates (keep after the candidates line for readability)
    name: 'endOfCandidates',
    reg: /^(end-of-candidates)/
  }, {
    // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...
    name: 'remoteCandidates',
    reg: /^remote-candidates:(.*)/,
    format: 'remote-candidates:%s'
  }, {
    // a=ice-options:google-ice
    name: 'iceOptions',
    reg: /^ice-options:(\S*)/,
    format: 'ice-options:%s'
  }, {
    // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1
    push: 'ssrcs',
    reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/,
    names: ['id', 'attribute', 'value'],
    format: function format(o) {
      var str = 'ssrc:%d';
      if (o.attribute != null) {
        str += ' %s';
        if (o.value != null) {
          str += ':%s';
        }
      }
      return str;
    }
  }, {
    // a=ssrc-group:FEC 1 2
    // a=ssrc-group:FEC-FR 3004364195 1080772241
    push: 'ssrcGroups',
    // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E
    reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
    names: ['semantics', 'ssrcs'],
    format: 'ssrc-group:%s %s'
  }, {
    // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV
    name: 'msidSemantic',
    reg: /^msid-semantic:\s?(\w*) (\S*)/,
    names: ['semantic', 'token'],
    format: 'msid-semantic: %s %s' // space after ':' is not accidental
  }, {
    // a=group:BUNDLE audio video
    push: 'groups',
    reg: /^group:(\w*) (.*)/,
    names: ['type', 'mids'],
    format: 'group:%s %s'
  }, {
    // a=rtcp-mux
    name: 'rtcpMux',
    reg: /^(rtcp-mux)/
  }, {
    // a=rtcp-rsize
    name: 'rtcpRsize',
    reg: /^(rtcp-rsize)/
  }, {
    // a=sctpmap:5000 webrtc-datachannel 1024
    name: 'sctpmap',
    reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/,
    names: ['sctpmapNumber', 'app', 'maxMessageSize'],
    format: function format(o) {
      return o.maxMessageSize != null ? 'sctpmap:%s %s %s' : 'sctpmap:%s %s';
    }
  }, {
    // a=x-google-flag:conference
    name: 'xGoogleFlag',
    reg: /^x-google-flag:([^\s]*)/,
    format: 'x-google-flag:%s'
  }, {
    // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0
    push: 'rids',
    reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
    names: ['id', 'direction', 'params'],
    format: function format(o) {
      return o.params ? 'rid:%s %s %s' : 'rid:%s %s';
    }
  }, {
    // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]
    // a=imageattr:* send [x=800,y=640] recv *
    // a=imageattr:100 recv [x=320,y=240]
    push: 'imageattrs',
    reg: new RegExp(
    // a=imageattr:97
    '^imageattr:(\\d+|\\*)' +
    // send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320]
    '[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)' +
    // recv [x=330,y=250]
    '(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?'),
    names: ['pt', 'dir1', 'attrs1', 'dir2', 'attrs2'],
    format: function format(o) {
      return 'imageattr:%s %s %s' + (o.dir2 ? ' %s %s' : '');
    }
  }, {
    // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8
    // a=simulcast:recv 1;4,5 send 6;7
    name: 'simulcast',
    reg: new RegExp(
    // a=simulcast:
    '^simulcast:' +
    // send 1,2,3;~4,~5
    '(send|recv) ([a-zA-Z0-9\\-_~;,]+)' +
    // space + recv 6;~7,~8
    '(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?' +
    // end
    '$'),
    names: ['dir1', 'list1', 'dir2', 'list2'],
    format: function format(o) {
      return 'simulcast:%s %s' + (o.dir2 ? ' %s %s' : '');
    }
  }, {
    // old simulcast draft 03 (implemented by Firefox)
    //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03
    // a=simulcast: recv pt=97;98 send pt=97
    // a=simulcast: send rid=5;6;7 paused=6,7
    name: 'simulcast_03',
    reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
    names: ['value'],
    format: 'simulcast: %s'
  }, {
    // a=framerate:25
    // a=framerate:29.97
    name: 'framerate',
    reg: /^framerate:(\d+(?:$|\.\d+))/,
    format: 'framerate:%s'
  }, {
    // RFC4570
    // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5
    name: 'sourceFilter',
    reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/,
    names: ['filterMode', 'netType', 'addressTypes', 'destAddress', 'srcList'],
    format: 'source-filter: %s %s %s %s %s'
  }, {
    // a=bundle-only
    name: 'bundleOnly',
    reg: /^(bundle-only)/
  }, {
    // a=label:1
    name: 'label',
    reg: /^label:(.+)/,
    format: 'label:%s'
  }, {
    // RFC version 26 for SCTP over DTLS
    // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5
    name: 'sctpPort',
    reg: /^sctp-port:(\d+)$/,
    format: 'sctp-port:%s'
  }, {
    // RFC version 26 for SCTP over DTLS
    // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6
    name: 'maxMessageSize',
    reg: /^max-message-size:(\d+)$/,
    format: 'max-message-size:%s'
  }, {
    // RFC7273
    // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37
    push: 'tsRefClocks',
    reg: /^ts-refclk:([^\s=]*)(?:=(\S*))?/,
    names: ['clksrc', 'clksrcExt'],
    format: function format(o) {
      return 'ts-refclk:%s' + (o.clksrcExt != null ? '=%s' : '');
    }
  }, {
    // RFC7273
    // a=mediaclk:direct=963214424
    name: 'mediaClk',
    reg: /^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/,
    names: ['id', 'mediaClockName', 'mediaClockValue', 'rateNumerator', 'rateDenominator'],
    format: function format(o) {
      var str = 'mediaclk:';
      str += o.id != null ? 'id=%s %s' : '%v%s';
      str += o.mediaClockValue != null ? '=%s' : '';
      str += o.rateNumerator != null ? ' rate=%s' : '';
      str += o.rateDenominator != null ? '/%s' : '';
      return str;
    }
  }, {
    // a=keywds:keywords
    name: 'keywords',
    reg: /^keywds:(.+)$/,
    format: 'keywds:%s'
  }, {
    // a=content:main
    name: 'content',
    reg: /^content:(.+)/,
    format: 'content:%s'
  },
  // BFCP https://tools.ietf.org/html/rfc4583
  {
    // a=floorctrl:c-s
    name: 'bfcpFloorCtrl',
    reg: /^floorctrl:(c-only|s-only|c-s)/,
    format: 'floorctrl:%s'
  }, {
    // a=confid:1
    name: 'bfcpConfId',
    reg: /^confid:(\d+)/,
    format: 'confid:%s'
  }, {
    // a=userid:1
    name: 'bfcpUserId',
    reg: /^userid:(\d+)/,
    format: 'userid:%s'
  }, {
    // a=floorid:1
    name: 'bfcpFloorId',
    reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,
    names: ['id', 'mStream'],
    format: 'floorid:%s mstrm:%s'
  }, {
    // any a= that we don't understand is kept verbatim on media.invalid
    push: 'invalid',
    names: ['value']
  }]
};

// set sensible defaults to avoid polluting the grammar with boring details
Object.keys(grammar).forEach(function (key) {
  var objs = grammar[key];
  objs.forEach(function (obj) {
    if (!obj.reg) {
      obj.reg = /(.*)/;
    }
    if (!obj.format) {
      obj.format = '%s';
    }
  });
});

},{}],76:[function(require,module,exports){
"use strict";

var parser = require('./parser');
var writer = require('./writer');
var grammar = require('./grammar');
exports.grammar = grammar;
exports.write = writer;
exports.parse = parser.parse;
exports.parseParams = parser.parseParams;
exports.parseFmtpConfig = parser.parseFmtpConfig; // Alias of parseParams().
exports.parsePayloads = parser.parsePayloads;
exports.parseRemoteCandidates = parser.parseRemoteCandidates;
exports.parseImageAttributes = parser.parseImageAttributes;
exports.parseSimulcastStreamList = parser.parseSimulcastStreamList;

},{"./grammar":75,"./parser":77,"./writer":78}],77:[function(require,module,exports){
"use strict";

var toIntIfInt = function toIntIfInt(v) {
  return String(Number(v)) === v ? Number(v) : v;
};
var attachProperties = function attachProperties(match, location, names, rawName) {
  if (rawName && !names) {
    location[rawName] = toIntIfInt(match[1]);
  } else {
    for (var i = 0; i < names.length; i += 1) {
      if (match[i + 1] != null) {
        location[names[i]] = toIntIfInt(match[i + 1]);
      }
    }
  }
};
var parseReg = function parseReg(obj, location, content) {
  var needsBlank = obj.name && obj.names;
  if (obj.push && !location[obj.push]) {
    location[obj.push] = [];
  } else if (needsBlank && !location[obj.name]) {
    location[obj.name] = {};
  }
  var keyLocation = obj.push ? {} :
  // blank object that will be pushed
  needsBlank ? location[obj.name] : location; // otherwise, named location or root

  attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);
  if (obj.push) {
    location[obj.push].push(keyLocation);
  }
};
var grammar = require('./grammar');
var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
exports.parse = function (sdp) {
  var session = {},
    media = [],
    location = session; // points at where properties go under (one of the above)

  // parse lines we understand
  sdp.split(/(\r\n|\r|\n)/).filter(validLine).forEach(function (l) {
    var type = l[0];
    var content = l.slice(2);
    if (type === 'm') {
      media.push({
        rtp: [],
        fmtp: []
      });
      location = media[media.length - 1]; // point at latest media line
    }
    for (var j = 0; j < (grammar[type] || []).length; j += 1) {
      var obj = grammar[type][j];
      if (obj.reg.test(content)) {
        return parseReg(obj, location, content);
      }
    }
  });
  session.media = media; // link it up
  return session;
};
var paramReducer = function paramReducer(acc, expr) {
  var s = expr.split(/=(.+)/, 2);
  if (s.length === 2) {
    acc[s[0]] = toIntIfInt(s[1]);
  } else if (s.length === 1 && expr.length > 1) {
    acc[s[0]] = undefined;
  }
  return acc;
};
exports.parseParams = function (str) {
  return str.split(/;\s?/).reduce(paramReducer, {});
};

// For backward compatibility - alias will be removed in 3.0.0
exports.parseFmtpConfig = exports.parseParams;
exports.parsePayloads = function (str) {
  return str.toString().split(' ').map(Number);
};
exports.parseRemoteCandidates = function (str) {
  var candidates = [];
  var parts = str.split(' ').map(toIntIfInt);
  for (var i = 0; i < parts.length; i += 3) {
    candidates.push({
      component: parts[i],
      ip: parts[i + 1],
      port: parts[i + 2]
    });
  }
  return candidates;
};
exports.parseImageAttributes = function (str) {
  return str.split(' ').map(function (item) {
    return item.substring(1, item.length - 1).split(',').reduce(paramReducer, {});
  });
};
exports.parseSimulcastStreamList = function (str) {
  return str.split(';').map(function (stream) {
    return stream.split(',').map(function (format) {
      var scid,
        paused = false;
      if (format[0] !== '~') {
        scid = toIntIfInt(format);
      } else {
        scid = toIntIfInt(format.substring(1, format.length));
        paused = true;
      }
      return {
        scid: scid,
        paused: paused
      };
    });
  });
};

},{"./grammar":75}],78:[function(require,module,exports){
"use strict";

var grammar = require('./grammar');

// customized util.format - discards excess arguments and can void middle ones
var formatRegExp = /%[sdv%]/g;
var format = function format(formatStr) {
  var i = 1;
  var args = arguments;
  var len = args.length;
  return formatStr.replace(formatRegExp, function (x) {
    if (i >= len) {
      return x; // missing argument
    }
    var arg = args[i];
    i += 1;
    switch (x) {
      case '%%':
        return '%';
      case '%s':
        return String(arg);
      case '%d':
        return Number(arg);
      case '%v':
        return '';
    }
  });
  // NB: we discard excess arguments - they are typically undefined from makeLine
};
var makeLine = function makeLine(type, obj, location) {
  var str = obj.format instanceof Function ? obj.format(obj.push ? location : location[obj.name]) : obj.format;
  var args = [type + '=' + str];
  if (obj.names) {
    for (var i = 0; i < obj.names.length; i += 1) {
      var n = obj.names[i];
      if (obj.name) {
        args.push(location[obj.name][n]);
      } else {
        // for mLine and push attributes
        args.push(location[obj.names[i]]);
      }
    }
  } else {
    args.push(location[obj.name]);
  }
  return format.apply(null, args);
};

// RFC specified order
// TODO: extend this with all the rest
var defaultOuterOrder = ['v', 'o', 's', 'i', 'u', 'e', 'p', 'c', 'b', 't', 'r', 'z', 'a'];
var defaultInnerOrder = ['i', 'c', 'b', 'a'];
module.exports = function (session, opts) {
  opts = opts || {};
  // ensure certain properties exist
  if (session.version == null) {
    session.version = 0; // 'v=0' must be there (only defined version atm)
  }
  if (session.name == null) {
    session.name = ' '; // 's= ' must be there if no meaningful name set
  }
  session.media.forEach(function (mLine) {
    if (mLine.payloads == null) {
      mLine.payloads = '';
    }
  });
  var outerOrder = opts.outerOrder || defaultOuterOrder;
  var innerOrder = opts.innerOrder || defaultInnerOrder;
  var sdp = [];

  // loop through outerOrder for matching properties on session
  outerOrder.forEach(function (type) {
    grammar[type].forEach(function (obj) {
      if (obj.name in session && session[obj.name] != null) {
        sdp.push(makeLine(type, obj, session));
      } else if (obj.push in session && session[obj.push] != null) {
        session[obj.push].forEach(function (el) {
          sdp.push(makeLine(type, obj, el));
        });
      }
    });
  });

  // then for each media line, follow the innerOrder
  session.media.forEach(function (mLine) {
    sdp.push(makeLine('m', grammar.m[0], mLine));
    innerOrder.forEach(function (type) {
      grammar[type].forEach(function (obj) {
        if (obj.name in mLine && mLine[obj.name] != null) {
          sdp.push(makeLine(type, obj, mLine));
        } else if (obj.push in mLine && mLine[obj.push] != null) {
          mLine[obj.push].forEach(function (el) {
            sdp.push(makeLine(type, obj, el));
          });
        }
      });
    });
  });
  return sdp.join('\r\n') + '\r\n';
};

},{"./grammar":75}],79:[function(require,module,exports){
"use strict";

/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Backoff = Backoff;
function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}
/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */
Backoff.prototype.duration = function () {
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand = Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};
/**
 * Reset the number of attempts.
 *
 * @api public
 */
Backoff.prototype.reset = function () {
  this.attempts = 0;
};
/**
 * Set the minimum duration
 *
 * @api public
 */
Backoff.prototype.setMin = function (min) {
  this.ms = min;
};
/**
 * Set the maximum duration
 *
 * @api public
 */
Backoff.prototype.setMax = function (max) {
  this.max = max;
};
/**
 * Set the jitter
 *
 * @api public
 */
Backoff.prototype.setJitter = function (jitter) {
  this.jitter = jitter;
};

},{}],80:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WebTransport = exports.WebSocket = exports.NodeWebSocket = exports.XHR = exports.NodeXHR = exports.Fetch = exports.Socket = exports.Manager = exports.protocol = void 0;
exports.io = lookup;
exports.connect = lookup;
exports["default"] = lookup;
var url_js_1 = require("./url.js");
var manager_js_1 = require("./manager.js");
Object.defineProperty(exports, "Manager", {
  enumerable: true,
  get: function get() {
    return manager_js_1.Manager;
  }
});
var socket_js_1 = require("./socket.js");
Object.defineProperty(exports, "Socket", {
  enumerable: true,
  get: function get() {
    return socket_js_1.Socket;
  }
});
var debug_1 = __importDefault(require("debug")); // debug()
var debug = (0, debug_1["default"])("socket.io-client"); // debug()
/**
 * Managers cache.
 */
var cache = {};
function lookup(uri, opts) {
  if (_typeof(uri) === "object") {
    opts = uri;
    uri = undefined;
  }
  opts = opts || {};
  var parsed = (0, url_js_1.url)(uri, opts.path || "/socket.io");
  var source = parsed.source;
  var id = parsed.id;
  var path = parsed.path;
  var sameNamespace = cache[id] && path in cache[id]["nsps"];
  var newConnection = opts.forceNew || opts["force new connection"] || false === opts.multiplex || sameNamespace;
  var io;
  if (newConnection) {
    debug("ignoring socket cache for %s", source);
    io = new manager_js_1.Manager(source, opts);
  } else {
    if (!cache[id]) {
      debug("new io instance for %s", source);
      cache[id] = new manager_js_1.Manager(source, opts);
    }
    io = cache[id];
  }
  if (parsed.query && !opts.query) {
    opts.query = parsed.queryKey;
  }
  return io.socket(parsed.path, opts);
}
// so that "lookup" can be used both as a function (e.g. `io(...)`) and as a
// namespace (e.g. `io.connect(...)`), for backward compatibility
Object.assign(lookup, {
  Manager: manager_js_1.Manager,
  Socket: socket_js_1.Socket,
  io: lookup,
  connect: lookup
});
/**
 * Protocol version.
 *
 * @public
 */
var socket_io_parser_1 = require("socket.io-parser");
Object.defineProperty(exports, "protocol", {
  enumerable: true,
  get: function get() {
    return socket_io_parser_1.protocol;
  }
});
var engine_io_client_1 = require("engine.io-client");
Object.defineProperty(exports, "Fetch", {
  enumerable: true,
  get: function get() {
    return engine_io_client_1.Fetch;
  }
});
Object.defineProperty(exports, "NodeXHR", {
  enumerable: true,
  get: function get() {
    return engine_io_client_1.NodeXHR;
  }
});
Object.defineProperty(exports, "XHR", {
  enumerable: true,
  get: function get() {
    return engine_io_client_1.XHR;
  }
});
Object.defineProperty(exports, "NodeWebSocket", {
  enumerable: true,
  get: function get() {
    return engine_io_client_1.NodeWebSocket;
  }
});
Object.defineProperty(exports, "WebSocket", {
  enumerable: true,
  get: function get() {
    return engine_io_client_1.WebSocket;
  }
});
Object.defineProperty(exports, "WebTransport", {
  enumerable: true,
  get: function get() {
    return engine_io_client_1.WebTransport;
  }
});
module.exports = lookup;

},{"./manager.js":81,"./socket.js":83,"./url.js":84,"debug":85,"engine.io-client":12,"socket.io-parser":88}],81:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Manager = void 0;
var engine_io_client_1 = require("engine.io-client");
var socket_js_1 = require("./socket.js");
var parser = __importStar(require("socket.io-parser"));
var on_js_1 = require("./on.js");
var backo2_js_1 = require("./contrib/backo2.js");
var component_emitter_1 = require("@socket.io/component-emitter");
var debug_1 = __importDefault(require("debug")); // debug()
var debug = (0, debug_1["default"])("socket.io-client:manager"); // debug()
var Manager = /*#__PURE__*/function (_component_emitter_1$) {
  function Manager(uri, opts) {
    var _this;
    _classCallCheck(this, Manager);
    var _a;
    _this = _callSuper(this, Manager);
    _this.nsps = {};
    _this.subs = [];
    if (uri && "object" === _typeof(uri)) {
      opts = uri;
      uri = undefined;
    }
    opts = opts || {};
    opts.path = opts.path || "/socket.io";
    _this.opts = opts;
    (0, engine_io_client_1.installTimerFunctions)(_this, opts);
    _this.reconnection(opts.reconnection !== false);
    _this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
    _this.reconnectionDelay(opts.reconnectionDelay || 1000);
    _this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
    _this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);
    _this.backoff = new backo2_js_1.Backoff({
      min: _this.reconnectionDelay(),
      max: _this.reconnectionDelayMax(),
      jitter: _this.randomizationFactor()
    });
    _this.timeout(null == opts.timeout ? 20000 : opts.timeout);
    _this._readyState = "closed";
    _this.uri = uri;
    var _parser = opts.parser || parser;
    _this.encoder = new _parser.Encoder();
    _this.decoder = new _parser.Decoder();
    _this._autoConnect = opts.autoConnect !== false;
    if (_this._autoConnect) _this.open();
    return _this;
  }
  _inherits(Manager, _component_emitter_1$);
  return _createClass(Manager, [{
    key: "reconnection",
    value: function reconnection(v) {
      if (!arguments.length) return this._reconnection;
      this._reconnection = !!v;
      if (!v) {
        this.skipReconnect = true;
      }
      return this;
    }
  }, {
    key: "reconnectionAttempts",
    value: function reconnectionAttempts(v) {
      if (v === undefined) return this._reconnectionAttempts;
      this._reconnectionAttempts = v;
      return this;
    }
  }, {
    key: "reconnectionDelay",
    value: function reconnectionDelay(v) {
      var _a;
      if (v === undefined) return this._reconnectionDelay;
      this._reconnectionDelay = v;
      (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);
      return this;
    }
  }, {
    key: "randomizationFactor",
    value: function randomizationFactor(v) {
      var _a;
      if (v === undefined) return this._randomizationFactor;
      this._randomizationFactor = v;
      (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);
      return this;
    }
  }, {
    key: "reconnectionDelayMax",
    value: function reconnectionDelayMax(v) {
      var _a;
      if (v === undefined) return this._reconnectionDelayMax;
      this._reconnectionDelayMax = v;
      (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);
      return this;
    }
  }, {
    key: "timeout",
    value: function timeout(v) {
      if (!arguments.length) return this._timeout;
      this._timeout = v;
      return this;
    }
    /**
     * Starts trying to reconnect if reconnection is enabled and we have not
     * started reconnecting yet
     *
     * @private
     */
  }, {
    key: "maybeReconnectOnOpen",
    value: function maybeReconnectOnOpen() {
      // Only try to reconnect if it's the first time we're connecting
      if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {
        // keeps reconnection from firing twice for the same reconnection loop
        this.reconnect();
      }
    }
    /**
     * Sets the current transport `socket`.
     *
     * @param {Function} fn - optional, callback
     * @return self
     * @public
     */
  }, {
    key: "open",
    value: function open(fn) {
      var _this2 = this;
      debug("readyState %s", this._readyState);
      if (~this._readyState.indexOf("open")) return this;
      debug("opening %s", this.uri);
      this.engine = new engine_io_client_1.Socket(this.uri, this.opts);
      var socket = this.engine;
      var self = this;
      this._readyState = "opening";
      this.skipReconnect = false;
      // emit `open`
      var openSubDestroy = (0, on_js_1.on)(socket, "open", function () {
        self.onopen();
        fn && fn();
      });
      var onError = function onError(err) {
        debug("error");
        _this2.cleanup();
        _this2._readyState = "closed";
        _this2.emitReserved("error", err);
        if (fn) {
          fn(err);
        } else {
          // Only do this if there is no fn to handle the error
          _this2.maybeReconnectOnOpen();
        }
      };
      // emit `error`
      var errorSub = (0, on_js_1.on)(socket, "error", onError);
      if (false !== this._timeout) {
        var timeout = this._timeout;
        debug("connect attempt will timeout after %d", timeout);
        // set timer
        var timer = this.setTimeoutFn(function () {
          debug("connect attempt timed out after %d", timeout);
          openSubDestroy();
          onError(new Error("timeout"));
          socket.close();
        }, timeout);
        if (this.opts.autoUnref) {
          timer.unref();
        }
        this.subs.push(function () {
          _this2.clearTimeoutFn(timer);
        });
      }
      this.subs.push(openSubDestroy);
      this.subs.push(errorSub);
      return this;
    }
    /**
     * Alias for open()
     *
     * @return self
     * @public
     */
  }, {
    key: "connect",
    value: function connect(fn) {
      return this.open(fn);
    }
    /**
     * Called upon transport open.
     *
     * @private
     */
  }, {
    key: "onopen",
    value: function onopen() {
      debug("open");
      // clear old subs
      this.cleanup();
      // mark as open
      this._readyState = "open";
      this.emitReserved("open");
      // add new subs
      var socket = this.engine;
      this.subs.push((0, on_js_1.on)(socket, "ping", this.onping.bind(this)), (0, on_js_1.on)(socket, "data", this.ondata.bind(this)), (0, on_js_1.on)(socket, "error", this.onerror.bind(this)), (0, on_js_1.on)(socket, "close", this.onclose.bind(this)),
      // @ts-ignore
      (0, on_js_1.on)(this.decoder, "decoded", this.ondecoded.bind(this)));
    }
    /**
     * Called upon a ping.
     *
     * @private
     */
  }, {
    key: "onping",
    value: function onping() {
      this.emitReserved("ping");
    }
    /**
     * Called with data.
     *
     * @private
     */
  }, {
    key: "ondata",
    value: function ondata(data) {
      try {
        this.decoder.add(data);
      } catch (e) {
        this.onclose("parse error", e);
      }
    }
    /**
     * Called when parser fully decodes a packet.
     *
     * @private
     */
  }, {
    key: "ondecoded",
    value: function ondecoded(packet) {
      var _this3 = this;
      // the nextTick call prevents an exception in a user-provided event listener from triggering a disconnection due to a "parse error"
      (0, engine_io_client_1.nextTick)(function () {
        _this3.emitReserved("packet", packet);
      }, this.setTimeoutFn);
    }
    /**
     * Called upon socket error.
     *
     * @private
     */
  }, {
    key: "onerror",
    value: function onerror(err) {
      debug("error", err);
      this.emitReserved("error", err);
    }
    /**
     * Creates a new socket for the given `nsp`.
     *
     * @return {Socket}
     * @public
     */
  }, {
    key: "socket",
    value: function socket(nsp, opts) {
      var socket = this.nsps[nsp];
      if (!socket) {
        socket = new socket_js_1.Socket(this, nsp, opts);
        this.nsps[nsp] = socket;
      } else if (this._autoConnect && !socket.active) {
        socket.connect();
      }
      return socket;
    }
    /**
     * Called upon a socket close.
     *
     * @param socket
     * @private
     */
  }, {
    key: "_destroy",
    value: function _destroy(socket) {
      var nsps = Object.keys(this.nsps);
      for (var _i = 0, _nsps = nsps; _i < _nsps.length; _i++) {
        var nsp = _nsps[_i];
        var _socket = this.nsps[nsp];
        if (_socket.active) {
          debug("socket %s is still active, skipping close", nsp);
          return;
        }
      }
      this._close();
    }
    /**
     * Writes a packet.
     *
     * @param packet
     * @private
     */
  }, {
    key: "_packet",
    value: function _packet(packet) {
      debug("writing packet %j", packet);
      var encodedPackets = this.encoder.encode(packet);
      for (var i = 0; i < encodedPackets.length; i++) {
        this.engine.write(encodedPackets[i], packet.options);
      }
    }
    /**
     * Clean up transport subscriptions and packet buffer.
     *
     * @private
     */
  }, {
    key: "cleanup",
    value: function cleanup() {
      debug("cleanup");
      this.subs.forEach(function (subDestroy) {
        return subDestroy();
      });
      this.subs.length = 0;
      this.decoder.destroy();
    }
    /**
     * Close the current socket.
     *
     * @private
     */
  }, {
    key: "_close",
    value: function _close() {
      debug("disconnect");
      this.skipReconnect = true;
      this._reconnecting = false;
      this.onclose("forced close");
    }
    /**
     * Alias for close()
     *
     * @private
     */
  }, {
    key: "disconnect",
    value: function disconnect() {
      return this._close();
    }
    /**
     * Called when:
     *
     * - the low-level engine is closed
     * - the parser encountered a badly formatted packet
     * - all sockets are disconnected
     *
     * @private
     */
  }, {
    key: "onclose",
    value: function onclose(reason, description) {
      var _a;
      debug("closed due to %s", reason);
      this.cleanup();
      (_a = this.engine) === null || _a === void 0 ? void 0 : _a.close();
      this.backoff.reset();
      this._readyState = "closed";
      this.emitReserved("close", reason, description);
      if (this._reconnection && !this.skipReconnect) {
        this.reconnect();
      }
    }
    /**
     * Attempt a reconnection.
     *
     * @private
     */
  }, {
    key: "reconnect",
    value: function reconnect() {
      var _this4 = this;
      if (this._reconnecting || this.skipReconnect) return this;
      var self = this;
      if (this.backoff.attempts >= this._reconnectionAttempts) {
        debug("reconnect failed");
        this.backoff.reset();
        this.emitReserved("reconnect_failed");
        this._reconnecting = false;
      } else {
        var delay = this.backoff.duration();
        debug("will wait %dms before reconnect attempt", delay);
        this._reconnecting = true;
        var timer = this.setTimeoutFn(function () {
          if (self.skipReconnect) return;
          debug("attempting reconnect");
          _this4.emitReserved("reconnect_attempt", self.backoff.attempts);
          // check again for the case socket closed in above events
          if (self.skipReconnect) return;
          self.open(function (err) {
            if (err) {
              debug("reconnect attempt error");
              self._reconnecting = false;
              self.reconnect();
              _this4.emitReserved("reconnect_error", err);
            } else {
              debug("reconnect success");
              self.onreconnect();
            }
          });
        }, delay);
        if (this.opts.autoUnref) {
          timer.unref();
        }
        this.subs.push(function () {
          _this4.clearTimeoutFn(timer);
        });
      }
    }
    /**
     * Called upon successful reconnect.
     *
     * @private
     */
  }, {
    key: "onreconnect",
    value: function onreconnect() {
      var attempt = this.backoff.attempts;
      this._reconnecting = false;
      this.backoff.reset();
      this.emitReserved("reconnect", attempt);
    }
  }]);
}(component_emitter_1.Emitter);
exports.Manager = Manager;

},{"./contrib/backo2.js":79,"./on.js":82,"./socket.js":83,"@socket.io/component-emitter":1,"debug":85,"engine.io-client":12,"socket.io-parser":88}],82:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.on = on;
function on(obj, ev, fn) {
  obj.on(ev, fn);
  return function subDestroy() {
    obj.off(ev, fn);
  };
}

},{}],83:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Socket = void 0;
var socket_io_parser_1 = require("socket.io-parser");
var on_js_1 = require("./on.js");
var component_emitter_1 = require("@socket.io/component-emitter");
var debug_1 = __importDefault(require("debug")); // debug()
var debug = (0, debug_1["default"])("socket.io-client:socket"); // debug()
/**
 * Internal events.
 * These events can't be emitted by the user.
 */
var RESERVED_EVENTS = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
  newListener: 1,
  removeListener: 1
});
/**
 * A Socket is the fundamental class for interacting with the server.
 *
 * A Socket belongs to a certain Namespace (by default /) and uses an underlying {@link Manager} to communicate.
 *
 * @example
 * const socket = io();
 *
 * socket.on("connect", () => {
 *   console.log("connected");
 * });
 *
 * // send an event to the server
 * socket.emit("foo", "bar");
 *
 * socket.on("foobar", () => {
 *   // an event was received from the server
 * });
 *
 * // upon disconnection
 * socket.on("disconnect", (reason) => {
 *   console.log(`disconnected due to ${reason}`);
 * });
 */
var Socket = /*#__PURE__*/function (_component_emitter_1$) {
  /**
   * `Socket` constructor.
   */
  function Socket(io, nsp, opts) {
    var _this;
    _classCallCheck(this, Socket);
    _this = _callSuper(this, Socket);
    /**
     * Whether the socket is currently connected to the server.
     *
     * @example
     * const socket = io();
     *
     * socket.on("connect", () => {
     *   console.log(socket.connected); // true
     * });
     *
     * socket.on("disconnect", () => {
     *   console.log(socket.connected); // false
     * });
     */
    _this.connected = false;
    /**
     * Whether the connection state was recovered after a temporary disconnection. In that case, any missed packets will
     * be transmitted by the server.
     */
    _this.recovered = false;
    /**
     * Buffer for packets received before the CONNECT packet
     */
    _this.receiveBuffer = [];
    /**
     * Buffer for packets that will be sent once the socket is connected
     */
    _this.sendBuffer = [];
    /**
     * The queue of packets to be sent with retry in case of failure.
     *
     * Packets are sent one by one, each waiting for the server acknowledgement, in order to guarantee the delivery order.
     * @private
     */
    _this._queue = [];
    /**
     * A sequence to generate the ID of the {@link QueuedPacket}.
     * @private
     */
    _this._queueSeq = 0;
    _this.ids = 0;
    /**
     * A map containing acknowledgement handlers.
     *
     * The `withError` attribute is used to differentiate handlers that accept an error as first argument:
     *
     * - `socket.emit("test", (err, value) => { ... })` with `ackTimeout` option
     * - `socket.timeout(5000).emit("test", (err, value) => { ... })`
     * - `const value = await socket.emitWithAck("test")`
     *
     * From those that don't:
     *
     * - `socket.emit("test", (value) => { ... });`
     *
     * In the first case, the handlers will be called with an error when:
     *
     * - the timeout is reached
     * - the socket gets disconnected
     *
     * In the second case, the handlers will be simply discarded upon disconnection, since the client will never receive
     * an acknowledgement from the server.
     *
     * @private
     */
    _this.acks = {};
    _this.flags = {};
    _this.io = io;
    _this.nsp = nsp;
    if (opts && opts.auth) {
      _this.auth = opts.auth;
    }
    _this._opts = Object.assign({}, opts);
    if (_this.io._autoConnect) _this.open();
    return _this;
  }
  /**
   * Whether the socket is currently disconnected
   *
   * @example
   * const socket = io();
   *
   * socket.on("connect", () => {
   *   console.log(socket.disconnected); // false
   * });
   *
   * socket.on("disconnect", () => {
   *   console.log(socket.disconnected); // true
   * });
   */
  _inherits(Socket, _component_emitter_1$);
  return _createClass(Socket, [{
    key: "disconnected",
    get: function get() {
      return !this.connected;
    }
    /**
     * Subscribe to open, close and packet events
     *
     * @private
     */
  }, {
    key: "subEvents",
    value: function subEvents() {
      if (this.subs) return;
      var io = this.io;
      this.subs = [(0, on_js_1.on)(io, "open", this.onopen.bind(this)), (0, on_js_1.on)(io, "packet", this.onpacket.bind(this)), (0, on_js_1.on)(io, "error", this.onerror.bind(this)), (0, on_js_1.on)(io, "close", this.onclose.bind(this))];
    }
    /**
     * Whether the Socket will try to reconnect when its Manager connects or reconnects.
     *
     * @example
     * const socket = io();
     *
     * console.log(socket.active); // true
     *
     * socket.on("disconnect", (reason) => {
     *   if (reason === "io server disconnect") {
     *     // the disconnection was initiated by the server, you need to manually reconnect
     *     console.log(socket.active); // false
     *   }
     *   // else the socket will automatically try to reconnect
     *   console.log(socket.active); // true
     * });
     */
  }, {
    key: "active",
    get: function get() {
      return !!this.subs;
    }
    /**
     * "Opens" the socket.
     *
     * @example
     * const socket = io({
     *   autoConnect: false
     * });
     *
     * socket.connect();
     */
  }, {
    key: "connect",
    value: function connect() {
      if (this.connected) return this;
      this.subEvents();
      if (!this.io["_reconnecting"]) this.io.open(); // ensure open
      if ("open" === this.io._readyState) this.onopen();
      return this;
    }
    /**
     * Alias for {@link connect()}.
     */
  }, {
    key: "open",
    value: function open() {
      return this.connect();
    }
    /**
     * Sends a `message` event.
     *
     * This method mimics the WebSocket.send() method.
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
     *
     * @example
     * socket.send("hello");
     *
     * // this is equivalent to
     * socket.emit("message", "hello");
     *
     * @return self
     */
  }, {
    key: "send",
    value: function send() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      args.unshift("message");
      this.emit.apply(this, args);
      return this;
    }
    /**
     * Override `emit`.
     * If the event is in `events`, it's emitted normally.
     *
     * @example
     * socket.emit("hello", "world");
     *
     * // all serializable datastructures are supported (no need to call JSON.stringify)
     * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
     *
     * // with an acknowledgement from the server
     * socket.emit("hello", "world", (val) => {
     *   // ...
     * });
     *
     * @return self
     */
  }, {
    key: "emit",
    value: function emit(ev) {
      var _a, _b, _c;
      if (RESERVED_EVENTS.hasOwnProperty(ev)) {
        throw new Error('"' + ev.toString() + '" is a reserved event name');
      }
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      args.unshift(ev);
      if (this._opts.retries && !this.flags.fromQueue && !this.flags["volatile"]) {
        this._addToQueue(args);
        return this;
      }
      var packet = {
        type: socket_io_parser_1.PacketType.EVENT,
        data: args
      };
      packet.options = {};
      packet.options.compress = this.flags.compress !== false;
      // event ack callback
      if ("function" === typeof args[args.length - 1]) {
        var id = this.ids++;
        debug("emitting packet with ack id %d", id);
        var ack = args.pop();
        this._registerAckCallback(id, ack);
        packet.id = id;
      }
      var isTransportWritable = (_b = (_a = this.io.engine) === null || _a === void 0 ? void 0 : _a.transport) === null || _b === void 0 ? void 0 : _b.writable;
      var isConnected = this.connected && !((_c = this.io.engine) === null || _c === void 0 ? void 0 : _c._hasPingExpired());
      var discardPacket = this.flags["volatile"] && !isTransportWritable;
      if (discardPacket) {
        debug("discard packet as the transport is not currently writable");
      } else if (isConnected) {
        this.notifyOutgoingListeners(packet);
        this.packet(packet);
      } else {
        this.sendBuffer.push(packet);
      }
      this.flags = {};
      return this;
    }
    /**
     * @private
     */
  }, {
    key: "_registerAckCallback",
    value: function _registerAckCallback(id, ack) {
      var _this2 = this;
      var _a;
      var timeout = (_a = this.flags.timeout) !== null && _a !== void 0 ? _a : this._opts.ackTimeout;
      if (timeout === undefined) {
        this.acks[id] = ack;
        return;
      }
      // @ts-ignore
      var timer = this.io.setTimeoutFn(function () {
        delete _this2.acks[id];
        for (var i = 0; i < _this2.sendBuffer.length; i++) {
          if (_this2.sendBuffer[i].id === id) {
            debug("removing packet with ack id %d from the buffer", id);
            _this2.sendBuffer.splice(i, 1);
          }
        }
        debug("event with ack id %d has timed out after %d ms", id, timeout);
        ack.call(_this2, new Error("operation has timed out"));
      }, timeout);
      var fn = function fn() {
        // @ts-ignore
        _this2.io.clearTimeoutFn(timer);
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }
        ack.apply(_this2, args);
      };
      fn.withError = true;
      this.acks[id] = fn;
    }
    /**
     * Emits an event and waits for an acknowledgement
     *
     * @example
     * // without timeout
     * const response = await socket.emitWithAck("hello", "world");
     *
     * // with a specific timeout
     * try {
     *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
     * } catch (err) {
     *   // the server did not acknowledge the event in the given delay
     * }
     *
     * @return a Promise that will be fulfilled when the server acknowledges the event
     */
  }, {
    key: "emitWithAck",
    value: function emitWithAck(ev) {
      var _this3 = this;
      for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        args[_key4 - 1] = arguments[_key4];
      }
      return new Promise(function (resolve, reject) {
        var fn = function fn(arg1, arg2) {
          return arg1 ? reject(arg1) : resolve(arg2);
        };
        fn.withError = true;
        args.push(fn);
        _this3.emit.apply(_this3, [ev].concat(args));
      });
    }
    /**
     * Add the packet to the queue.
     * @param args
     * @private
     */
  }, {
    key: "_addToQueue",
    value: function _addToQueue(args) {
      var _this4 = this;
      var ack;
      if (typeof args[args.length - 1] === "function") {
        ack = args.pop();
      }
      var packet = {
        id: this._queueSeq++,
        tryCount: 0,
        pending: false,
        args: args,
        flags: Object.assign({
          fromQueue: true
        }, this.flags)
      };
      args.push(function (err) {
        if (packet !== _this4._queue[0]) {
          // the packet has already been acknowledged
          return;
        }
        var hasError = err !== null;
        if (hasError) {
          if (packet.tryCount > _this4._opts.retries) {
            debug("packet [%d] is discarded after %d tries", packet.id, packet.tryCount);
            _this4._queue.shift();
            if (ack) {
              ack(err);
            }
          }
        } else {
          debug("packet [%d] was successfully sent", packet.id);
          _this4._queue.shift();
          if (ack) {
            for (var _len5 = arguments.length, responseArgs = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
              responseArgs[_key5 - 1] = arguments[_key5];
            }
            ack.apply(void 0, [null].concat(responseArgs));
          }
        }
        packet.pending = false;
        return _this4._drainQueue();
      });
      this._queue.push(packet);
      this._drainQueue();
    }
    /**
     * Send the first packet of the queue, and wait for an acknowledgement from the server.
     * @param force - whether to resend a packet that has not been acknowledged yet
     *
     * @private
     */
  }, {
    key: "_drainQueue",
    value: function _drainQueue() {
      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      debug("draining queue");
      if (!this.connected || this._queue.length === 0) {
        return;
      }
      var packet = this._queue[0];
      if (packet.pending && !force) {
        debug("packet [%d] has already been sent and is waiting for an ack", packet.id);
        return;
      }
      packet.pending = true;
      packet.tryCount++;
      debug("sending packet [%d] (try n°%d)", packet.id, packet.tryCount);
      this.flags = packet.flags;
      this.emit.apply(this, packet.args);
    }
    /**
     * Sends a packet.
     *
     * @param packet
     * @private
     */
  }, {
    key: "packet",
    value: function packet(_packet) {
      _packet.nsp = this.nsp;
      this.io._packet(_packet);
    }
    /**
     * Called upon engine `open`.
     *
     * @private
     */
  }, {
    key: "onopen",
    value: function onopen() {
      var _this5 = this;
      debug("transport is open - connecting");
      if (typeof this.auth == "function") {
        this.auth(function (data) {
          _this5._sendConnectPacket(data);
        });
      } else {
        this._sendConnectPacket(this.auth);
      }
    }
    /**
     * Sends a CONNECT packet to initiate the Socket.IO session.
     *
     * @param data
     * @private
     */
  }, {
    key: "_sendConnectPacket",
    value: function _sendConnectPacket(data) {
      this.packet({
        type: socket_io_parser_1.PacketType.CONNECT,
        data: this._pid ? Object.assign({
          pid: this._pid,
          offset: this._lastOffset
        }, data) : data
      });
    }
    /**
     * Called upon engine or manager `error`.
     *
     * @param err
     * @private
     */
  }, {
    key: "onerror",
    value: function onerror(err) {
      if (!this.connected) {
        this.emitReserved("connect_error", err);
      }
    }
    /**
     * Called upon engine `close`.
     *
     * @param reason
     * @param description
     * @private
     */
  }, {
    key: "onclose",
    value: function onclose(reason, description) {
      debug("close (%s)", reason);
      this.connected = false;
      delete this.id;
      this.emitReserved("disconnect", reason, description);
      this._clearAcks();
    }
    /**
     * Clears the acknowledgement handlers upon disconnection, since the client will never receive an acknowledgement from
     * the server.
     *
     * @private
     */
  }, {
    key: "_clearAcks",
    value: function _clearAcks() {
      var _this6 = this;
      Object.keys(this.acks).forEach(function (id) {
        var isBuffered = _this6.sendBuffer.some(function (packet) {
          return String(packet.id) === id;
        });
        if (!isBuffered) {
          // note: handlers that do not accept an error as first argument are ignored here
          var ack = _this6.acks[id];
          delete _this6.acks[id];
          if (ack.withError) {
            ack.call(_this6, new Error("socket has been disconnected"));
          }
        }
      });
    }
    /**
     * Called with socket packet.
     *
     * @param packet
     * @private
     */
  }, {
    key: "onpacket",
    value: function onpacket(packet) {
      var sameNamespace = packet.nsp === this.nsp;
      if (!sameNamespace) return;
      switch (packet.type) {
        case socket_io_parser_1.PacketType.CONNECT:
          if (packet.data && packet.data.sid) {
            this.onconnect(packet.data.sid, packet.data.pid);
          } else {
            this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
          }
          break;
        case socket_io_parser_1.PacketType.EVENT:
        case socket_io_parser_1.PacketType.BINARY_EVENT:
          this.onevent(packet);
          break;
        case socket_io_parser_1.PacketType.ACK:
        case socket_io_parser_1.PacketType.BINARY_ACK:
          this.onack(packet);
          break;
        case socket_io_parser_1.PacketType.DISCONNECT:
          this.ondisconnect();
          break;
        case socket_io_parser_1.PacketType.CONNECT_ERROR:
          this.destroy();
          var err = new Error(packet.data.message);
          // @ts-ignore
          err.data = packet.data.data;
          this.emitReserved("connect_error", err);
          break;
      }
    }
    /**
     * Called upon a server event.
     *
     * @param packet
     * @private
     */
  }, {
    key: "onevent",
    value: function onevent(packet) {
      var args = packet.data || [];
      debug("emitting event %j", args);
      if (null != packet.id) {
        debug("attaching ack callback to event");
        args.push(this.ack(packet.id));
      }
      if (this.connected) {
        this.emitEvent(args);
      } else {
        this.receiveBuffer.push(Object.freeze(args));
      }
    }
  }, {
    key: "emitEvent",
    value: function emitEvent(args) {
      if (this._anyListeners && this._anyListeners.length) {
        var listeners = this._anyListeners.slice();
        var _iterator = _createForOfIteratorHelper(listeners),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var listener = _step.value;
            listener.apply(this, args);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
      _superPropGet(Socket, "emit", this, 1).apply(this, args);
      if (this._pid && args.length && typeof args[args.length - 1] === "string") {
        this._lastOffset = args[args.length - 1];
      }
    }
    /**
     * Produces an ack callback to emit with an event.
     *
     * @private
     */
  }, {
    key: "ack",
    value: function ack(id) {
      var self = this;
      var sent = false;
      return function () {
        // prevent double callbacks
        if (sent) return;
        sent = true;
        for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
          args[_key6] = arguments[_key6];
        }
        debug("sending ack %j", args);
        self.packet({
          type: socket_io_parser_1.PacketType.ACK,
          id: id,
          data: args
        });
      };
    }
    /**
     * Called upon a server acknowledgement.
     *
     * @param packet
     * @private
     */
  }, {
    key: "onack",
    value: function onack(packet) {
      var ack = this.acks[packet.id];
      if (typeof ack !== "function") {
        debug("bad ack %s", packet.id);
        return;
      }
      delete this.acks[packet.id];
      debug("calling ack %s with %j", packet.id, packet.data);
      // @ts-ignore FIXME ack is incorrectly inferred as 'never'
      if (ack.withError) {
        packet.data.unshift(null);
      }
      // @ts-ignore
      ack.apply(this, packet.data);
    }
    /**
     * Called upon server connect.
     *
     * @private
     */
  }, {
    key: "onconnect",
    value: function onconnect(id, pid) {
      debug("socket connected with id %s", id);
      this.id = id;
      this.recovered = pid && this._pid === pid;
      this._pid = pid; // defined only if connection state recovery is enabled
      this.connected = true;
      this.emitBuffered();
      this.emitReserved("connect");
      this._drainQueue(true);
    }
    /**
     * Emit buffered events (received and emitted).
     *
     * @private
     */
  }, {
    key: "emitBuffered",
    value: function emitBuffered() {
      var _this7 = this;
      this.receiveBuffer.forEach(function (args) {
        return _this7.emitEvent(args);
      });
      this.receiveBuffer = [];
      this.sendBuffer.forEach(function (packet) {
        _this7.notifyOutgoingListeners(packet);
        _this7.packet(packet);
      });
      this.sendBuffer = [];
    }
    /**
     * Called upon server disconnect.
     *
     * @private
     */
  }, {
    key: "ondisconnect",
    value: function ondisconnect() {
      debug("server disconnect (%s)", this.nsp);
      this.destroy();
      this.onclose("io server disconnect");
    }
    /**
     * Called upon forced client/server side disconnections,
     * this method ensures the manager stops tracking us and
     * that reconnections don't get triggered for this.
     *
     * @private
     */
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.subs) {
        // clean subscriptions to avoid reconnections
        this.subs.forEach(function (subDestroy) {
          return subDestroy();
        });
        this.subs = undefined;
      }
      this.io["_destroy"](this);
    }
    /**
     * Disconnects the socket manually. In that case, the socket will not try to reconnect.
     *
     * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
     *
     * @example
     * const socket = io();
     *
     * socket.on("disconnect", (reason) => {
     *   // console.log(reason); prints "io client disconnect"
     * });
     *
     * socket.disconnect();
     *
     * @return self
     */
  }, {
    key: "disconnect",
    value: function disconnect() {
      if (this.connected) {
        debug("performing disconnect (%s)", this.nsp);
        this.packet({
          type: socket_io_parser_1.PacketType.DISCONNECT
        });
      }
      // remove socket from pool
      this.destroy();
      if (this.connected) {
        // fire events
        this.onclose("io client disconnect");
      }
      return this;
    }
    /**
     * Alias for {@link disconnect()}.
     *
     * @return self
     */
  }, {
    key: "close",
    value: function close() {
      return this.disconnect();
    }
    /**
     * Sets the compress flag.
     *
     * @example
     * socket.compress(false).emit("hello");
     *
     * @param compress - if `true`, compresses the sending data
     * @return self
     */
  }, {
    key: "compress",
    value: function compress(_compress) {
      this.flags.compress = _compress;
      return this;
    }
    /**
     * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
     * ready to send messages.
     *
     * @example
     * socket.volatile.emit("hello"); // the server may or may not receive it
     *
     * @returns self
     */
  }, {
    key: "volatile",
    get: function get() {
      this.flags["volatile"] = true;
      return this;
    }
    /**
     * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
     * given number of milliseconds have elapsed without an acknowledgement from the server:
     *
     * @example
     * socket.timeout(5000).emit("my-event", (err) => {
     *   if (err) {
     *     // the server did not acknowledge the event in the given delay
     *   }
     * });
     *
     * @returns self
     */
  }, {
    key: "timeout",
    value: function timeout(_timeout) {
      this.flags.timeout = _timeout;
      return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback.
     *
     * @example
     * socket.onAny((event, ...args) => {
     *   console.log(`got ${event}`);
     * });
     *
     * @param listener
     */
  }, {
    key: "onAny",
    value: function onAny(listener) {
      this._anyListeners = this._anyListeners || [];
      this._anyListeners.push(listener);
      return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback. The listener is added to the beginning of the listeners array.
     *
     * @example
     * socket.prependAny((event, ...args) => {
     *   console.log(`got event ${event}`);
     * });
     *
     * @param listener
     */
  }, {
    key: "prependAny",
    value: function prependAny(listener) {
      this._anyListeners = this._anyListeners || [];
      this._anyListeners.unshift(listener);
      return this;
    }
    /**
     * Removes the listener that will be fired when any event is emitted.
     *
     * @example
     * const catchAllListener = (event, ...args) => {
     *   console.log(`got event ${event}`);
     * }
     *
     * socket.onAny(catchAllListener);
     *
     * // remove a specific listener
     * socket.offAny(catchAllListener);
     *
     * // or remove all listeners
     * socket.offAny();
     *
     * @param listener
     */
  }, {
    key: "offAny",
    value: function offAny(listener) {
      if (!this._anyListeners) {
        return this;
      }
      if (listener) {
        var listeners = this._anyListeners;
        for (var i = 0; i < listeners.length; i++) {
          if (listener === listeners[i]) {
            listeners.splice(i, 1);
            return this;
          }
        }
      } else {
        this._anyListeners = [];
      }
      return this;
    }
    /**
     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
     * e.g. to remove listeners.
     */
  }, {
    key: "listenersAny",
    value: function listenersAny() {
      return this._anyListeners || [];
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback.
     *
     * Note: acknowledgements sent to the server are not included.
     *
     * @example
     * socket.onAnyOutgoing((event, ...args) => {
     *   console.log(`sent event ${event}`);
     * });
     *
     * @param listener
     */
  }, {
    key: "onAnyOutgoing",
    value: function onAnyOutgoing(listener) {
      this._anyOutgoingListeners = this._anyOutgoingListeners || [];
      this._anyOutgoingListeners.push(listener);
      return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback. The listener is added to the beginning of the listeners array.
     *
     * Note: acknowledgements sent to the server are not included.
     *
     * @example
     * socket.prependAnyOutgoing((event, ...args) => {
     *   console.log(`sent event ${event}`);
     * });
     *
     * @param listener
     */
  }, {
    key: "prependAnyOutgoing",
    value: function prependAnyOutgoing(listener) {
      this._anyOutgoingListeners = this._anyOutgoingListeners || [];
      this._anyOutgoingListeners.unshift(listener);
      return this;
    }
    /**
     * Removes the listener that will be fired when any event is emitted.
     *
     * @example
     * const catchAllListener = (event, ...args) => {
     *   console.log(`sent event ${event}`);
     * }
     *
     * socket.onAnyOutgoing(catchAllListener);
     *
     * // remove a specific listener
     * socket.offAnyOutgoing(catchAllListener);
     *
     * // or remove all listeners
     * socket.offAnyOutgoing();
     *
     * @param [listener] - the catch-all listener (optional)
     */
  }, {
    key: "offAnyOutgoing",
    value: function offAnyOutgoing(listener) {
      if (!this._anyOutgoingListeners) {
        return this;
      }
      if (listener) {
        var listeners = this._anyOutgoingListeners;
        for (var i = 0; i < listeners.length; i++) {
          if (listener === listeners[i]) {
            listeners.splice(i, 1);
            return this;
          }
        }
      } else {
        this._anyOutgoingListeners = [];
      }
      return this;
    }
    /**
     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
     * e.g. to remove listeners.
     */
  }, {
    key: "listenersAnyOutgoing",
    value: function listenersAnyOutgoing() {
      return this._anyOutgoingListeners || [];
    }
    /**
     * Notify the listeners for each packet sent
     *
     * @param packet
     *
     * @private
     */
  }, {
    key: "notifyOutgoingListeners",
    value: function notifyOutgoingListeners(packet) {
      if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
        var listeners = this._anyOutgoingListeners.slice();
        var _iterator2 = _createForOfIteratorHelper(listeners),
          _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var listener = _step2.value;
            listener.apply(this, packet.data);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
    }
  }]);
}(component_emitter_1.Emitter);
exports.Socket = Socket;

},{"./on.js":82,"@socket.io/component-emitter":1,"debug":85,"socket.io-parser":88}],84:[function(require,module,exports){
"use strict";

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.url = url;
var engine_io_client_1 = require("engine.io-client");
var debug_1 = __importDefault(require("debug")); // debug()
var debug = (0, debug_1["default"])("socket.io-client:url"); // debug()
/**
 * URL parser.
 *
 * @param uri - url
 * @param path - the request path of the connection
 * @param loc - An object meant to mimic window.location.
 *        Defaults to window.location.
 * @public
 */
function url(uri) {
  var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
  var loc = arguments.length > 2 ? arguments[2] : undefined;
  var obj = uri;
  // default to window.location
  loc = loc || typeof location !== "undefined" && location;
  if (null == uri) uri = loc.protocol + "//" + loc.host;
  // relative path support
  if (typeof uri === "string") {
    if ("/" === uri.charAt(0)) {
      if ("/" === uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }
    if (!/^(https?|wss?):\/\//.test(uri)) {
      debug("protocol-less url %s", uri);
      if ("undefined" !== typeof loc) {
        uri = loc.protocol + "//" + uri;
      } else {
        uri = "https://" + uri;
      }
    }
    // parse
    debug("parse %s", uri);
    obj = (0, engine_io_client_1.parse)(uri);
  }
  // make sure we treat `localhost:80` and `localhost` equally
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = "80";
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = "443";
    }
  }
  obj.path = obj.path || "/";
  var ipv6 = obj.host.indexOf(":") !== -1;
  var host = ipv6 ? "[" + obj.host + "]" : obj.host;
  // define unique id
  obj.id = obj.protocol + "://" + host + ":" + obj.port + path;
  // define href
  obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
  return obj;
}

},{"debug":85,"engine.io-client":12}],85:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"./common":86,"_process":74,"dup":22}],86:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23,"ms":73}],87:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.reconstructPacket = exports.deconstructPacket = void 0;
var is_binary_js_1 = require("./is-binary.js");
/**
 * Replaces every Buffer | ArrayBuffer | Blob | File in packet with a numbered placeholder.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @public
 */
function deconstructPacket(packet) {
  var buffers = [];
  var packetData = packet.data;
  var pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length; // number of binary 'attachments'
  return {
    packet: pack,
    buffers: buffers
  };
}
exports.deconstructPacket = deconstructPacket;
function _deconstructPacket(data, buffers) {
  if (!data) return data;
  if ((0, is_binary_js_1.isBinary)(data)) {
    var placeholder = {
      _placeholder: true,
      num: buffers.length
    };
    buffers.push(data);
    return placeholder;
  } else if (Array.isArray(data)) {
    var newData = new Array(data.length);
    for (var i = 0; i < data.length; i++) {
      newData[i] = _deconstructPacket(data[i], buffers);
    }
    return newData;
  } else if (_typeof(data) === "object" && !(data instanceof Date)) {
    var _newData = {};
    for (var key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        _newData[key] = _deconstructPacket(data[key], buffers);
      }
    }
    return _newData;
  }
  return data;
}
/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @public
 */
function reconstructPacket(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  delete packet.attachments; // no longer useful
  return packet;
}
exports.reconstructPacket = reconstructPacket;
function _reconstructPacket(data, buffers) {
  if (!data) return data;
  if (data && data._placeholder === true) {
    var isIndexValid = typeof data.num === "number" && data.num >= 0 && data.num < buffers.length;
    if (isIndexValid) {
      return buffers[data.num]; // appropriate buffer (should be natural order anyway)
    } else {
      throw new Error("illegal attachments");
    }
  } else if (Array.isArray(data)) {
    for (var i = 0; i < data.length; i++) {
      data[i] = _reconstructPacket(data[i], buffers);
    }
  } else if (_typeof(data) === "object") {
    for (var key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        data[key] = _reconstructPacket(data[key], buffers);
      }
    }
  }
  return data;
}

},{"./is-binary.js":89}],88:[function(require,module,exports){
"use strict";

function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Decoder = exports.Encoder = exports.PacketType = exports.protocol = void 0;
var component_emitter_1 = require("@socket.io/component-emitter");
var binary_js_1 = require("./binary.js");
var is_binary_js_1 = require("./is-binary.js");
var debug_1 = require("debug"); // debug()
var debug = (0, debug_1["default"])("socket.io-parser"); // debug()
/**
 * These strings must not be used as event names, as they have a special meaning.
 */
var RESERVED_EVENTS = ["connect", "connect_error", "disconnect", "disconnecting", "newListener", "removeListener" // used by the Node.js EventEmitter
];
/**
 * Protocol version.
 *
 * @public
 */
exports.protocol = 5;
var PacketType;
(function (PacketType) {
  PacketType[PacketType["CONNECT"] = 0] = "CONNECT";
  PacketType[PacketType["DISCONNECT"] = 1] = "DISCONNECT";
  PacketType[PacketType["EVENT"] = 2] = "EVENT";
  PacketType[PacketType["ACK"] = 3] = "ACK";
  PacketType[PacketType["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
  PacketType[PacketType["BINARY_EVENT"] = 5] = "BINARY_EVENT";
  PacketType[PacketType["BINARY_ACK"] = 6] = "BINARY_ACK";
})(PacketType = exports.PacketType || (exports.PacketType = {}));
/**
 * A socket.io Encoder instance
 */
var Encoder = /*#__PURE__*/function () {
  /**
   * Encoder constructor
   *
   * @param {function} replacer - custom replacer to pass down to JSON.parse
   */
  function Encoder(replacer) {
    _classCallCheck(this, Encoder);
    this.replacer = replacer;
  }
  /**
   * Encode a packet as a single string if non-binary, or as a
   * buffer sequence, depending on packet type.
   *
   * @param {Object} obj - packet object
   */
  return _createClass(Encoder, [{
    key: "encode",
    value: function encode(obj) {
      debug("encoding packet %j", obj);
      if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
        if ((0, is_binary_js_1.hasBinary)(obj)) {
          return this.encodeAsBinary({
            type: obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,
            nsp: obj.nsp,
            data: obj.data,
            id: obj.id
          });
        }
      }
      return [this.encodeAsString(obj)];
    }
    /**
     * Encode packet as string.
     */
  }, {
    key: "encodeAsString",
    value: function encodeAsString(obj) {
      // first is type
      var str = "" + obj.type;
      // attachments if we have them
      if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
        str += obj.attachments + "-";
      }
      // if we have a namespace other than `/`
      // we append it followed by a comma `,`
      if (obj.nsp && "/" !== obj.nsp) {
        str += obj.nsp + ",";
      }
      // immediately followed by the id
      if (null != obj.id) {
        str += obj.id;
      }
      // json data
      if (null != obj.data) {
        str += JSON.stringify(obj.data, this.replacer);
      }
      debug("encoded %j as %s", obj, str);
      return str;
    }
    /**
     * Encode packet as 'buffer sequence' by removing blobs, and
     * deconstructing packet into object with placeholders and
     * a list of buffers.
     */
  }, {
    key: "encodeAsBinary",
    value: function encodeAsBinary(obj) {
      var deconstruction = (0, binary_js_1.deconstructPacket)(obj);
      var pack = this.encodeAsString(deconstruction.packet);
      var buffers = deconstruction.buffers;
      buffers.unshift(pack); // add packet info to beginning of data list
      return buffers; // write all the buffers
    }
  }]);
}();
exports.Encoder = Encoder;
// see https://stackoverflow.com/questions/8511281/check-if-a-value-is-an-object-in-javascript
function isObject(value) {
  return Object.prototype.toString.call(value) === "[object Object]";
}
/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 */
var Decoder = /*#__PURE__*/function (_component_emitter_1$) {
  /**
   * Decoder constructor
   *
   * @param {function} reviver - custom reviver to pass down to JSON.stringify
   */
  function Decoder(reviver) {
    var _this;
    _classCallCheck(this, Decoder);
    _this = _callSuper(this, Decoder);
    _this.reviver = reviver;
    return _this;
  }
  /**
   * Decodes an encoded packet string into packet JSON.
   *
   * @param {String} obj - encoded packet
   */
  _inherits(Decoder, _component_emitter_1$);
  return _createClass(Decoder, [{
    key: "add",
    value: function add(obj) {
      var packet;
      if (typeof obj === "string") {
        if (this.reconstructor) {
          throw new Error("got plaintext data when reconstructing a packet");
        }
        packet = this.decodeString(obj);
        var isBinaryEvent = packet.type === PacketType.BINARY_EVENT;
        if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {
          packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;
          // binary packet's json
          this.reconstructor = new BinaryReconstructor(packet);
          // no attachments, labeled binary but no binary data to follow
          if (packet.attachments === 0) {
            _superPropGet(Decoder, "emitReserved", this, 3)(["decoded", packet]);
          }
        } else {
          // non-binary full packet
          _superPropGet(Decoder, "emitReserved", this, 3)(["decoded", packet]);
        }
      } else if ((0, is_binary_js_1.isBinary)(obj) || obj.base64) {
        // raw binary data
        if (!this.reconstructor) {
          throw new Error("got binary data when not reconstructing a packet");
        } else {
          packet = this.reconstructor.takeBinaryData(obj);
          if (packet) {
            // received final buffer
            this.reconstructor = null;
            _superPropGet(Decoder, "emitReserved", this, 3)(["decoded", packet]);
          }
        }
      } else {
        throw new Error("Unknown type: " + obj);
      }
    }
    /**
     * Decode a packet String (JSON data)
     *
     * @param {String} str
     * @return {Object} packet
     */
  }, {
    key: "decodeString",
    value: function decodeString(str) {
      var i = 0;
      // look up type
      var p = {
        type: Number(str.charAt(0))
      };
      if (PacketType[p.type] === undefined) {
        throw new Error("unknown packet type " + p.type);
      }
      // look up attachments if type binary
      if (p.type === PacketType.BINARY_EVENT || p.type === PacketType.BINARY_ACK) {
        var start = i + 1;
        while (str.charAt(++i) !== "-" && i != str.length) {}
        var buf = str.substring(start, i);
        if (buf != Number(buf) || str.charAt(i) !== "-") {
          throw new Error("Illegal attachments");
        }
        p.attachments = Number(buf);
      }
      // look up namespace (if any)
      if ("/" === str.charAt(i + 1)) {
        var _start = i + 1;
        while (++i) {
          var c = str.charAt(i);
          if ("," === c) break;
          if (i === str.length) break;
        }
        p.nsp = str.substring(_start, i);
      } else {
        p.nsp = "/";
      }
      // look up id
      var next = str.charAt(i + 1);
      if ("" !== next && Number(next) == next) {
        var _start2 = i + 1;
        while (++i) {
          var _c = str.charAt(i);
          if (null == _c || Number(_c) != _c) {
            --i;
            break;
          }
          if (i === str.length) break;
        }
        p.id = Number(str.substring(_start2, i + 1));
      }
      // look up json data
      if (str.charAt(++i)) {
        var payload = this.tryParse(str.substr(i));
        if (Decoder.isPayloadValid(p.type, payload)) {
          p.data = payload;
        } else {
          throw new Error("invalid payload");
        }
      }
      debug("decoded %s as %j", str, p);
      return p;
    }
  }, {
    key: "tryParse",
    value: function tryParse(str) {
      try {
        return JSON.parse(str, this.reviver);
      } catch (e) {
        return false;
      }
    }
  }, {
    key: "destroy",
    value:
    /**
     * Deallocates a parser's resources
     */
    function destroy() {
      if (this.reconstructor) {
        this.reconstructor.finishedReconstruction();
        this.reconstructor = null;
      }
    }
  }], [{
    key: "isPayloadValid",
    value: function isPayloadValid(type, payload) {
      switch (type) {
        case PacketType.CONNECT:
          return isObject(payload);
        case PacketType.DISCONNECT:
          return payload === undefined;
        case PacketType.CONNECT_ERROR:
          return typeof payload === "string" || isObject(payload);
        case PacketType.EVENT:
        case PacketType.BINARY_EVENT:
          return Array.isArray(payload) && (typeof payload[0] === "number" || typeof payload[0] === "string" && RESERVED_EVENTS.indexOf(payload[0]) === -1);
        case PacketType.ACK:
        case PacketType.BINARY_ACK:
          return Array.isArray(payload);
      }
    }
  }]);
}(component_emitter_1.Emitter);
exports.Decoder = Decoder;
/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 */
var BinaryReconstructor = /*#__PURE__*/function () {
  function BinaryReconstructor(packet) {
    _classCallCheck(this, BinaryReconstructor);
    this.packet = packet;
    this.buffers = [];
    this.reconPack = packet;
  }
  /**
   * Method to be called when binary data received from connection
   * after a BINARY_EVENT packet.
   *
   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
   * @return {null | Object} returns null if more binary data is expected or
   *   a reconstructed packet object if all buffers have been received.
   */
  return _createClass(BinaryReconstructor, [{
    key: "takeBinaryData",
    value: function takeBinaryData(binData) {
      this.buffers.push(binData);
      if (this.buffers.length === this.reconPack.attachments) {
        // done with buffer list
        var packet = (0, binary_js_1.reconstructPacket)(this.reconPack, this.buffers);
        this.finishedReconstruction();
        return packet;
      }
      return null;
    }
    /**
     * Cleans up binary packet reconstruction variables.
     */
  }, {
    key: "finishedReconstruction",
    value: function finishedReconstruction() {
      this.reconPack = null;
      this.buffers = [];
    }
  }]);
}();

},{"./binary.js":87,"./is-binary.js":89,"@socket.io/component-emitter":1,"debug":90}],89:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hasBinary = exports.isBinary = void 0;
var withNativeArrayBuffer = typeof ArrayBuffer === "function";
var isView = function isView(obj) {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
};
var toString = Object.prototype.toString;
var withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && toString.call(Blob) === "[object BlobConstructor]";
var withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString.call(File) === "[object FileConstructor]";
/**
 * Returns true if obj is a Buffer, an ArrayBuffer, a Blob or a File.
 *
 * @private
 */
function isBinary(obj) {
  return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;
}
exports.isBinary = isBinary;
function hasBinary(obj, toJSON) {
  if (!obj || _typeof(obj) !== "object") {
    return false;
  }
  if (Array.isArray(obj)) {
    for (var i = 0, l = obj.length; i < l; i++) {
      if (hasBinary(obj[i])) {
        return true;
      }
    }
    return false;
  }
  if (isBinary(obj)) {
    return true;
  }
  if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }
  return false;
}
exports.hasBinary = hasBinary;

},{}],90:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"./common":91,"_process":74,"dup":22}],91:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23,"ms":73}],92:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
/* UAParser.js v2.0.4
   Copyright © 2012-2025 Faisal Salman <f@faisalman.com>
   AGPLv3 License */
(function (i, l) {
  function I(i) {
    for (var e = {}, t = 0; t < i.length; t++) e[i[t].toUpperCase()] = i[t];
    return e;
  }
  var U = 500,
    P = "user-agent",
    w = "",
    B = "?",
    R = "function",
    n = "undefined",
    c = "object",
    L = "string",
    u = "browser",
    h = "cpu",
    p = "device",
    m = "engine",
    f = "os",
    g = "result",
    v = "name",
    k = "type",
    x = "vendor",
    y = "version",
    C = "architecture",
    G = "major",
    S = "model",
    W = "console",
    _ = "mobile",
    r = "tablet",
    e = "smarttv",
    t = "wearable",
    N = "xr",
    F = "embedded",
    D = "inapp",
    $ = "brands",
    q = "formFactors",
    X = "fullVersionList",
    z = "platform",
    Y = "platformVersion",
    Q = "bitness",
    o = "sec-ch-ua",
    Z = o + "-full-version-list",
    K = o + "-arch",
    J = o + "-" + Q,
    ii = o + "-form-factors",
    ei = o + "-" + _,
    ti = o + "-" + S,
    oi = o + "-" + z,
    ri = oi + "-version",
    ai = [$, X, _, S, z, Y, C, q, Q],
    si = "Amazon",
    a = "Apple",
    ni = "ASUS",
    wi = "BlackBerry",
    s = "Google",
    bi = "Huawei",
    di = "Lenovo",
    li = "Microsoft",
    ci = "Motorola",
    ui = "Nvidia",
    hi = "OnePlus",
    pi = "OPPO",
    mi = "Samsung",
    fi = "Sony",
    gi = "Xiaomi",
    vi = "Zebra",
    ki = "Chromium",
    b = "Chromecast",
    xi = "Edge",
    yi = "Firefox",
    d = "Opera",
    Ci = "Facebook",
    T = "Mobile ",
    Si = " Browser",
    _i = "Windows",
    qi = _typeof(i) !== n,
    A = qi && i.navigator ? i.navigator : l,
    H = A && A.userAgentData ? A.userAgentData : l,
    zi = function zi(i, e) {
      if (_typeof(i) === c && 0 < i.length) {
        for (var t in i) if (j(e) == j(i[t])) return !0;
        return !1;
      }
      return !!O(i) && j(e) == j(i);
    },
    _Ti = function Ti(i, e) {
      for (var t in i) return /^(browser|cpu|device|engine|os)$/.test(t) || !!e && _Ti(i[t]);
    },
    O = function O(i) {
      return _typeof(i) === L;
    },
    Ai = function Ai(i) {
      if (!i) return l;
      for (var e, t = [], o = Oi(/\\?\"/g, i).split(","), r = 0; r < o.length; r++) -1 < o[r].indexOf(";") ? (e = Mi(o[r]).split(";v="), t[r] = {
        brand: e[0],
        version: e[1]
      }) : t[r] = Mi(o[r]);
      return t;
    },
    j = function j(i) {
      return O(i) ? i.toLowerCase() : i;
    },
    Hi = function Hi(i) {
      return O(i) ? Oi(/[^\d\.]/g, i).split(".")[0] : l;
    },
    M = function M(i) {
      for (var e in i) {
        e = i[e];
        _typeof(e) == c && 2 == e.length ? this[e[0]] = e[1] : this[e] = l;
      }
      return this;
    },
    Oi = function Oi(i, e) {
      return O(e) ? e.replace(i, w) : e;
    },
    ji = function ji(i) {
      return Oi(/\\?\"/g, i);
    },
    Mi = function Mi(i, e) {
      if (O(i)) return i = Oi(/^\s\s*/, i), _typeof(e) === n ? i : i.substring(0, U);
    },
    Ei = function Ei(i, e) {
      if (i && e) for (var t, o, r, a, s, n = 0; n < e.length && !a;) {
        for (var w = e[n], b = e[n + 1], d = t = 0; d < w.length && !a && w[d];) if (a = w[d++].exec(i)) for (o = 0; o < b.length; o++) s = a[++t], _typeof(r = b[o]) === c && 0 < r.length ? 2 === r.length ? _typeof(r[1]) == R ? this[r[0]] = r[1].call(this, s) : this[r[0]] = r[1] : 3 <= r.length && (_typeof(r[1]) !== R || r[1].exec && r[1].test ? 3 == r.length ? this[r[0]] = s ? s.replace(r[1], r[2]) : l : 4 == r.length ? this[r[0]] = s ? r[3].call(this, s.replace(r[1], r[2])) : l : 4 < r.length && (this[r[0]] = s ? r[3].apply(this, [s.replace(r[1], r[2])].concat(r.slice(4))) : l) : 3 < r.length ? this[r[0]] = s ? r[1].apply(this, r.slice(2)) : l : this[r[0]] = s ? r[1].call(this, s, r[2]) : l) : this[r] = s || l;
        n += 2;
      }
    },
    E = function E(i, e) {
      for (var t in e) if (_typeof(e[t]) === c && 0 < e[t].length) {
        for (var o = 0; o < e[t].length; o++) if (zi(e[t][o], i)) return t === B ? l : t;
      } else if (zi(e[t], i)) return t === B ? l : t;
      return e.hasOwnProperty("*") ? e["*"] : i;
    },
    Vi = {
      ME: "4.90",
      "NT 3.51": "3.51",
      "NT 4.0": "4.0",
      2e3: ["5.0", "5.01"],
      XP: ["5.1", "5.2"],
      Vista: "6.0",
      7: "6.1",
      8: "6.2",
      8.1: "6.3",
      10: ["6.4", "10.0"],
      NT: ""
    },
    Ii = {
      embedded: "Automotive",
      mobile: "Mobile",
      tablet: ["Tablet", "EInk"],
      smarttv: "TV",
      wearable: "Watch",
      xr: ["VR", "XR"],
      "?": ["Desktop", "Unknown"],
      "*": l
    },
    Ui = {
      Chrome: "Google Chrome",
      Edge: "Microsoft Edge",
      "Edge WebView2": "Microsoft Edge WebView2",
      "Chrome WebView": "Android WebView",
      "Chrome Headless": "HeadlessChrome",
      "Huawei Browser": "HuaweiBrowser",
      "MIUI Browser": "Miui Browser",
      "Opera Mobi": "OperaMobile",
      Yandex: "YaBrowser"
    },
    Pi = {
      browser: [[/\b(?:crmo|crios)\/([\w\.]+)/i], [y, [v, T + "Chrome"]], [/webview.+edge\/([\w\.]+)/i], [y, [v, xi + " WebView"]], [/edg(?:e|ios|a)?\/([\w\.]+)/i], [y, [v, "Edge"]], [/(opera mini)\/([-\w\.]+)/i, /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i, /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i], [v, y], [/opios[\/ ]+([\w\.]+)/i], [y, [v, d + " Mini"]], [/\bop(?:rg)?x\/([\w\.]+)/i], [y, [v, d + " GX"]], [/\bopr\/([\w\.]+)/i], [y, [v, d]], [/\bb[ai]*d(?:uhd|[ub]*[aekoprswx]{5,6})[\/ ]?([\w\.]+)/i], [y, [v, "Baidu"]], [/\b(?:mxbrowser|mxios|myie2)\/?([-\w\.]*)\b/i], [y, [v, "Maxthon"]], [/(kindle)\/([\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer|sleipnir)[\/ ]?([\w\.]*)/i, /(avant|iemobile|slim(?:browser|boat|jet))[\/ ]?([\d\.]*)/i, /(?:ms|\()(ie) ([\w\.]+)/i, /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|duckduckgo|klar|helio|(?=comodo_)?dragon|otter|dooble|(?:lg |qute)browser)\/([-\w\.]+)/i, /(heytap|ovi|115|surf)browser\/([\d\.]+)/i, /(ecosia|weibo)(?:__| \w+@)([\d\.]+)/i], [v, y], [/quark(?:pc)?\/([-\w\.]+)/i], [y, [v, "Quark"]], [/\bddg\/([\w\.]+)/i], [y, [v, "DuckDuckGo"]], [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i], [y, [v, "UCBrowser"]], [/microm.+\bqbcore\/([\w\.]+)/i, /\bqbcore\/([\w\.]+).+microm/i, /micromessenger\/([\w\.]+)/i], [y, [v, "WeChat"]], [/konqueror\/([\w\.]+)/i], [y, [v, "Konqueror"]], [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i], [y, [v, "IE"]], [/ya(?:search)?browser\/([\w\.]+)/i], [y, [v, "Yandex"]], [/slbrowser\/([\w\.]+)/i], [y, [v, "Smart " + di + Si]], [/(avast|avg)\/([\w\.]+)/i], [[v, /(.+)/, "$1 Secure" + Si], y], [/\bfocus\/([\w\.]+)/i], [y, [v, yi + " Focus"]], [/\bopt\/([\w\.]+)/i], [y, [v, d + " Touch"]], [/coc_coc\w+\/([\w\.]+)/i], [y, [v, "Coc Coc"]], [/dolfin\/([\w\.]+)/i], [y, [v, "Dolphin"]], [/coast\/([\w\.]+)/i], [y, [v, d + " Coast"]], [/miuibrowser\/([\w\.]+)/i], [y, [v, "MIUI" + Si]], [/fxios\/([\w\.-]+)/i], [y, [v, T + yi]], [/\bqihoobrowser\/?([\w\.]*)/i], [y, [v, "360"]], [/\b(qq)\/([\w\.]+)/i], [[v, /(.+)/, "$1Browser"], y], [/(oculus|sailfish|huawei|vivo|pico)browser\/([\w\.]+)/i], [[v, /(.+)/, "$1" + Si], y], [/samsungbrowser\/([\w\.]+)/i], [y, [v, mi + " Internet"]], [/metasr[\/ ]?([\d\.]+)/i], [y, [v, "Sogou Explorer"]], [/(sogou)mo\w+\/([\d\.]+)/i], [[v, "Sogou Mobile"], y], [/(electron)\/([\w\.]+) safari/i, /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i, /m?(qqbrowser|2345(?=browser|chrome|explorer))\w*[\/ ]?v?([\w\.]+)/i], [v, y], [/(lbbrowser|rekonq)/i], [v], [/ome\/([\w\.]+) \w* ?(iron) saf/i, /ome\/([\w\.]+).+qihu (360)[es]e/i], [y, v], [/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i], [[v, Ci], y, [k, D]], [/(kakao(?:talk|story))[\/ ]([\w\.]+)/i, /(naver)\(.*?(\d+\.[\w\.]+).*\)/i, /(daum)apps[\/ ]([\w\.]+)/i, /safari (line)\/([\w\.]+)/i, /\b(line)\/([\w\.]+)\/iab/i, /(alipay)client\/([\w\.]+)/i, /(twitter)(?:and| f.+e\/([\w\.]+))/i, /(instagram|snapchat|klarna)[\/ ]([-\w\.]+)/i], [v, y, [k, D]], [/\bgsa\/([\w\.]+) .*safari\//i], [y, [v, "GSA"], [k, D]], [/musical_ly(?:.+app_?version\/|_)([\w\.]+)/i], [y, [v, "TikTok"], [k, D]], [/\[(linkedin)app\]/i], [v, [k, D]], [/(chromium)[\/ ]([-\w\.]+)/i], [v, y], [/headlesschrome(?:\/([\w\.]+)| )/i], [y, [v, "Chrome Headless"]], [/wv\).+chrome\/([\w\.]+).+edgw\//i], [y, [v, xi + " WebView2"]], [/ wv\).+(chrome)\/([\w\.]+)/i], [[v, "Chrome WebView"], y], [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i], [y, [v, "Android" + Si]], [/chrome\/([\w\.]+) mobile/i], [y, [v, T + "Chrome"]], [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i], [v, y], [/version\/([\w\.\,]+) .*mobile(?:\/\w+ | ?)safari/i], [y, [v, T + "Safari"]], [/iphone .*mobile(?:\/\w+ | ?)safari/i], [[v, T + "Safari"]], [/version\/([\w\.\,]+) .*(safari)/i], [y, v], [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i], [v, [y, "1"]], [/(webkit|khtml)\/([\w\.]+)/i], [v, y], [/(?:mobile|tablet);.*(firefox)\/([\w\.-]+)/i], [[v, T + yi], y], [/(navigator|netscape\d?)\/([-\w\.]+)/i], [[v, "Netscape"], y], [/(wolvic|librewolf)\/([\w\.]+)/i], [v, y], [/mobile vr; rv:([\w\.]+)\).+firefox/i], [y, [v, yi + " Reality"]], [/ekiohf.+(flow)\/([\w\.]+)/i, /(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror)[\/ ]?([\w\.\+]+)/i, /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i, /(firefox)\/([\w\.]+)/i, /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i, /(amaya|dillo|doris|icab|ladybird|lynx|mosaic|netsurf|obigo|polaris|w3m|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i, /\b(links) \(([\w\.]+)/i], [v, [y, /_/g, "."]], [/(cobalt)\/([\w\.]+)/i], [v, [y, /[^\d\.]+./, w]]],
      cpu: [[/\b((amd|x|x86[-_]?|wow|win)64)\b/i], [[C, "amd64"]], [/(ia32(?=;))/i, /\b((i[346]|x)86)(pc)?\b/i], [[C, "ia32"]], [/\b(aarch64|arm(v?[89]e?l?|_?64))\b/i], [[C, "arm64"]], [/\b(arm(v[67])?ht?n?[fl]p?)\b/i], [[C, "armhf"]], [/( (ce|mobile); ppc;|\/[\w\.]+arm\b)/i], [[C, "arm"]], [/((ppc|powerpc)(64)?)( mac|;|\))/i], [[C, /ower/, w, j]], [/ sun4\w[;\)]/i], [[C, "sparc"]], [/\b(avr32|ia64(?=;)|68k(?=\))|\barm(?=v([1-7]|[5-7]1)l?|;|eabi)|(irix|mips|sparc)(64)?\b|pa-risc)/i], [[C, j]]],
      device: [[/\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i], [S, [x, mi], [k, r]], [/\b((?:s[cgp]h|gt|sm)-(?![lr])\w+|sc[g-]?[\d]+a?|galaxy nexus)/i, /samsung[- ]((?!sm-[lr]|browser)[-\w]+)/i, /sec-(sgh\w+)/i], [S, [x, mi], [k, _]], [/(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i], [S, [x, a], [k, _]], [/\((ipad);[-\w\),; ]+apple/i, /applecoremedia\/[\w\.]+ \((ipad)/i, /\b(ipad)\d\d?,\d\d?[;\]].+ios/i], [S, [x, a], [k, r]], [/(macintosh);/i], [S, [x, a]], [/\b(sh-?[altvz]?\d\d[a-ekm]?)/i], [S, [x, "Sharp"], [k, _]], [/\b((?:brt|eln|hey2?|gdi|jdn)-a?[lnw]09|(?:ag[rm]3?|jdn2|kob2)-a?[lw]0[09]hn)(?: bui|\)|;)/i], [S, [x, "Honor"], [k, r]], [/honor([-\w ]+)[;\)]/i], [S, [x, "Honor"], [k, _]], [/\b((?:ag[rs][2356]?k?|bah[234]?|bg[2o]|bt[kv]|cmr|cpn|db[ry]2?|jdn2|got|kob2?k?|mon|pce|scm|sht?|[tw]gr|vrd)-[ad]?[lw][0125][09]b?|605hw|bg2-u03|(?:gem|fdr|m2|ple|t1)-[7a]0[1-4][lu]|t1-a2[13][lw]|mediapad[\w\. ]*(?= bui|\)))\b(?!.+d\/s)/i], [S, [x, bi], [k, r]], [/(?:huawei)([-\w ]+)[;\)]/i, /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i], [S, [x, bi], [k, _]], [/oid[^\)]+; (2[\dbc]{4}(182|283|rp\w{2})[cgl]|m2105k81a?c)(?: bui|\))/i, /\b((?:red)?mi[-_ ]?pad[\w- ]*)(?: bui|\))/i], [[S, /_/g, " "], [x, gi], [k, r]], [/\b(poco[\w ]+|m2\d{3}j\d\d[a-z]{2})(?: bui|\))/i, /\b; (\w+) build\/hm\1/i, /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i, /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i, /oid[^\)]+; (m?[12][0-389][01]\w{3,6}[c-y])( bui|; wv|\))/i, /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite|pro)?)(?: bui|\))/i, / ([\w ]+) miui\/v?\d/i], [[S, /_/g, " "], [x, gi], [k, _]], [/droid.+; (cph2[3-6]\d[13579]|((gm|hd)19|(ac|be|in|kb)20|(d[en]|eb|le|mt)21|ne22)[0-2]\d|p[g-k]\w[1m]10)\b/i, /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i], [S, [x, hi], [k, _]], [/; (\w+) bui.+ oppo/i, /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i], [S, [x, pi], [k, _]], [/\b(opd2(\d{3}a?))(?: bui|\))/i], [S, [x, E, {
        OnePlus: ["203", "304", "403", "404", "413", "415"],
        "*": pi
      }], [k, r]], [/(vivo (5r?|6|8l?|go|one|s|x[il]?[2-4]?)[\w\+ ]*)(?: bui|\))/i], [S, [x, "BLU"], [k, _]], [/; vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i], [S, [x, "Vivo"], [k, _]], [/\b(rmx[1-3]\d{3})(?: bui|;|\))/i], [S, [x, "Realme"], [k, _]], [/(ideatab[-\w ]+|602lv|d-42a|a101lv|a2109a|a3500-hv|s[56]000|pb-6505[my]|tb-?x?\d{3,4}(?:f[cu]|xu|[av])|yt\d?-[jx]?\d+[lfmx])( bui|;|\)|\/)/i, /lenovo ?(b[68]0[08]0-?[hf]?|tab(?:[\w- ]+?)|tb[\w-]{6,7})( bui|;|\)|\/)/i], [S, [x, di], [k, r]], [/lenovo[-_ ]?([-\w ]+?)(?: bui|\)|\/)/i], [S, [x, di], [k, _]], [/\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i, /\bmot(?:orola)?[- ]([\w\s]+)(\)| bui)/i, /((?:moto(?! 360)[-\w\(\) ]+|xt\d{3,4}[cgkosw\+]?[-\d]*|nexus 6)(?= bui|\)))/i], [S, [x, ci], [k, _]], [/\b(mz60\d|xoom[2 ]{0,2}) build\//i], [S, [x, ci], [k, r]], [/((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i], [S, [x, "LG"], [k, r]], [/(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i, /\blg[-e;\/ ]+(?!.*(?:browser|netcast|android tv|watch|webos))(\w+)/i, /\blg-?([\d\w]+) bui/i], [S, [x, "LG"], [k, _]], [/(nokia) (t[12][01])/i], [x, S, [k, r]], [/(?:maemo|nokia).*(n900|lumia \d+|rm-\d+)/i, /nokia[-_ ]?(([-\w\. ]*))/i], [[S, /_/g, " "], [k, _], [x, "Nokia"]], [/(pixel (c|tablet))\b/i], [S, [x, s], [k, r]], [/droid.+;(?: google)? (g(01[13]a|020[aem]|025[jn]|1b60|1f8f|2ybb|4s1m|576d|5nz6|8hhn|8vou|a02099|c15s|d1yq|e2ae|ec77|gh2x|kv4x|p4bc|pj41|r83y|tt9q|ur25|wvk6)|pixel[\d ]*a?( pro)?( xl)?( fold)?( \(5g\))?)( bui|\))/i], [S, [x, s], [k, _]], [/(google) (pixelbook( go)?)/i], [x, S], [/droid.+; (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-\w\w\d\d)(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i], [S, [x, fi], [k, _]], [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i], [[S, "Xperia Tablet"], [x, fi], [k, r]], [/(alexa)webm/i, /(kf[a-z]{2}wi|aeo(?!bc)\w\w)( bui|\))/i, /(kf[a-z]+)( bui|\)).+silk\//i], [S, [x, si], [k, r]], [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i], [[S, /(.+)/g, "Fire Phone $1"], [x, si], [k, _]], [/(playbook);[-\w\),; ]+(rim)/i], [S, x, [k, r]], [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i], [S, [x, wi], [k, _]], [/(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i], [S, [x, ni], [k, r]], [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i], [S, [x, ni], [k, _]], [/(nexus 9)/i], [S, [x, "HTC"], [k, r]], [/(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i, /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i, /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i], [x, [S, /_/g, " "], [k, _]], [/tcl (xess p17aa)/i, /droid [\w\.]+; ((?:8[14]9[16]|9(?:0(?:48|60|8[01])|1(?:3[27]|66)|2(?:6[69]|9[56])|466))[gqswx])(_\w(\w|\w\w))?(\)| bui)/i], [S, [x, "TCL"], [k, r]], [/droid [\w\.]+; (418(?:7d|8v)|5087z|5102l|61(?:02[dh]|25[adfh]|27[ai]|56[dh]|59k|65[ah])|a509dl|t(?:43(?:0w|1[adepqu])|50(?:6d|7[adju])|6(?:09dl|10k|12b|71[efho]|76[hjk])|7(?:66[ahju]|67[hw]|7[045][bh]|71[hk]|73o|76[ho]|79w|81[hks]?|82h|90[bhsy]|99b)|810[hs]))(_\w(\w|\w\w))?(\)| bui)/i], [S, [x, "TCL"], [k, _]], [/(itel) ((\w+))/i], [[x, j], S, [k, E, {
        tablet: ["p10001l", "w7001"],
        "*": "mobile"
      }]], [/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i], [S, [x, "Acer"], [k, r]], [/droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i], [S, [x, "Meizu"], [k, _]], [/; ((?:power )?armor(?:[\w ]{0,8}))(?: bui|\))/i], [S, [x, "Ulefone"], [k, _]], [/; (energy ?\w+)(?: bui|\))/i, /; energizer ([\w ]+)(?: bui|\))/i], [S, [x, "Energizer"], [k, _]], [/; cat (b35);/i, /; (b15q?|s22 flip|s48c|s62 pro)(?: bui|\))/i], [S, [x, "Cat"], [k, _]], [/((?:new )?andromax[\w- ]+)(?: bui|\))/i], [S, [x, "Smartfren"], [k, _]], [/droid.+; (a(in)?(0(15|59|6[35])|142)p?)/i], [S, [x, "Nothing"], [k, _]], [/; (x67 5g|tikeasy \w+|ac[1789]\d\w+)( b|\))/i, /archos ?(5|gamepad2?|([\w ]*[t1789]|hello) ?\d+[\w ]*)( b|\))/i], [S, [x, "Archos"], [k, r]], [/archos ([\w ]+)( b|\))/i, /; (ac[3-6]\d\w{2,8})( b|\))/i], [S, [x, "Archos"], [k, _]], [/; (n159v)/i], [S, [x, "HMD"], [k, _]], [/(imo) (tab \w+)/i, /(infinix|tecno) (x1101b?|p904|dp(7c|8d|10a)( pro)?|p70[1-3]a?|p904|t1101)/i], [x, S, [k, r]], [/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus(?! zenw)|dell|jolla|meizu|motorola|polytron|tecno|micromax|advan)[-_ ]?([-\w]*)/i, /; (blu|hmd|imo|infinix|lava|oneplus|tcl)[_ ]([\w\+ ]+?)(?: bui|\)|; r)/i, /(hp) ([\w ]+\w)/i, /(microsoft); (lumia[\w ]+)/i, /(oppo) ?([\w ]+) bui/i], [x, S, [k, _]], [/(kobo)\s(ereader|touch)/i, /(hp).+(touchpad(?!.+tablet)|tablet)/i, /(kindle)\/([\w\.]+)/i], [x, S, [k, r]], [/(surface duo)/i], [S, [x, li], [k, r]], [/droid [\d\.]+; (fp\du?)(?: b|\))/i], [S, [x, "Fairphone"], [k, _]], [/((?:tegranote|shield t(?!.+d tv))[\w- ]*?)(?: b|\))/i], [S, [x, ui], [k, r]], [/(sprint) (\w+)/i], [x, S, [k, _]], [/(kin\.[onetw]{3})/i], [[S, /\./g, " "], [x, li], [k, _]], [/droid.+; ([c6]+|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i], [S, [x, vi], [k, r]], [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i], [S, [x, vi], [k, _]], [/smart-tv.+(samsung)/i], [x, [k, e]], [/hbbtv.+maple;(\d+)/i], [[S, /^/, "SmartTV"], [x, mi], [k, e]], [/(vizio)(?: |.+model\/)(\w+-\w+)/i, /tcast.+(lg)e?. ([-\w]+)/i], [x, S, [k, e]], [/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i], [[x, "LG"], [k, e]], [/(apple) ?tv/i], [x, [S, a + " TV"], [k, e]], [/crkey.*devicetype\/chromecast/i], [[S, b + " Third Generation"], [x, s], [k, e]], [/crkey.*devicetype\/([^/]*)/i], [[S, /^/, "Chromecast "], [x, s], [k, e]], [/fuchsia.*crkey/i], [[S, b + " Nest Hub"], [x, s], [k, e]], [/crkey/i], [[S, b], [x, s], [k, e]], [/(portaltv)/i], [S, [x, Ci], [k, e]], [/droid.+aft(\w+)( bui|\))/i], [S, [x, si], [k, e]], [/(shield \w+ tv)/i], [S, [x, ui], [k, e]], [/\(dtv[\);].+(aquos)/i, /(aquos-tv[\w ]+)\)/i], [S, [x, "Sharp"], [k, e]], [/(bravia[\w ]+)( bui|\))/i], [S, [x, fi], [k, e]], [/(mi(tv|box)-?\w+) bui/i], [S, [x, gi], [k, e]], [/Hbbtv.*(technisat) (.*);/i], [x, S, [k, e]], [/\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i, /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i], [[x, /.+\/(\w+)/, "$1", E, {
        LG: "lge"
      }], [S, Mi], [k, e]], [/droid.+; ([\w- ]+) (?:android tv|smart[- ]?tv)/i], [S, [k, e]], [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:|large screen[\w ]+safari)\b/i], [[k, e]], [/(playstation \w+)/i], [S, [x, fi], [k, W]], [/\b(xbox(?: one)?(?!; xbox))[\); ]/i], [S, [x, li], [k, W]], [/(ouya)/i, /(nintendo) (\w+)/i, /(retroid) (pocket ([^\)]+))/i], [x, S, [k, W]], [/droid.+; (shield)( bui|\))/i], [S, [x, ui], [k, W]], [/\b(sm-[lr]\d\d[0156][fnuw]?s?|gear live)\b/i], [S, [x, mi], [k, t]], [/((pebble))app/i, /(asus|google|lg|oppo) ((pixel |zen)?watch[\w ]*)( bui|\))/i], [x, S, [k, t]], [/(ow(?:19|20)?we?[1-3]{1,3})/i], [S, [x, pi], [k, t]], [/(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i], [S, [x, a], [k, t]], [/(opwwe\d{3})/i], [S, [x, hi], [k, t]], [/(moto 360)/i], [S, [x, ci], [k, t]], [/(smartwatch 3)/i], [S, [x, fi], [k, t]], [/(g watch r)/i], [S, [x, "LG"], [k, t]], [/droid.+; (wt63?0{2,3})\)/i], [S, [x, vi], [k, t]], [/droid.+; (glass) \d/i], [S, [x, s], [k, N]], [/(pico) (4|neo3(?: link|pro)?)/i], [x, S, [k, N]], [/(quest( \d| pro)?s?).+vr/i], [S, [x, Ci], [k, N]], [/mobile vr; rv.+firefox/i], [[k, N]], [/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i], [x, [k, F]], [/(aeobc)\b/i], [S, [x, si], [k, F]], [/(homepod).+mac os/i], [S, [x, a], [k, F]], [/windows iot/i], [[k, F]], [/droid .+?; ([^;]+?)(?: bui|; wv\)|\) applew).+?(mobile|vr|\d) safari/i], [S, [k, E, {
        mobile: "Mobile",
        xr: "VR",
        "*": r
      }]], [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i], [[k, r]], [/(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i], [[k, _]], [/droid .+?; ([\w\. -]+)( bui|\))/i], [S, [x, "Generic"]]],
      engine: [[/windows.+ edge\/([\w\.]+)/i], [y, [v, xi + "HTML"]], [/(arkweb)\/([\w\.]+)/i], [v, y], [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i], [y, [v, "Blink"]], [/(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna|servo)\/([\w\.]+)/i, /ekioh(flow)\/([\w\.]+)/i, /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i, /(icab)[\/ ]([23]\.[\d\.]+)/i, /\b(libweb)/i], [v, y], [/ladybird\//i], [[v, "LibWeb"]], [/rv\:([\w\.]{1,9})\b.+(gecko)/i], [y, v]],
      os: [[/(windows nt) (6\.[23]); arm/i], [[v, /N/, "R"], [y, E, Vi]], [/(windows (?:phone|mobile|iot))(?: os)?[\/ ]?([\d\.]*( se)?)/i, /(windows)[\/ ](1[01]|2000|3\.1|7|8(\.1)?|9[58]|me|server 20\d\d( r2)?|vista|xp)/i], [v, y], [/windows nt ?([\d\.\)]*)(?!.+xbox)/i, /\bwin(?=3| ?9|n)(?:nt| 9x )?([\d\.;]*)/i], [[y, /(;|\))/g, "", E, Vi], [v, _i]], [/(windows ce)\/?([\d\.]*)/i], [v, y], [/[adehimnop]{4,7}\b(?:.*os ([\w]+) like mac|; opera)/i, /(?:ios;fbsv\/|iphone.+ios[\/ ])([\d\.]+)/i, /cfnetwork\/.+darwin/i], [[y, /_/g, "."], [v, "iOS"]], [/(mac os x) ?([\w\. ]*)/i, /(macintosh|mac_powerpc\b)(?!.+(haiku|morphos))/i], [[v, "macOS"], [y, /_/g, "."]], [/android ([\d\.]+).*crkey/i], [y, [v, b + " Android"]], [/fuchsia.*crkey\/([\d\.]+)/i], [y, [v, b + " Fuchsia"]], [/crkey\/([\d\.]+).*devicetype\/smartspeaker/i], [y, [v, b + " SmartSpeaker"]], [/linux.*crkey\/([\d\.]+)/i], [y, [v, b + " Linux"]], [/crkey\/([\d\.]+)/i], [y, [v, b]], [/droid ([\w\.]+)\b.+(android[- ]x86)/i], [y, v], [/(ubuntu) ([\w\.]+) like android/i], [[v, /(.+)/, "$1 Touch"], y], [/(harmonyos)[\/ ]?([\d\.]*)/i, /(android|bada|blackberry|kaios|maemo|meego|openharmony|qnx|rim tablet os|sailfish|series40|symbian|tizen)\w*[-\/\.; ]?([\d\.]*)/i], [v, y], [/\(bb(10);/i], [y, [v, wi]], [/(?:symbian ?os|symbos|s60(?=;)|series ?60)[-\/ ]?([\w\.]*)/i], [y, [v, "Symbian"]], [/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i], [y, [v, yi + " OS"]], [/\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i, /webos(?:[ \/]?|\.tv-20(?=2[2-9]))(\d[\d\.]*)/i], [y, [v, "webOS"]], [/web0s;.+?(?:chr[o0]me|safari)\/(\d+)/i], [[y, E, {
        25: "120",
        24: "108",
        23: "94",
        22: "87",
        6: "79",
        5: "68",
        4: "53",
        3: "38",
        2: "538",
        1: "537",
        "*": "TV"
      }], [v, "webOS"]], [/watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i], [y, [v, "watchOS"]], [/(cros) [\w]+(?:\)| ([\w\.]+)\b)/i], [[v, "Chrome OS"], y], [/panasonic;(viera)/i, /(netrange)mmh/i, /(nettv)\/(\d+\.[\w\.]+)/i, /(nintendo|playstation) (\w+)/i, /(xbox); +xbox ([^\);]+)/i, /(pico) .+os([\w\.]+)/i, /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i, /linux.+(mint)[\/\(\) ]?([\w\.]*)/i, /(mageia|vectorlinux|fuchsia|arcaos|arch(?= ?linux))[;l ]([\d\.]*)/i, /([kxln]?ubuntu|debian|suse|opensuse|gentoo|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire|knoppix)(?: gnu[\/ ]linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i, /((?:open)?solaris)[-\/ ]?([\w\.]*)/i, /\b(aix)[; ]([1-9\.]{0,4})/i, /(hurd|linux|morphos)(?: (?:arm|x86|ppc)\w*| ?)([\w\.]*)/i, /(gnu) ?([\w\.]*)/i, /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, /(haiku) ?(r\d)?/i], [v, y], [/(sunos) ?([\d\.]*)/i], [[v, "Solaris"], y], [/\b(beos|os\/2|amigaos|openvms|hp-ux|serenityos)/i, /(unix) ?([\w\.]*)/i], [v, y]]
    },
    Bi = (d = {
      init: {},
      isIgnore: {},
      isIgnoreRgx: {},
      toString: {}
    }, M.call(d.init, [[u, [v, y, G, k]], [h, [C]], [p, [k, S, x]], [m, [v, y]], [f, [v, y]]]), M.call(d.isIgnore, [[u, [y, G]], [m, [y]], [f, [y]]]), M.call(d.isIgnoreRgx, [[u, / ?browser$/i], [f, / ?os$/i]]), M.call(d.toString, [[u, [v, y]], [h, [C]], [p, [x, S]], [m, [v, y]], [f, [v, y]]]), d),
    Ri = function Ri(e, i) {
      var t = Bi.init[i],
        o = Bi.isIgnore[i] || 0,
        r = Bi.isIgnoreRgx[i] || 0,
        a = Bi.toString[i] || 0;
      function s() {
        M.call(this, t);
      }
      return s.prototype.getItem = function () {
        return e;
      }, s.prototype.withClientHints = function () {
        return H ? H.getHighEntropyValues(ai).then(function (i) {
          return e.setCH(new Li(i, !1)).parseCH().get();
        }) : e.parseCH().get();
      }, s.prototype.withFeatureCheck = function () {
        return e.detectFeature().get();
      }, i != g && (s.prototype.is = function (i) {
        var e,
          t = !1;
        for (e in this) if (this.hasOwnProperty(e) && !zi(o, e) && j(r ? Oi(r, this[e]) : this[e]) == j(r ? Oi(r, i) : i)) {
          if (t = !0, i != n) break;
        } else if (i == n && t) {
          t = !t;
          break;
        }
        return t;
      }, s.prototype.toString = function () {
        var i,
          e = w;
        for (i in a) _typeof(this[a[i]]) !== n && (e += (e ? " " : w) + this[a[i]]);
        return e || n;
      }), H || (s.prototype.then = function (i) {
        function e() {
          for (var i in t) t.hasOwnProperty(i) && (this[i] = t[i]);
        }
        var t = this,
          o = (e.prototype = {
            is: s.prototype.is,
            toString: s.prototype.toString
          }, new e());
        return i(o), o;
      }), new s();
    };
  function Li(i, e) {
    if (i = i || {}, M.call(this, ai), e) M.call(this, [[$, Ai(i[o])], [X, Ai(i[Z])], [_, /\?1/.test(i[ei])], [S, ji(i[ti])], [z, ji(i[oi])], [Y, ji(i[ri])], [C, ji(i[K])], [q, Ai(i[ii])], [Q, ji(i[J])]]);else for (var t in i) this.hasOwnProperty(t) && _typeof(i[t]) !== n && (this[t] = i[t]);
  }
  function Gi(i, e, t, o) {
    return this.get = function (i) {
      return i ? this.data.hasOwnProperty(i) ? this.data[i] : l : this.data;
    }, this.set = function (i, e) {
      return this.data[i] = e, this;
    }, this.setCH = function (i) {
      return this.uaCH = i, this;
    }, this.detectFeature = function () {
      if (A && A.userAgent == this.ua) switch (this.itemType) {
        case u:
          A.brave && _typeof(A.brave.isBrave) == R && this.set(v, "Brave");
          break;
        case p:
          !this.get(k) && H && H[_] && this.set(k, _), "Macintosh" == this.get(S) && A && _typeof(A.standalone) !== n && A.maxTouchPoints && 2 < A.maxTouchPoints && this.set(S, "iPad").set(k, r);
          break;
        case f:
          !this.get(v) && H && H[z] && this.set(v, H[z]);
          break;
        case g:
          var e = this.data,
            i = function i(_i2) {
              return e[_i2].getItem().detectFeature().get();
            };
          this.set(u, i(u)).set(h, i(h)).set(p, i(p)).set(m, i(m)).set(f, i(f));
      }
      return this;
    }, this.parseUA = function () {
      return this.itemType != g && Ei.call(this.data, this.ua, this.rgxMap), this.itemType == u && this.set(G, Hi(this.get(y))), this;
    }, this.parseCH = function () {
      var i,
        e = this.uaCH,
        t = this.rgxMap;
      switch (this.itemType) {
        case u:
        case m:
          var o,
            r = e[X] || e[$];
          if (r) for (var a in r) {
            var s = r[a].brand || r[a],
              a = r[a].version;
            this.itemType == u && !/not.a.brand/i.test(s) && (!o || /Chrom/.test(o) && s != ki || o == xi && /WebView2/.test(s)) && (s = E(s, Ui), (o = this.get(v)) && !/Chrom/.test(o) && /Chrom/.test(s) || this.set(v, s).set(y, a).set(G, Hi(a)), o = s), this.itemType == m && s == ki && this.set(y, a);
          }
          break;
        case h:
          var n = e[C];
          n && ("64" == e[Q] && (n += "64"), Ei.call(this.data, n + ";", t));
          break;
        case p:
          if (e[_] && this.set(k, _), e[S] && (this.set(S, e[S]), this.get(k) && this.get(x) || (Ei.call(n = {}, "droid 9; " + e[S] + ")", t), !this.get(k) && n.type && this.set(k, n.type), !this.get(x) && n.vendor && this.set(x, n.vendor))), e[q]) {
            if ("string" != typeof e[q]) for (var w = 0; !i && w < e[q].length;) i = E(e[q][w++], Ii);else i = E(e[q], Ii);
            this.set(k, i);
          }
          break;
        case f:
          var b,
            n = e[z];
          n && (b = e[Y], n == _i && (b = 13 <= parseInt(Hi(b), 10) ? "11" : "10"), this.set(v, n).set(y, b)), this.get(v) == _i && "Xbox" == e[S] && this.set(v, "Xbox").set(y, l);
          break;
        case g:
          var d = this.data,
            n = function n(i) {
              return d[i].getItem().setCH(e).parseCH().get();
            };
          this.set(u, n(u)).set(h, n(h)).set(p, n(p)).set(m, n(m)).set(f, n(f));
      }
      return this;
    }, M.call(this, [["itemType", i], ["ua", e], ["uaCH", o], ["rgxMap", t], ["data", Ri(this, i)]]), this;
  }
  function V(i, e, t) {
    var o, r, a, s, n;
    return _typeof(i) === c ? (e = _Ti(i, !0) ? (_typeof(e) === c && (t = e), i) : (t = i, l), i = l) : _typeof(i) !== L || _Ti(e, !0) || (t = e, e = l), t && _typeof(t.append) === R && (o = {}, t.forEach(function (i, e) {
      o[e] = i;
    }), t = o), this instanceof V ? (r = _typeof(i) === L ? i : t && t[P] ? t[P] : A && A.userAgent ? A.userAgent : w, a = new Li(t, !0), s = e ? function (i, e) {
      var t,
        o = {},
        r = e;
      if (!_Ti(e)) for (var a in r = {}, e) for (var s in e[a]) r[s] = e[a][s].concat(r[s] || []);
      for (t in i) o[t] = r[t] && r[t].length % 2 == 0 ? r[t].concat(i[t]) : i[t];
      return o;
    }(Pi, e) : Pi, M.call(this, [["getBrowser", (n = function n(i) {
      return i == g ? function () {
        return new Gi(i, r, s, a).set("ua", r).set(u, this.getBrowser()).set(h, this.getCPU()).set(p, this.getDevice()).set(m, this.getEngine()).set(f, this.getOS()).get();
      } : function () {
        return new Gi(i, r, s[i], a).parseUA().get();
      };
    })(u)], ["getCPU", n(h)], ["getDevice", n(p)], ["getEngine", n(m)], ["getOS", n(f)], ["getResult", n(g)], ["getUA", function () {
      return r;
    }], ["setUA", function (i) {
      return O(i) && (r = i.length > U ? Mi(i, U) : i), this;
    }]]).setUA(r), this) : new V(i, e, t).getResult();
  }
  V.VERSION = "2.0.4", V.BROWSER = I([v, y, G, k]), V.CPU = I([C]), V.DEVICE = I([S, x, k, W, _, e, r, t, F]), V.ENGINE = V.OS = I([v, y]), (typeof exports === "undefined" ? "undefined" : _typeof(exports)) !== n ? (exports = (typeof module === "undefined" ? "undefined" : _typeof(module)) !== n && module.exports ? module.exports = V : exports).UAParser = V : (typeof define === "undefined" ? "undefined" : _typeof(define)) === R && define.amd ? define(function () {
    return V;
  }) : qi && (i.UAParser = V);
  var Wi,
    Ni = qi && (i.jQuery || i.Zepto);
  Ni && !Ni.ua && (Wi = new V(), Ni.ua = Wi.getResult(), Ni.ua.get = function () {
    return Wi.getUA();
  }, Ni.ua.set = function (i) {
    Wi.setUA(i);
    var e,
      t = Wi.getResult();
    for (e in t) Ni.ua[e] = t[e];
  });
})("object" == (typeof window === "undefined" ? "undefined" : _typeof(window)) ? window : void 0);

},{}],93:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.version = exports.validate = exports.v7 = exports.v6ToV1 = exports.v6 = exports.v5 = exports.v4 = exports.v3 = exports.v1ToV6 = exports.v1 = exports.stringify = exports.parse = exports.NIL = exports.MAX = void 0;
var max_js_1 = require("./max.js");
Object.defineProperty(exports, "MAX", {
  enumerable: true,
  get: function get() {
    return max_js_1["default"];
  }
});
var nil_js_1 = require("./nil.js");
Object.defineProperty(exports, "NIL", {
  enumerable: true,
  get: function get() {
    return nil_js_1["default"];
  }
});
var parse_js_1 = require("./parse.js");
Object.defineProperty(exports, "parse", {
  enumerable: true,
  get: function get() {
    return parse_js_1["default"];
  }
});
var stringify_js_1 = require("./stringify.js");
Object.defineProperty(exports, "stringify", {
  enumerable: true,
  get: function get() {
    return stringify_js_1["default"];
  }
});
var v1_js_1 = require("./v1.js");
Object.defineProperty(exports, "v1", {
  enumerable: true,
  get: function get() {
    return v1_js_1["default"];
  }
});
var v1ToV6_js_1 = require("./v1ToV6.js");
Object.defineProperty(exports, "v1ToV6", {
  enumerable: true,
  get: function get() {
    return v1ToV6_js_1["default"];
  }
});
var v3_js_1 = require("./v3.js");
Object.defineProperty(exports, "v3", {
  enumerable: true,
  get: function get() {
    return v3_js_1["default"];
  }
});
var v4_js_1 = require("./v4.js");
Object.defineProperty(exports, "v4", {
  enumerable: true,
  get: function get() {
    return v4_js_1["default"];
  }
});
var v5_js_1 = require("./v5.js");
Object.defineProperty(exports, "v5", {
  enumerable: true,
  get: function get() {
    return v5_js_1["default"];
  }
});
var v6_js_1 = require("./v6.js");
Object.defineProperty(exports, "v6", {
  enumerable: true,
  get: function get() {
    return v6_js_1["default"];
  }
});
var v6ToV1_js_1 = require("./v6ToV1.js");
Object.defineProperty(exports, "v6ToV1", {
  enumerable: true,
  get: function get() {
    return v6ToV1_js_1["default"];
  }
});
var v7_js_1 = require("./v7.js");
Object.defineProperty(exports, "v7", {
  enumerable: true,
  get: function get() {
    return v7_js_1["default"];
  }
});
var validate_js_1 = require("./validate.js");
Object.defineProperty(exports, "validate", {
  enumerable: true,
  get: function get() {
    return validate_js_1["default"];
  }
});
var version_js_1 = require("./version.js");
Object.defineProperty(exports, "version", {
  enumerable: true,
  get: function get() {
    return version_js_1["default"];
  }
});

},{"./max.js":94,"./nil.js":97,"./parse.js":98,"./stringify.js":102,"./v1.js":103,"./v1ToV6.js":104,"./v3.js":105,"./v4.js":107,"./v5.js":108,"./v6.js":109,"./v6ToV1.js":110,"./v7.js":111,"./validate.js":112,"./version.js":113}],94:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = 'ffffffff-ffff-ffff-ffff-ffffffffffff';

},{}],95:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
function md5(bytes) {
  var words = uint8ToUint32(bytes);
  var md5Bytes = wordsToMd5(words, bytes.length * 8);
  return uint32ToUint8(md5Bytes);
}
function uint32ToUint8(input) {
  var bytes = new Uint8Array(input.length * 4);
  for (var i = 0; i < input.length * 4; i++) {
    bytes[i] = input[i >> 2] >>> i % 4 * 8 & 0xff;
  }
  return bytes;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
  var xpad = new Uint32Array(getOutputLength(len)).fill(0);
  xpad.set(x);
  xpad[len >> 5] |= 0x80 << len % 32;
  xpad[xpad.length - 1] = len;
  x = xpad;
  var a = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;
  for (var i = 0; i < x.length; i += 16) {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }
  return Uint32Array.of(a, b, c, d);
}
function uint8ToUint32(input) {
  if (input.length === 0) {
    return new Uint32Array();
  }
  var output = new Uint32Array(getOutputLength(input.length * 8)).fill(0);
  for (var i = 0; i < input.length; i++) {
    output[i >> 2] |= (input[i] & 0xff) << i % 4 * 8;
  }
  return output;
}
function safeAdd(x, y) {
  var lsw = (x & 0xffff) + (y & 0xffff);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 0xffff;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}
exports["default"] = md5;

},{}],96:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);
exports["default"] = {
  randomUUID: randomUUID
};

},{}],97:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = '00000000-0000-0000-0000-000000000000';

},{}],98:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var validate_js_1 = require("./validate.js");
function parse(uuid) {
  if (!(0, validate_js_1["default"])(uuid)) {
    throw TypeError('Invalid UUID');
  }
  var v;
  return Uint8Array.of((v = parseInt(uuid.slice(0, 8), 16)) >>> 24, v >>> 16 & 0xff, v >>> 8 & 0xff, v & 0xff, (v = parseInt(uuid.slice(9, 13), 16)) >>> 8, v & 0xff, (v = parseInt(uuid.slice(14, 18), 16)) >>> 8, v & 0xff, (v = parseInt(uuid.slice(19, 23), 16)) >>> 8, v & 0xff, (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff, v / 0x100000000 & 0xff, v >>> 24 & 0xff, v >>> 16 & 0xff, v >>> 8 & 0xff, v & 0xff);
}
exports["default"] = parse;

},{"./validate.js":112}],99:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;

},{}],100:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    if (typeof crypto === 'undefined' || !crypto.getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
    getRandomValues = crypto.getRandomValues.bind(crypto);
  }
  return getRandomValues(rnds8);
}
exports["default"] = rng;

},{}],101:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}
function sha1(bytes) {
  var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
  var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
  var newBytes = new Uint8Array(bytes.length + 1);
  newBytes.set(bytes);
  newBytes[bytes.length] = 0x80;
  bytes = newBytes;
  var l = bytes.length / 4 + 2;
  var N = Math.ceil(l / 16);
  var M = new Array(N);
  for (var i = 0; i < N; ++i) {
    var arr = new Uint32Array(16);
    for (var j = 0; j < 16; ++j) {
      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
    }
    M[i] = arr;
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;
  for (var _i = 0; _i < N; ++_i) {
    var W = new Uint32Array(80);
    for (var t = 0; t < 16; ++t) {
      W[t] = M[_i][t];
    }
    for (var _t = 16; _t < 80; ++_t) {
      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
    }
    var a = H[0];
    var b = H[1];
    var c = H[2];
    var d = H[3];
    var e = H[4];
    for (var _t2 = 0; _t2 < 80; ++_t2) {
      var s = Math.floor(_t2 / 20);
      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return Uint8Array.of(H[0] >> 24, H[0] >> 16, H[0] >> 8, H[0], H[1] >> 24, H[1] >> 16, H[1] >> 8, H[1], H[2] >> 24, H[2] >> 16, H[2] >> 8, H[2], H[3] >> 24, H[3] >> 16, H[3] >> 8, H[3], H[4] >> 24, H[4] >> 16, H[4] >> 8, H[4]);
}
exports["default"] = sha1;

},{}],102:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unsafeStringify = void 0;
var validate_js_1 = require("./validate.js");
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).slice(1));
}
function unsafeStringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}
exports.unsafeStringify = unsafeStringify;
function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var uuid = unsafeStringify(arr, offset);
  if (!(0, validate_js_1["default"])(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }
  return uuid;
}
exports["default"] = stringify;

},{"./validate.js":112}],103:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateV1State = void 0;
var rng_js_1 = require("./rng.js");
var stringify_js_1 = require("./stringify.js");
var _state = {};
function v1(options, buf, offset) {
  var _options$_v, _options;
  var bytes;
  var isV6 = (_options$_v = (_options = options) === null || _options === void 0 ? void 0 : _options._v6) !== null && _options$_v !== void 0 ? _options$_v : false;
  if (options) {
    var optionsKeys = Object.keys(options);
    if (optionsKeys.length === 1 && optionsKeys[0] === '_v6') {
      options = undefined;
    }
  }
  if (options) {
    var _ref, _options$random, _options$rng, _options2;
    bytes = v1Bytes((_ref = (_options$random = options.random) !== null && _options$random !== void 0 ? _options$random : (_options$rng = (_options2 = options).rng) === null || _options$rng === void 0 ? void 0 : _options$rng.call(_options2)) !== null && _ref !== void 0 ? _ref : (0, rng_js_1["default"])(), options.msecs, options.nsecs, options.clockseq, options.node, buf, offset);
  } else {
    var now = Date.now();
    var rnds = (0, rng_js_1["default"])();
    updateV1State(_state, now, rnds);
    bytes = v1Bytes(rnds, _state.msecs, _state.nsecs, isV6 ? undefined : _state.clockseq, isV6 ? undefined : _state.node, buf, offset);
  }
  return buf !== null && buf !== void 0 ? buf : (0, stringify_js_1.unsafeStringify)(bytes);
}
function updateV1State(state, now, rnds) {
  var _state$msecs, _state$nsecs;
  (_state$msecs = state.msecs) !== null && _state$msecs !== void 0 ? _state$msecs : state.msecs = -Infinity;
  (_state$nsecs = state.nsecs) !== null && _state$nsecs !== void 0 ? _state$nsecs : state.nsecs = 0;
  if (now === state.msecs) {
    state.nsecs++;
    if (state.nsecs >= 10000) {
      state.node = undefined;
      state.nsecs = 0;
    }
  } else if (now > state.msecs) {
    state.nsecs = 0;
  } else if (now < state.msecs) {
    state.node = undefined;
  }
  if (!state.node) {
    state.node = rnds.slice(10, 16);
    state.node[0] |= 0x01;
    state.clockseq = (rnds[8] << 8 | rnds[9]) & 0x3fff;
  }
  state.msecs = now;
  return state;
}
exports.updateV1State = updateV1State;
function v1Bytes(rnds, msecs, nsecs, clockseq, node, buf) {
  var offset = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
  if (rnds.length < 16) {
    throw new Error('Random bytes length must be >= 16');
  }
  if (!buf) {
    buf = new Uint8Array(16);
    offset = 0;
  } else {
    if (offset < 0 || offset + 16 > buf.length) {
      throw new RangeError("UUID byte range ".concat(offset, ":").concat(offset + 15, " is out of buffer bounds"));
    }
  }
  msecs !== null && msecs !== void 0 ? msecs : msecs = Date.now();
  nsecs !== null && nsecs !== void 0 ? nsecs : nsecs = 0;
  clockseq !== null && clockseq !== void 0 ? clockseq : clockseq = (rnds[8] << 8 | rnds[9]) & 0x3fff;
  node !== null && node !== void 0 ? node : node = rnds.slice(10, 16);
  msecs += 12219292800000;
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  buf[offset++] = tl >>> 24 & 0xff;
  buf[offset++] = tl >>> 16 & 0xff;
  buf[offset++] = tl >>> 8 & 0xff;
  buf[offset++] = tl & 0xff;
  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  buf[offset++] = tmh >>> 8 & 0xff;
  buf[offset++] = tmh & 0xff;
  buf[offset++] = tmh >>> 24 & 0xf | 0x10;
  buf[offset++] = tmh >>> 16 & 0xff;
  buf[offset++] = clockseq >>> 8 | 0x80;
  buf[offset++] = clockseq & 0xff;
  for (var n = 0; n < 6; ++n) {
    buf[offset++] = node[n];
  }
  return buf;
}
exports["default"] = v1;

},{"./rng.js":100,"./stringify.js":102}],104:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var parse_js_1 = require("./parse.js");
var stringify_js_1 = require("./stringify.js");
function v1ToV6(uuid) {
  var v1Bytes = typeof uuid === 'string' ? (0, parse_js_1["default"])(uuid) : uuid;
  var v6Bytes = _v1ToV6(v1Bytes);
  return typeof uuid === 'string' ? (0, stringify_js_1.unsafeStringify)(v6Bytes) : v6Bytes;
}
exports["default"] = v1ToV6;
function _v1ToV6(v1Bytes) {
  return Uint8Array.of((v1Bytes[6] & 0x0f) << 4 | v1Bytes[7] >> 4 & 0x0f, (v1Bytes[7] & 0x0f) << 4 | (v1Bytes[4] & 0xf0) >> 4, (v1Bytes[4] & 0x0f) << 4 | (v1Bytes[5] & 0xf0) >> 4, (v1Bytes[5] & 0x0f) << 4 | (v1Bytes[0] & 0xf0) >> 4, (v1Bytes[0] & 0x0f) << 4 | (v1Bytes[1] & 0xf0) >> 4, (v1Bytes[1] & 0x0f) << 4 | (v1Bytes[2] & 0xf0) >> 4, 0x60 | v1Bytes[2] & 0x0f, v1Bytes[3], v1Bytes[8], v1Bytes[9], v1Bytes[10], v1Bytes[11], v1Bytes[12], v1Bytes[13], v1Bytes[14], v1Bytes[15]);
}

},{"./parse.js":98,"./stringify.js":102}],105:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.URL = exports.DNS = void 0;
var md5_js_1 = require("./md5.js");
var v35_js_1 = require("./v35.js");
var v35_js_2 = require("./v35.js");
Object.defineProperty(exports, "DNS", {
  enumerable: true,
  get: function get() {
    return v35_js_2.DNS;
  }
});
Object.defineProperty(exports, "URL", {
  enumerable: true,
  get: function get() {
    return v35_js_2.URL;
  }
});
function v3(value, namespace, buf, offset) {
  return (0, v35_js_1["default"])(0x30, md5_js_1["default"], value, namespace, buf, offset);
}
v3.DNS = v35_js_1.DNS;
v3.URL = v35_js_1.URL;
exports["default"] = v3;

},{"./md5.js":95,"./v35.js":106}],106:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.URL = exports.DNS = exports.stringToBytes = void 0;
var parse_js_1 = require("./parse.js");
var stringify_js_1 = require("./stringify.js");
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  var bytes = new Uint8Array(str.length);
  for (var i = 0; i < str.length; ++i) {
    bytes[i] = str.charCodeAt(i);
  }
  return bytes;
}
exports.stringToBytes = stringToBytes;
exports.DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
exports.URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
function v35(version, hash, value, namespace, buf, offset) {
  var _namespace;
  var valueBytes = typeof value === 'string' ? stringToBytes(value) : value;
  var namespaceBytes = typeof namespace === 'string' ? (0, parse_js_1["default"])(namespace) : namespace;
  if (typeof namespace === 'string') {
    namespace = (0, parse_js_1["default"])(namespace);
  }
  if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
    throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
  }
  var bytes = new Uint8Array(16 + valueBytes.length);
  bytes.set(namespaceBytes);
  bytes.set(valueBytes, namespaceBytes.length);
  bytes = hash(bytes);
  bytes[6] = bytes[6] & 0x0f | version;
  bytes[8] = bytes[8] & 0x3f | 0x80;
  if (buf) {
    offset = offset || 0;
    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = bytes[i];
    }
    return buf;
  }
  return (0, stringify_js_1.unsafeStringify)(bytes);
}
exports["default"] = v35;

},{"./parse.js":98,"./stringify.js":102}],107:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var native_js_1 = require("./native.js");
var rng_js_1 = require("./rng.js");
var stringify_js_1 = require("./stringify.js");
function v4(options, buf, offset) {
  var _ref, _options$random, _options$rng, _options;
  if (native_js_1["default"].randomUUID && !buf && !options) {
    return native_js_1["default"].randomUUID();
  }
  options = options || {};
  var rnds = (_ref = (_options$random = options.random) !== null && _options$random !== void 0 ? _options$random : (_options$rng = (_options = options).rng) === null || _options$rng === void 0 ? void 0 : _options$rng.call(_options)) !== null && _ref !== void 0 ? _ref : (0, rng_js_1["default"])();
  if (rnds.length < 16) {
    throw new Error('Random bytes length must be >= 16');
  }
  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80;
  if (buf) {
    offset = offset || 0;
    if (offset < 0 || offset + 16 > buf.length) {
      throw new RangeError("UUID byte range ".concat(offset, ":").concat(offset + 15, " is out of buffer bounds"));
    }
    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return (0, stringify_js_1.unsafeStringify)(rnds);
}
exports["default"] = v4;

},{"./native.js":96,"./rng.js":100,"./stringify.js":102}],108:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.URL = exports.DNS = void 0;
var sha1_js_1 = require("./sha1.js");
var v35_js_1 = require("./v35.js");
var v35_js_2 = require("./v35.js");
Object.defineProperty(exports, "DNS", {
  enumerable: true,
  get: function get() {
    return v35_js_2.DNS;
  }
});
Object.defineProperty(exports, "URL", {
  enumerable: true,
  get: function get() {
    return v35_js_2.URL;
  }
});
function v5(value, namespace, buf, offset) {
  return (0, v35_js_1["default"])(0x50, sha1_js_1["default"], value, namespace, buf, offset);
}
v5.DNS = v35_js_1.DNS;
v5.URL = v35_js_1.URL;
exports["default"] = v5;

},{"./sha1.js":101,"./v35.js":106}],109:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var stringify_js_1 = require("./stringify.js");
var v1_js_1 = require("./v1.js");
var v1ToV6_js_1 = require("./v1ToV6.js");
function v6(options, buf, offset) {
  options !== null && options !== void 0 ? options : options = {};
  offset !== null && offset !== void 0 ? offset : offset = 0;
  var bytes = (0, v1_js_1["default"])(_objectSpread(_objectSpread({}, options), {}, {
    _v6: true
  }), new Uint8Array(16));
  bytes = (0, v1ToV6_js_1["default"])(bytes);
  if (buf) {
    for (var i = 0; i < 16; i++) {
      buf[offset + i] = bytes[i];
    }
    return buf;
  }
  return (0, stringify_js_1.unsafeStringify)(bytes);
}
exports["default"] = v6;

},{"./stringify.js":102,"./v1.js":103,"./v1ToV6.js":104}],110:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var parse_js_1 = require("./parse.js");
var stringify_js_1 = require("./stringify.js");
function v6ToV1(uuid) {
  var v6Bytes = typeof uuid === 'string' ? (0, parse_js_1["default"])(uuid) : uuid;
  var v1Bytes = _v6ToV1(v6Bytes);
  return typeof uuid === 'string' ? (0, stringify_js_1.unsafeStringify)(v1Bytes) : v1Bytes;
}
exports["default"] = v6ToV1;
function _v6ToV1(v6Bytes) {
  return Uint8Array.of((v6Bytes[3] & 0x0f) << 4 | v6Bytes[4] >> 4 & 0x0f, (v6Bytes[4] & 0x0f) << 4 | (v6Bytes[5] & 0xf0) >> 4, (v6Bytes[5] & 0x0f) << 4 | v6Bytes[6] & 0x0f, v6Bytes[7], (v6Bytes[1] & 0x0f) << 4 | (v6Bytes[2] & 0xf0) >> 4, (v6Bytes[2] & 0x0f) << 4 | (v6Bytes[3] & 0xf0) >> 4, 0x10 | (v6Bytes[0] & 0xf0) >> 4, (v6Bytes[0] & 0x0f) << 4 | (v6Bytes[1] & 0xf0) >> 4, v6Bytes[8], v6Bytes[9], v6Bytes[10], v6Bytes[11], v6Bytes[12], v6Bytes[13], v6Bytes[14], v6Bytes[15]);
}

},{"./parse.js":98,"./stringify.js":102}],111:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateV7State = void 0;
var rng_js_1 = require("./rng.js");
var stringify_js_1 = require("./stringify.js");
var _state = {};
function v7(options, buf, offset) {
  var bytes;
  if (options) {
    var _ref, _options$random, _options$rng;
    bytes = v7Bytes((_ref = (_options$random = options.random) !== null && _options$random !== void 0 ? _options$random : (_options$rng = options.rng) === null || _options$rng === void 0 ? void 0 : _options$rng.call(options)) !== null && _ref !== void 0 ? _ref : (0, rng_js_1["default"])(), options.msecs, options.seq, buf, offset);
  } else {
    var now = Date.now();
    var rnds = (0, rng_js_1["default"])();
    updateV7State(_state, now, rnds);
    bytes = v7Bytes(rnds, _state.msecs, _state.seq, buf, offset);
  }
  return buf !== null && buf !== void 0 ? buf : (0, stringify_js_1.unsafeStringify)(bytes);
}
function updateV7State(state, now, rnds) {
  var _state$msecs, _state$seq;
  (_state$msecs = state.msecs) !== null && _state$msecs !== void 0 ? _state$msecs : state.msecs = -Infinity;
  (_state$seq = state.seq) !== null && _state$seq !== void 0 ? _state$seq : state.seq = 0;
  if (now > state.msecs) {
    state.seq = rnds[6] << 23 | rnds[7] << 16 | rnds[8] << 8 | rnds[9];
    state.msecs = now;
  } else {
    state.seq = state.seq + 1 | 0;
    if (state.seq === 0) {
      state.msecs++;
    }
  }
  return state;
}
exports.updateV7State = updateV7State;
function v7Bytes(rnds, msecs, seq, buf) {
  var offset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
  if (rnds.length < 16) {
    throw new Error('Random bytes length must be >= 16');
  }
  if (!buf) {
    buf = new Uint8Array(16);
    offset = 0;
  } else {
    if (offset < 0 || offset + 16 > buf.length) {
      throw new RangeError("UUID byte range ".concat(offset, ":").concat(offset + 15, " is out of buffer bounds"));
    }
  }
  msecs !== null && msecs !== void 0 ? msecs : msecs = Date.now();
  seq !== null && seq !== void 0 ? seq : seq = rnds[6] * 0x7f << 24 | rnds[7] << 16 | rnds[8] << 8 | rnds[9];
  buf[offset++] = msecs / 0x10000000000 & 0xff;
  buf[offset++] = msecs / 0x100000000 & 0xff;
  buf[offset++] = msecs / 0x1000000 & 0xff;
  buf[offset++] = msecs / 0x10000 & 0xff;
  buf[offset++] = msecs / 0x100 & 0xff;
  buf[offset++] = msecs & 0xff;
  buf[offset++] = 0x70 | seq >>> 28 & 0x0f;
  buf[offset++] = seq >>> 20 & 0xff;
  buf[offset++] = 0x80 | seq >>> 14 & 0x3f;
  buf[offset++] = seq >>> 6 & 0xff;
  buf[offset++] = seq << 2 & 0xff | rnds[10] & 0x03;
  buf[offset++] = rnds[11];
  buf[offset++] = rnds[12];
  buf[offset++] = rnds[13];
  buf[offset++] = rnds[14];
  buf[offset++] = rnds[15];
  return buf;
}
exports["default"] = v7;

},{"./rng.js":100,"./stringify.js":102}],112:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var regex_js_1 = require("./regex.js");
function validate(uuid) {
  return typeof uuid === 'string' && regex_js_1["default"].test(uuid);
}
exports["default"] = validate;

},{"./regex.js":99}],113:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var validate_js_1 = require("./validate.js");
function version(uuid) {
  if (!(0, validate_js_1["default"])(uuid)) {
    throw TypeError('Invalid UUID');
  }
  return parseInt(uuid.slice(14, 15), 16);
}
exports["default"] = version;

},{"./validate.js":112}],114:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o("next", 0), o("throw", 1), o("return", 2); } }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
var io = require('socket.io-client');
var mediasoupClient = require('mediasoup-client');
var socket = io("/mediasoup");
socket.on('connection-success', function (_ref) {
  var socketId = _ref.socketId;
  console.log('Connected with socket ID:', socketId);
});
var device;
var rtpCapabilities;
var producerTransport;
var consumerTransport;
var videoProducer;
var audioProducer;
var roomId;
var screenVideoProducer = null;
var screenAudioProducer = null;
var consumers = new Map();
socket.on('activeSpeaker', function (_ref2) {
  var peerId = _ref2.peerId;
  // Now receives peerId
  // Remove all highlights
  document.querySelectorAll('.tile').forEach(function (t) {
    return t.classList.remove('active');
  });
  console.log('CLIENT activeSpeaker', peerId);
  // Highlight video for this peer
  var videoEl = peerVideos.get(peerId);
  if (videoEl) {
    videoEl.classList.add('active');
    videoEl.scrollIntoView({
      behavior: 'smooth',
      block: 'nearest'
    });
  }
});
socket.on('disconnect', function () {
  // Show room setup again
  roomControlsDiv.style.display = 'none';
  roomSetupDiv.style.display = 'block';
  displayRoomCodeSpan.textContent = 'N/A';
  copyRoomCodeButton.style.display = 'none';
  console.log('Disconnected from server');
  localVideo.srcObject = null;
  remoteVideos.srcObject = null;
  // Reset room state
  roomId = null;
  device = null;
  rtpCapabilities = null;
  producerTransport = null;
  consumerTransport = null;
  videoProducer = null;
  audioProducer = null;
  //consumer = null;
  consumers.forEach(function (_ref3) {
    var consumer = _ref3.consumer;
    return consumer === null || consumer === void 0 ? void 0 : consumer.close();
  });
  consumers.clear();
});
socket.on('error', function (error) {
  console.error('Socket error:', error);
});
var videoparams = {
  encodings: [{
    rid: 'r0',
    maxBitrate: 100000,
    scalabilityMode: 'S1T3'
  }, {
    rid: 'r1',
    maxBitrate: 300000,
    scalabilityMode: 'S1T3'
  }, {
    rid: 'r2',
    maxBitrate: 900000,
    scalabilityMode: 'S1T3'
  }],
  codecOptions: {
    videoGoogleStartBitrate: 1000
  }
};
var audioParams = {
  track: null,
  // will be filled with stream.getAudioTracks()[0]
  codecOptions: {
    opusStereo: false,
    // mono keeps bit-rate low
    opusFec: true,
    // forward-error-correction for packet-loss
    opusDtx: true,
    // silent-period suppression make it false for now
    opusMaxPlaybackRate: 48000,
    opusPtime: 20
  },
  encodings: [{
    maxBitrate: 64000 // 64 kbps is crisp for speech
  }]
};

// ICE servers configuration - make sure these work
var iceServers = [{
  urls: 'stun:stun.l.google.com:19302'
}, {
  urls: 'stun:stun1.l.google.com:19302'
}, {
  urls: 'turn:relay1.expressturn.com:3480',
  username: '000000002065332507',
  credential: '2dm9ltTqJIjVrRq/LI/QvTm0nPY='
}];

// DOM elements
var localVideo = document.getElementById('localVideo');
var remoteVideos = document.getElementById('remoteVideos');
var btnJoinRoom = document.getElementById('btnJoinRoom');
var btnCreateRoom = document.getElementById('btnCreateRoom');
var roomCodeInput = document.getElementById('roomCodeInput'); // Input for joining
var displayRoomCodeSpan = document.getElementById('displayRoomCode'); // To show created room code
var copyRoomCodeButton = document.getElementById('copyRoomCode'); // New button to copy
var roomSetupDiv = document.getElementById('roomSetup'); // To hide after joining/creating
var roomControlsDiv = document.getElementById('roomControls'); // To show after joining/creating
var btnShareScreen = document.getElementById('btnShareScreen');
// const btnStopScreenShare = document.getElementById('btnStopScreenShare');
var btnToggleMic = document.getElementById('btnToggleMic');
var btnToggleCam = document.getElementById('btnToggleCam');

// Add at top with other variables
var peerVideos = new Map(); // Maps peer IDs to video elements

function addRemoteMedia(producerId, track, kind, peerId) {
  // Add peerId parameter
  if (consumers.has(producerId)) return;
  var el;
  if (kind === 'audio') {
    el = document.createElement('audio');
    el.controls = false;
    el.muted = false;
  } else {
    el = document.createElement('video');
    el.playsInline = true;

    // Store video element with peer ID
    peerVideos.set(peerId, el);
  }
  el.autoplay = true;
  el.srcObject = new MediaStream([track]);
  document.getElementById(kind === 'audio' ? 'remoteAudios' : 'remoteVideos').appendChild(el);
  el.classList.add('tile');

  // Store peerId with consumer entry
  consumers.set(producerId, {
    el: el,
    consumer: null,
    peerId: peerId
  }); // Add peerId here
}
function removeRemoteMedia(producerId) {
  var _entry$consumer;
  var entry = consumers.get(producerId);
  if (!entry) return;

  // Remove from peerVideos if video
  if (entry.el.tagName === 'VIDEO') {
    peerVideos["delete"](entry.peerId);
  }
  entry.el.remove();
  (_entry$consumer = entry.consumer) === null || _entry$consumer === void 0 ? void 0 : _entry$consumer.close();
  consumers["delete"](producerId);
}
var streamSuccess = /*#__PURE__*/function () {
  var _ref4 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(stream) {
    var videotrack, audiotrack;
    return _regenerator().w(function (_context) {
      while (1) switch (_context.n) {
        case 0:
          try {
            localVideo.srcObject = stream;
            videotrack = stream.getVideoTracks()[0];
            audiotrack = stream.getAudioTracks()[0];
            videoparams.track = videotrack;
            audioParams.track = audiotrack;
            console.log('Local stream set successfully');
          } catch (error) {
            console.error('Error in streamSuccess:', error);
          }
        case 1:
          return _context.a(2);
      }
    }, _callee);
  }));
  return function streamSuccess(_x) {
    return _ref4.apply(this, arguments);
  };
}();
function pickMic() {
  return _pickMic.apply(this, arguments);
}
function _pickMic() {
  _pickMic = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee12() {
    var list, mic;
    return _regenerator().w(function (_context12) {
      while (1) switch (_context12.n) {
        case 0:
          _context12.n = 1;
          return navigator.mediaDevices.enumerateDevices();
        case 1:
          list = _context12.v;
          mic = list.find(function (d) {
            return d.kind === 'audioinput' && /headset|earbuds|headphone/i.test(d.label);
          }) || list.find(function (d) {
            return d.kind === 'audioinput' && d.deviceId !== 'default';
          }) || list.find(function (d) {
            return d.kind === 'audioinput';
          });
          return _context12.a(2, mic === null || mic === void 0 ? void 0 : mic.deviceId);
      }
    }, _callee12);
  }));
  return _pickMic.apply(this, arguments);
}
var getLocalStream = /*#__PURE__*/function () {
  var _ref5 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2() {
    var micId, stream;
    return _regenerator().w(function (_context2) {
      while (1) switch (_context2.n) {
        case 0:
          console.log('Selecting best mic…');
          _context2.n = 1;
          return pickMic();
        case 1:
          micId = _context2.v;
          _context2.n = 2;
          return navigator.mediaDevices.getUserMedia({
            audio: {
              deviceId: micId ? {
                exact: micId
              } : undefined,
              noiseSuppression: true,
              echoCancellation: true,
              autoGainControl: true,
              sampleRate: 48000,
              channelCount: 1
            },
            video: {
              width: {
                min: 640,
                max: 1920
              },
              height: {
                min: 400,
                max: 1080
              }
            }
          });
        case 2:
          stream = _context2.v;
          streamSuccess(stream);
        case 3:
          return _context2.a(2);
      }
    }, _callee2);
  }));
  return function getLocalStream() {
    return _ref5.apply(this, arguments);
  };
}();
var createDevice = /*#__PURE__*/function () {
  var _ref6 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3() {
    var _t;
    return _regenerator().w(function (_context3) {
      while (1) switch (_context3.n) {
        case 0:
          _context3.p = 0;
          if (rtpCapabilities) {
            _context3.n = 1;
            break;
          }
          console.error('RTP capabilities not loaded');
          throw new Error('RTP capabilities not loaded');
        case 1:
          device = new mediasoupClient.Device();
          _context3.n = 2;
          return device.load({
            routerRtpCapabilities: rtpCapabilities
          });
        case 2:
          console.log('Device created successfully');
          console.log('Device RTP Capabilities:', device.rtpCapabilities);
          _context3.n = 4;
          break;
        case 3:
          _context3.p = 3;
          _t = _context3.v;
          console.error('Device creation error:', _t);
          if (_t.name === 'UnsupportedError') {
            console.error('Browser not supported');
          }
        case 4:
          return _context3.a(2);
      }
    }, _callee3, null, [[0, 3]]);
  }));
  return function createDevice() {
    return _ref6.apply(this, arguments);
  };
}();
var getRtpCapabilities = function getRtpCapabilities() {
  return new Promise(function (resolve, reject) {
    socket.emit('getRtpCapabilities', function (data) {
      if (data.error) {
        console.error('Error getting RTP capabilities:', data.error);
        reject(data.error);
        return;
      }
      console.log('Router RTP Capabilities received');
      rtpCapabilities = data.rtpCapabilities;
      resolve();
    });
  });
};
var createSendTransport = function createSendTransport() {
  return new Promise(function (resolve, reject) {
    if (!device) {
      var error = 'Device not initialized';
      console.error(error);
      reject(error);
      return;
    }
    console.log(roomId);
    socket.emit('createWebRtcTransport', {
      sender: true,
      roomId: roomId
    }, function (response) {
      var _response$params;
      if (response.error || (_response$params = response.params) !== null && _response$params !== void 0 && _response$params.error) {
        var _error = response.error || response.params.error;
        console.error('Transport creation error:', _error);
        reject(_error);
        return;
      }
      console.log('Producer transport params:', response.params);

      // Create transport with ICE servers
      producerTransport = device.createSendTransport(_objectSpread(_objectSpread({}, response.params), {}, {
        iceServers: iceServers
      }));

      // Enhanced logging for debugging
      producerTransport.on('connect', /*#__PURE__*/function () {
        var _ref8 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(_ref7, callback, errback) {
          var dtlsParameters, _t2;
          return _regenerator().w(function (_context4) {
            while (1) switch (_context4.n) {
              case 0:
                dtlsParameters = _ref7.dtlsParameters;
                console.log('Producer transport connect event triggered');
                _context4.p = 1;
                _context4.n = 2;
                return new Promise(function (resolve, reject) {
                  socket.emit('transport-connect', {
                    dtlsParameters: dtlsParameters,
                    transportId: producerTransport.id,
                    roomId: roomId
                  }, function (error) {
                    console.log("socket emit done");
                    if (error) {
                      console.error('Transport connect server error:', error);
                      reject(error);
                    } else {
                      console.log('Transport connect server success');
                      resolve();
                    }
                  });
                });
              case 2:
                console.log("trying to callback");
                callback();
                _context4.n = 4;
                break;
              case 3:
                _context4.p = 3;
                _t2 = _context4.v;
                console.error('Transport connect error:', _t2);
                errback(_t2);
              case 4:
                return _context4.a(2);
            }
          }, _callee4, null, [[1, 3]]);
        }));
        return function (_x2, _x3, _x4) {
          return _ref8.apply(this, arguments);
        };
      }());
      producerTransport.on('produce', /*#__PURE__*/function () {
        var _ref9 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5(parameters, callback, errback) {
          var _t3;
          return _regenerator().w(function (_context5) {
            while (1) switch (_context5.n) {
              case 0:
                console.log('Producer transport produce event triggered');
                console.log("now i will try to go in the tansport produce");
                _context5.p = 1;
                console.log("in the try");
                _context5.n = 2;
                return new Promise(function (resolve, reject) {
                  socket.emit('transport-produce', {
                    kind: parameters.kind,
                    rtpParameters: parameters.rtpParameters,
                    appData: parameters.appData,
                    transportId: producerTransport.id,
                    roomId: roomId
                  }, function (response) {
                    if (response.error) {
                      console.error('Produce server error:', response.error);
                      reject(response.error);
                    } else {
                      console.log('Produce server success, ID:', response.id);
                      resolve(response.id);
                    }
                  });
                }).then(function (id) {
                  callback({
                    id: id
                  });
                });
              case 2:
                _context5.n = 4;
                break;
              case 3:
                _context5.p = 3;
                _t3 = _context5.v;
                console.error('Produce event error:', _t3);
                errback(_t3);
              case 4:
                return _context5.a(2);
            }
          }, _callee5, null, [[1, 3]]);
        }));
        return function (_x5, _x6, _x7) {
          return _ref9.apply(this, arguments);
        };
      }());
      producerTransport.on('connectionstatechange', function (state) {
        console.log('Producer transport connection state:', state);
        if (state === 'connected') {
          console.log('Producer transport connected successfully!');
        } else if (state === 'failed') {
          console.error('Producer transport connection failed!');
        }
      });
      producerTransport.on('iceconnectionstatechange', function (state) {
        console.log('Producer ICE connection state:', state);
        if (state === 'connected') {
          console.log('Producer ICE connected!');
        } else if (state === 'failed') {
          console.error('Producer ICE connection failed!');
        }
      });
      producerTransport.on('icegatheringstatechange', function (state) {
        console.log('Producer ICE gathering state:', state);
      });
      resolve(producerTransport);
    });
  });
};
var connectSendTransport = /*#__PURE__*/function () {
  var _ref0 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6() {
    var _t4;
    return _regenerator().w(function (_context6) {
      while (1) switch (_context6.n) {
        case 0:
          _context6.p = 0;
          if (producerTransport) {
            _context6.n = 1;
            break;
          }
          throw new Error('Producer transport not created');
        case 1:
          if (videoparams.track) {
            _context6.n = 2;
            break;
          }
          throw new Error('No video track available');
        case 2:
          // 1. VIDEO
          console.log('Starting to produce video...');
          _context6.n = 3;
          return producerTransport.produce(_objectSpread(_objectSpread({
            track: videoparams.track
          }, videoparams), {}, {
            // encodings / codecOptions
            kind: 'video'
          }));
        case 3:
          videoProducer = _context6.v;
          console.log('videoProducer created successfully:', videoProducer.id);
          videoProducer.on('trackended', function () {
            var _videoProducer;
            console.log('Video track ended');
            (_videoProducer = videoProducer) === null || _videoProducer === void 0 ? void 0 : _videoProducer.close(); // clean up
          });
          videoProducer.on('transportclose', function () {
            console.log('Video producer transport closed');
            videoProducer = null;
          });

          // 2. AUDIO
          console.log('Starting to produce audio...');
          if (!audioParams.track) {
            _context6.n = 5;
            break;
          }
          _context6.n = 4;
          return producerTransport.produce(_objectSpread(_objectSpread({
            track: audioParams.track
          }, audioParams), {}, {
            kind: 'audio'
          }));
        case 4:
          audioProducer = _context6.v;
        case 5:
          console.log('audioProducer created successfully:', audioProducer.id);
          audioProducer.on('trackended', function () {
            var _audioProducer;
            console.log('Audio track ended');
            (_audioProducer = audioProducer) === null || _audioProducer === void 0 ? void 0 : _audioProducer.close();
          });
          audioProducer.on('transportclose', function () {
            console.log('Audio producer transport closed');
            audioProducer = null;
          });
          console.log('Produced video & audio:', !!videoProducer, !!audioProducer);
          _context6.n = 7;
          break;
        case 6:
          _context6.p = 6;
          _t4 = _context6.v;
          console.error('Error in connectSendTransport:', _t4);
          throw _t4;
        case 7:
          return _context6.a(2);
      }
    }, _callee6, null, [[0, 6]]);
  }));
  return function connectSendTransport() {
    return _ref0.apply(this, arguments);
  };
}();
var createRecvTransport = function createRecvTransport() {
  return new Promise(function (resolve, reject) {
    if (!device) {
      var error = 'Device not initialized';
      console.error(error);
      reject(error);
      return;
    }
    console.log(roomId);
    socket.emit('createWebRtcTransport', {
      sender: false,
      roomId: roomId
    }, function (response) {
      var _response$params2;
      if (response.error || (_response$params2 = response.params) !== null && _response$params2 !== void 0 && _response$params2.error) {
        var _error2 = response.error || response.params.error;
        console.error('Consumer transport creation error:', _error2);
        reject(_error2);
        return;
      }
      console.log('Consumer transport params:', response.params);
      consumerTransport = device.createRecvTransport(_objectSpread(_objectSpread({}, response.params), {}, {
        iceServers: iceServers
      }));
      consumerTransport.on('connect', /*#__PURE__*/function () {
        var _ref10 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7(_ref1, callback, errback) {
          var dtlsParameters, _t5;
          return _regenerator().w(function (_context7) {
            while (1) switch (_context7.n) {
              case 0:
                dtlsParameters = _ref1.dtlsParameters;
                console.log('Consumer transport connect event triggered');
                _context7.p = 1;
                _context7.n = 2;
                return new Promise(function (resolve, reject) {
                  socket.emit('transport-recv-connect', {
                    dtlsParameters: dtlsParameters,
                    transportId: consumerTransport.id,
                    roomId: roomId
                  }, function (error) {
                    if (error) {
                      console.error('Consumer transport connect server error:', error);
                      reject(error);
                    } else {
                      console.log('Consumer transport connect server success');
                      resolve();
                    }
                  });
                });
              case 2:
                callback();
                _context7.n = 4;
                break;
              case 3:
                _context7.p = 3;
                _t5 = _context7.v;
                console.error('Consumer transport connect error:', _t5);
                errback(_t5);
              case 4:
                return _context7.a(2);
            }
          }, _callee7, null, [[1, 3]]);
        }));
        return function (_x8, _x9, _x0) {
          return _ref10.apply(this, arguments);
        };
      }());
      consumerTransport.on('connectionstatechange', function (state) {
        console.log('Consumer transport connection state:', state);
        if (state === 'connected') {
          console.log('Consumer transport connected successfully!');
        } else if (state === 'failed') {
          console.error('Consumer transport connection failed!');
        }
      });
      consumerTransport.on('iceconnectionstatechange', function (state) {
        console.log('Consumer ICE connection state:', state);
      });
      resolve(consumerTransport);
    });
  });
};
var connectRecvTransport = /*#__PURE__*/function () {
  var _ref11 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8(producerInfo) {
    var _device, _yield$Promise, params, consumer, _t6;
    return _regenerator().w(function (_context8) {
      while (1) switch (_context8.n) {
        case 0:
          _context8.p = 0;
          if (consumerTransport) {
            _context8.n = 1;
            break;
          }
          throw new Error('Consumer transport not created');
        case 1:
          if ((_device = device) !== null && _device !== void 0 && _device.rtpCapabilities) {
            _context8.n = 2;
            break;
          }
          throw new Error('Device capabilities not available');
        case 2:
          console.log('Starting to consume media...', producerInfo);

          // 1. Ask server for consume params
          _context8.n = 3;
          return new Promise(function (resolve, reject) {
            socket.emit('consume', {
              producerId: producerInfo.producerId,
              rtpCapabilities: device.rtpCapabilities,
              roomId: roomId
            }, function (data) {
              if (data.error) reject(data.error);else resolve(data);
            });
          });
        case 3:
          _yield$Promise = _context8.v;
          params = _yield$Promise.params;
          _context8.n = 4;
          return consumerTransport.consume({
            id: params.id,
            producerId: params.producerId,
            kind: params.kind,
            rtpParameters: params.rtpParameters,
            paused: true
          });
        case 4:
          consumer = _context8.v;
          addRemoteMedia(params.producerId, consumer.track, params.kind, params.peerId);

          // 5. Resume on server
          _context8.n = 5;
          return new Promise(function (resolve, reject) {
            socket.emit('consumer-resume', {
              consumerId: consumer.id,
              roomId: roomId
            }, function (error) {
              if (error) reject(error);else resolve();
            });
          });
        case 5:
          console.log('Consumer created & resumed:', consumer.id);
          return _context8.a(2, consumer);
        case 6:
          _context8.p = 6;
          _t6 = _context8.v;
          console.error('connectRecvTransport error:', _t6);
          throw _t6;
        case 7:
          return _context8.a(2);
      }
    }, _callee8, null, [[0, 6]]);
  }));
  return function connectRecvTransport(_x1) {
    return _ref11.apply(this, arguments);
  };
}();
var setupMediasoupPipeline = /*#__PURE__*/function () {
  var _ref12 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee9() {
    var _t7;
    return _regenerator().w(function (_context9) {
      while (1) switch (_context9.n) {
        case 0:
          roomSetupDiv.style.display = 'none'; // hide immediately
          _context9.p = 1;
          _context9.n = 2;
          return getLocalStream();
        case 2:
          _context9.n = 3;
          return getRtpCapabilities();
        case 3:
          _context9.n = 4;
          return createDevice();
        case 4:
          _context9.n = 5;
          return createSendTransport();
        case 5:
          _context9.n = 6;
          return connectSendTransport();
        case 6:
          _context9.n = 7;
          return createRecvTransport();
        case 7:
          // We'll consume producers as they become available in the room
          console.log('Mediasoup pipeline initialized.');
          // wire controls only AFTER producers are ready
          document.getElementById('btnToggleMic').addEventListener('click', toggleMic);
          document.getElementById('btnToggleCam').addEventListener('click', toggleCam);

          // roomSetupDiv.style.display = 'none'; // Hide room setup controls
          roomControlsDiv.style.display = 'block'; // Show video elements and call buttons
          _context9.n = 9;
          break;
        case 8:
          _context9.p = 8;
          _t7 = _context9.v;
          console.error('Error setting up Mediasoup pipeline:', _t7);
          alert('Failed to set up video call. See console for details.');
          // Potentially disable UI elements or show error to user
        case 9:
          return _context9.a(2);
      }
    }, _callee9, null, [[1, 8]]);
  }));
  return function setupMediasoupPipeline() {
    return _ref12.apply(this, arguments);
  };
}();
function toggleScreenShare() {
  return _toggleScreenShare.apply(this, arguments);
}
function _toggleScreenShare() {
  _toggleScreenShare = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee13() {
    var _screenAudioProducer, stream, _stream$getVideoTrack, _stream$getVideoTrack2, videoTrack, _stream$getAudioTrack, _stream$getAudioTrack2, audioTrack;
    return _regenerator().w(function (_context13) {
      while (1) switch (_context13.n) {
        case 0:
          if (!screenVideoProducer) {
            _context13.n = 1;
            break;
          }
          screenVideoProducer.close();
          (_screenAudioProducer = screenAudioProducer) === null || _screenAudioProducer === void 0 ? void 0 : _screenAudioProducer.close();
          screenVideoProducer = screenAudioProducer = null;
          return _context13.a(2);
        case 1:
          _context13.n = 2;
          return navigator.mediaDevices.getDisplayMedia({
            video: true,
            // always required
            audio: {
              echoCancellation: true,
              noiseSuppression: true,
              autoGainControl: true,
              sampleRate: 48000,
              channelCount: 1
            } // shows “Share audio” checkbox if available
          });
        case 2:
          stream = _context13.v;
          _stream$getVideoTrack = stream.getVideoTracks(), _stream$getVideoTrack2 = _slicedToArray(_stream$getVideoTrack, 1), videoTrack = _stream$getVideoTrack2[0];
          _stream$getAudioTrack = stream.getAudioTracks(), _stream$getAudioTrack2 = _slicedToArray(_stream$getAudioTrack, 1), audioTrack = _stream$getAudioTrack2[0]; // Produce the screen video
          _context13.n = 3;
          return producerTransport.produce({
            track: videoTrack,
            kind: 'video'
          });
        case 3:
          screenVideoProducer = _context13.v;
          if (!audioTrack) {
            _context13.n = 5;
            break;
          }
          _context13.n = 4;
          return producerTransport.produce({
            track: audioTrack,
            kind: 'audio'
          });
        case 4:
          screenAudioProducer = _context13.v;
        case 5:
          // Auto-close when user clicks “Stop sharing” in the browser UI
          videoTrack.onended = toggleScreenShare;
        case 6:
          return _context13.a(2);
      }
    }, _callee13);
  }));
  return _toggleScreenShare.apply(this, arguments);
}
function toggleMic() {
  var btn = document.getElementById('btnToggleMic');
  if (audioProducer && !audioProducer.paused) {
    audioProducer.pause(); // mute local mic
    btn.textContent = '🎤 Mic OFF';
  } else if (audioProducer) {
    audioProducer.resume(); // un-mute mic
    btn.textContent = '🎤 Mic ON';
  }
}
function toggleCam() {
  var btn = document.getElementById('btnToggleCam');
  if (videoProducer && !videoProducer.paused) {
    videoProducer.pause(); // turn camera off
    btn.textContent = '📹 Cam OFF';
  } else if (videoProducer) {
    videoProducer.resume(); // turn camera on
    btn.textContent = '📹 Cam ON';
  }
}
var CreateRoom = /*#__PURE__*/function () {
  var _ref13 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee0() {
    return _regenerator().w(function (_context0) {
      while (1) switch (_context0.n) {
        case 0:
          try {
            // Request the server to create a room and get a unique ID
            socket.emit('createRoom', function (response) {
              if (response.error) {
                console.error('Error creating room:', response.error);
                alert('Failed to create room: ' + response.error);
                return;
              }
              roomId = response.roomId;
              console.log('Room created with ID:', roomId);
              displayRoomCodeSpan.textContent = roomId; // Display the room code to the user
              copyRoomCodeButton.style.display = 'inline-block'; // Show copy button

              setupMediasoupPipeline();
            });
          } catch (error) {
            console.error('Error in CreateRoom:', error);
          }
        case 1:
          return _context0.a(2);
      }
    }, _callee0);
  }));
  return function CreateRoom() {
    return _ref13.apply(this, arguments);
  };
}();
var JoinRoom = /*#__PURE__*/function () {
  var _ref14 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee10() {
    var enteredRoomId;
    return _regenerator().w(function (_context10) {
      while (1) switch (_context10.n) {
        case 0:
          enteredRoomId = roomCodeInput.value.trim();
          if (enteredRoomId) {
            _context10.n = 1;
            break;
          }
          alert('Please enter a room code.');
          return _context10.a(2);
        case 1:
          roomId = enteredRoomId;
          try {
            // Inform the server about joining a room
            socket.emit('joinRoom', {
              roomId: roomId
            }, /*#__PURE__*/function () {
              var _ref15 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee1(response) {
                return _regenerator().w(function (_context1) {
                  while (1) switch (_context1.n) {
                    case 0:
                      if (!response.error) {
                        _context1.n = 1;
                        break;
                      }
                      console.error('Error joining room:', response.error);
                      alert('Failed to join room: ' + response.error);
                      return _context1.a(2);
                    case 1:
                      console.log('Successfully joined room:', roomId);
                      displayRoomCodeSpan.textContent = roomId; // Also display for joiners
                      copyRoomCodeButton.style.display = 'inline-block'; // Show copy button

                      // Now, set up Mediasoup pipeline
                      _context1.n = 2;
                      return setupMediasoupPipeline();
                    case 2:
                      // After joining, we need to request existing producers in the room
                      requestExistingProducers();
                    case 3:
                      return _context1.a(2);
                  }
                }, _callee1);
              }));
              return function (_x10) {
                return _ref15.apply(this, arguments);
              };
            }());
          } catch (error) {
            console.error('Error in JoinRoom:', error);
          }
        case 2:
          return _context10.a(2);
      }
    }, _callee10);
  }));
  return function JoinRoom() {
    return _ref14.apply(this, arguments);
  };
}();
var requestExistingProducers = function requestExistingProducers() {
  var _videoProducer2, _audioProducer2;
  console.log("trying to get the producers in the room");
  var myPids = [(_videoProducer2 = videoProducer) === null || _videoProducer2 === void 0 ? void 0 : _videoProducer2.id, (_audioProducer2 = audioProducer) === null || _audioProducer2 === void 0 ? void 0 : _audioProducer2.id].filter(Boolean);
  socket.emit('getProducersInRoom', {
    roomId: roomId
  }, function (response) {
    if (response.error) {
      console.error('Error getting producers in room:', response.error);
      return;
    }
    console.log('Existing producers in room:', response.producerIds);
    response.producerIds.forEach(/*#__PURE__*/function () {
      var _ref16 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee11(producerId) {
        return _regenerator().w(function (_context11) {
          while (1) switch (_context11.n) {
            case 0:
              if (!myPids.includes(producerId)) {
                // Don't consume our own producer
                // Request server for consumer parameters for this producer
                socket.emit('consume', {
                  producerId: producerId,
                  rtpCapabilities: device.rtpCapabilities,
                  roomId: roomId
                }, function (consumerResponse) {
                  if (consumerResponse.error) {
                    console.error('Error creating consumer for existing producer:', consumerResponse.error);
                    return;
                  }
                  console.log('Consumer response for existing producer:', consumerResponse.params);
                  connectRecvTransport(consumerResponse.params); // Use the data from the server
                });
              }
            case 1:
              return _context11.a(2);
          }
        }, _callee11);
      }));
      return function (_x11) {
        return _ref16.apply(this, arguments);
      };
    }());
  });
};

// Listener for new producers in the room (from other participants)
socket.on('newProducer', function (data) {
  var _videoProducer3, _audioProducer3;
  console.log('New producer announced:', data);
  var myPids = [(_videoProducer3 = videoProducer) === null || _videoProducer3 === void 0 ? void 0 : _videoProducer3.id, (_audioProducer3 = audioProducer) === null || _audioProducer3 === void 0 ? void 0 : _audioProducer3.id].filter(Boolean);
  if (data.producerId && !myPids.includes(data.producerId)) {
    // Don't consume our own producer
    // Request server for consumer parameters for this new producer
    socket.emit('consume', {
      producerId: data.producerId,
      rtpCapabilities: device.rtpCapabilities,
      roomId: roomId
    }, function (consumerResponse) {
      if (consumerResponse.error) {
        console.error('Error creating consumer for new producer:', consumerResponse.error);
        return;
      }
      console.log('Consumer response for new producer:', consumerResponse.params);
      connectRecvTransport(consumerResponse.params);
    });
  }
});

// Listener for producers removed from the room
socket.on('producerClosed', function (_ref17) {
  var producerId = _ref17.producerId;
  console.log('Producer closed:', producerId);
  removeRemoteMedia(producerId);
});

// --- UI Event Listeners ---
btnJoinRoom.addEventListener('click', JoinRoom);
btnCreateRoom.addEventListener('click', CreateRoom);
copyRoomCodeButton.addEventListener('click', function () {
  var roomCode = displayRoomCodeSpan.textContent;
  if (roomCode) {
    navigator.clipboard.writeText(roomCode).then(function () {
      alert('Room code copied to clipboard!');
    })["catch"](function (err) {
      console.error('Failed to copy room code: ', err);
      alert('Failed to copy room code. Please copy manually: ' + roomCode);
    });
  }
});

// Hide video controls and copy button initially
document.addEventListener('DOMContentLoaded', function () {
  roomControlsDiv.style.display = 'none';
  copyRoomCodeButton.style.display = 'none';
});
document.addEventListener('DOMContentLoaded', function () {
  document.getElementById('btnShareScreen').addEventListener('click', toggleScreenShare);
  // document.getElementById('btnToggleMic')  .addEventListener('click', toggleMic);
  // document.getElementById('btnToggleCam')  .addEventListener('click', toggleCam);
});

// let recording = false;
// let paused    = false;

// const btnStart  = document.getElementById('btnStartRec');
// const btnPause  = document.getElementById('btnPauseRec');
// const btnResume = document.getElementById('btnResumeRec');
// const btnStop   = document.getElementById('btnStopRec');

// function updateButtons() {
//   btnStart.disabled   = recording;
//   btnPause.disabled   = !recording || paused;
//   btnResume.disabled  = !recording || !paused;
//   btnStop.disabled    = !recording;
// }

// function send(cmd) {
//   socket.emit(cmd, { roomId });
// }

// btnStart.addEventListener('click',  () => { send('startRecording');  recording = true;  paused = false; updateButtons(); });
// btnPause.addEventListener('click',  () => { send('pauseRecording');  paused = true;    updateButtons(); });
// btnResume.addEventListener('click', () => { send('resumeRecording'); paused = false;   updateButtons(); });
// btnStop.addEventListener('click',   () => { send('stopRecording');   recording = false; paused = false; updateButtons(); });

},{"mediasoup-client":67,"socket.io-client":80}]},{},[114]);
